<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我做了一个奇奇怪怪的视频网站</title>
      <link href="2022/12/25/221225-%E4%B8%80%E4%B8%AA%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99/"/>
      <url>2022/12/25/221225-%E4%B8%80%E4%B8%AA%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E8%A7%86%E9%A2%91%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<p>  最近在家羊了一周，发烧、咳嗽是一样也没落下。躺在床上头晕沉沉之际，想起我还有一个<a class="link" href="https://www.ray0728.cn/2021/08/26/210826-%E4%BA%91%E4%B8%8A%E5%88%A9%E7%94%A8Aria%E6%90%AD%E5%BB%BA%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/">《云上下载工具》<i class="fas fa-external-link-alt"></i></a>呢，反正躺着也没什么事儿，就上去看看以前下发的下载任务完成得怎么样了吧。<br><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/12/24/Screenshot_20221224_122338.jpg" alt="下载完成情况"><br>  看样子任务都顺利的完成了呢，但是下载好的视频只能通过SCP的方式从云上拷贝下来再播放，否则也仅仅只是显示一个名字而已，不过幸好我的小云上还有一个<a class="link" href="https://www.ray0728.cn/2021/09/15/210915-%E8%AE%A9%E5%B0%8F%E4%BA%91%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E5%9C%A8%E7%BA%BF%E6%92%AD%E6%94%BE/">视频播放平台<i class="fas fa-external-link-alt"></i></a>。于是乎一个奇奇怪怪的想法就这样冒了出来。</p><h3 id="推流播放"><a href="#推流播放" class="headerlink" title="推流播放"></a>推流播放</h3><p>  如果小云能在Aria2下载完成后，自动将视频推送给我的播放平台。那么不就可以在线观看视频了吗？不过我的小云配置低，管道小。如果将高清视频直接推送上去，不仅对主机资源消耗大，对外网带宽要求也极高。毕竟图像越清晰，单帧图像的大小越大，就越需要的带宽来进行传输。而如果想使用较低的带宽传输，那么就意味着需要降低图像的清晰度。他们三者有一个简单的大小关系：</p><table><thead><tr><th align="center">图像清晰度</th><th align="center">单桢图像数据大小</th><th align="center">外网带宽大小</th></tr></thead><tbody><tr><td align="center">清晰</td><td align="center">大</td><td align="center">大</td></tr><tr><td align="center">模糊</td><td align="center">小</td><td align="center">小</td></tr></tbody></table><p>  看来需要在视频推流的时候做些优化调整了。</p><h4 id="帧率、分辨率、码率与清晰度的关系"><a href="#帧率、分辨率、码率与清晰度的关系" class="headerlink" title="帧率、分辨率、码率与清晰度的关系"></a>帧率、分辨率、码率与清晰度的关系</h4><p>  任何一个视频文件都会有很多参数，但是最主要的三个参数是：</p><ul><li>帧率：每秒显示画面数量，数值越大视频越流畅。</li><li>分辨率：图像的尺寸大小，一般以“长 x 宽”来表示。</li><li>码率：每秒显示的图片进行压缩后的数据量。</li></ul><p>  从它们的定义中，能看出帧率和分辨率与画面的清晰度并没有直接的关系。当我们以越高的帧率和越高的分辨率播放视频时除了产生巨大的数据量（帧率x分辨率）之外，似乎也并不改变视频本身的清晰度。</p><p>  而这个巨大的数据/码率则是视频中的压缩比，压缩比越大则视频画面越糟糕。码率与画面清晰程度有正相关关系。</p><p>  因此，如果原始视频是720P的分辨率，将画面放大到1080P，并以相同的帧率和码率播放，则压缩比较原始文件更大，画面变模糊。而如果原始分辨率为1080P，缩小到720P进行播放，则压缩比反而变小，视频更清晰。</p><p>  同样，如果视频分辨率保持在相同的配置下，码率越大，则压缩比越小，画面越清晰。但是所产生的文件也越大。</p><p>  上述的基本知识点，对于接下来的要做的动作非常重要，为了在小水管的云上得到最佳播放效果，需要以此为依据，在帧率、分辨率、码率三者中找到平衡点。</p><h4 id="FFMpeg推流"><a href="#FFMpeg推流" class="headerlink" title="FFMpeg推流"></a>FFMpeg推流</h4><p>  FFMPEG中支持用以下参数设置视频输出帧率、分辨率以及码率：</p><blockquote><p>-r[:stream_specifier] fps (input/output,per-stream) 设置视频帧率，单位Hz<br>-b:v 设置视频的码率，如果仅设置这一个参数，则将以该码率为固定码率输出视频<br>-minrate/maxrate 最小/大码率，设置其中任意一个参数将以动态码率的形式输出视频<br>-vf scale 设置输出视频缩放大小</p></blockquote><p>  经过不断的摸索，以下配置是比较适合我的小水管云，当然一定也会有其他的配置可以达到更好的效果。</p><p><code>ffmpeg -b:v 900k -maxrate 1000k -vf scale=-1:720 -r film</code></p><h3 id="何时推流"><a href="#何时推流" class="headerlink" title="何时推流"></a>何时推流</h3><p>  上面既已摸索出了FFMPEG推流所需的配置参数，那么剩下的就是考虑在何时触发推流了。</p><h4 id="方案一：下载完成后即自动进行推流、切片"><a href="#方案一：下载完成后即自动进行推流、切片" class="headerlink" title="方案一：下载完成后即自动进行推流、切片"></a>方案一：下载完成后即自动进行推流、切片</h4><p>  利用Aria2下载完成后可自动触发指定脚本的特点，最大限度利用云计算的资源，将视频下载与切片无缝链接。待切片完成后，用户便可在任何时候进行观看。</p><p>  但是该方案也有明显的不足之处，首先切片后的文件需要占用磁盘空间，相当于下载一部电影用了两倍的空间进行保存，对于资源有限的小云来说不划算。其次还需要对分片后的数据做额外的管理，得不偿失。作为私有云，更多的使用场景是作为云端下载器，完成下载后再将文件拷贝至本地而已，从长远来看所有下载的文件都仅是临时存放在云上而已</p><h4 id="方案二：需要观看时再触发推流"><a href="#方案二：需要观看时再触发推流" class="headerlink" title="方案二：需要观看时再触发推流"></a>方案二：需要观看时再触发推流</h4><p>  这有点类似点播功能，在需要的时候对指定的视频进行推流播放。但是如果没有优秀的前端和后端配合，实际使用体验可能没有想象中那么美好。</p><p>  举个简单的例子：前端在播放的时候用户拖拉了一下播放进度，此时前端需要判断当前进度条被拖拉到什么位置，并转换为对应的时长，然后通过调用后端的reset接口将信息向后传递。后端收到之后再通过FFMPEG进行跳时处理，并重新开始切片。有必要的话，还需要将结果反馈给前端。</p><p>  所以要让点播具有良好的体验，就需要投入时间优化和完善配套的前后端处理逻辑。这对于我这样的个人站点来说，不是好主意。</p><h4 id="方案三：对下载的视频做循环推流"><a href="#方案三：对下载的视频做循环推流" class="headerlink" title="方案三：对下载的视频做循环推流"></a>方案三：对下载的视频做循环推流</h4><p>  该方案有点像是方案一的改良版，因为是循环推流，因此并不需要时时刻刻保存完整的视频切片文件，只需要保留时间窗内的切片数据即可，这样对磁盘存储空间的压力就减少很多。同时由于是循环推流播放，那么只要等待足够的时间，总会看完一部视频，而不会因为错过了一次，就再也看不到了。更重要的是逻辑相对简单。</p><h5 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h5><p>  基于小云的实际情况，我选择了方案三作为推流的时机。一种简易的实现手段就是利用脚本，循环遍历指定目录下的文件，如果是视频文件，则推流给指定的服务器即可。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#! /bin/bashfunction read_dir(){  for file in `ls $1`  do  if [ -d $1"/"$file ]   then     read_dir $1"/"$file   else     type=${file##*.}     if [ $type = 'mp4' ] || [ $type = 'mkv' ]     then       docker run --rm -it -v $1:/videos --network netbeta registry.cn-hangzhou.aliyuncs.com/ossrs/srs:encoder \       ffmpeg \              -re -i /videos/$file \              -c:a aac -q:a 0.8 \              -c:v libx264 -b:v 900k -maxrate 1000k \              -vf scale=-1:720 \              -r film \              -g 3 \              -f flv rtmp://stream/live/movie     fi     sleep 10  fi  done}root_dir=`pwd`IFS=$'\n'while truedo  read_dir $root_dir  sleep 5doneIFS=$'\t\n'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  运行上述脚本后，系统将自动将下载好的视频循环推流给我的视频播放平台，从而实现循环播放的效果。如果有新的视频文件下载完成，也会在下一轮的遍历循环中发现，并加入推流当中。而我只需要在需要的时候通过浏览器访问指定的m3u8文件即可观看视频。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/12/25/Video_20221225_082815_477.gif" alt="播放效果"></p><p>  而且实际的清晰度也还能接受。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/12/25/Screenshot_20221225_220420.jpg" alt="实际清晰度"></p><h3 id="前端设计"><a href="#前端设计" class="headerlink" title="前端设计"></a>前端设计</h3><p>  一切进展都挺顺利，但又似乎缺了点什么。如果只有一部视频在循环播放那还行，反正不是看见片头就是看见片尾，但如果有几部视频在依次循环播放呢？每次播放都像是开盲盒一样，永远猜不到会看到哪一部视频了。我急切的需要一个能告诉我这一切的后端。</p><p>  为了减少后端对系统资源的开销，这次我选择以Python作为后端的开发语言。</p><p>####播放时刻表<br>  与其等到视频播放时才获取视频名称，还不如学学影院，提前规划好当天的放映时刻表，这样不仅能知道当前在播放什么，还能预知接下来会播放什么。</p><p>  要实现这样的目的，最重要的是获取视频的时长。幸运的是FFMPEG早就替我们准备好了获取工具。</p><p>  FFMPEG提供了一个子工具ffprobe，可以读取视频文件的容器信息，其中就包含有时长。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">cmd = "ffprobe -show_entries format=duration -v quiet -of flat -i {}".format(path)duration = Shell.exec(cmd,True)duration = float(duration.split("=\"")[1].rstrip("\"\n"))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  获取到视频时长后就可以按照一天的放映时间窗口（比如早上6点至晚上11点），进行排片。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">start = FilmSchedule.OPEN_TIMEwhile(start &lt;= FilmSchedule.CLOSE_TIME and len(self.films.keys()) &gt; 0 ):    for film in self.films.keys():        time = self.tranlateTime(start)        self.timetable[film].append(time)        self.playlist.append({'path':self.films[film]['path'], 'time':start})        start += self.films[film]['duration']        if(start &gt; FilmSchedule.CLOSE_TIME):            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  代码是从后端代码(common/sys/schedule.py)中截取的一部分，大概逻辑是从OPEN_TIME开始，依次叠加所有视频的时长，每次叠加的结果均是下一个视频开始播放的时间，直到播放时间超过CLOSE_TIME。</p><p>####视频截图<br>  有了播放时间，如果能在前端同时展示几张视频的截图就更好了，这样就能提前看到视频的播放效果。</p><p>  而利用FFMPEG，对视频截图也是轻松的事情。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def snapshot(self, path, num):        image = "./snap.jpg"        timestamp = 360        snapshotList = []        for offset in range(num):          cmd = " ".join(["ffmpeg", "-ss", str(timestamp), "-i", path, "-r", "1", "-frames:v", "1", "-s", "352x288", "-q:v", "2", "-f", "image2", "-y", image])          Shell.exec(cmd, True)          timestamp += 10*60          with open(image, 'rb') as f:            imgfile = f.read()            snapshotList.append(str(base64.b64encode(imgfile), encoding='utf-8'))        return snapshotList<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  为了减少截图的大小，我将图片大小缩小到CIF尺寸，同时为了尽可能显示不一样的视频内容（连续截图，很可能是同一张画面），每次截图均向后跳转了10分钟。</p><h4 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h4><p>  配合上BootStrap的响应效果，最终前端显示效果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/12/22/_2022-12-22T14-39-34.633Z.png" alt="大屏幕显示效果"></p><p>  如果在移动设备上则显示这样的效果：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/12/22/_2022-12-22T14-43-25.413Z.png" alt="移动设备显示效果"></p><p>代码已在<a class="link" href="https://gitee.com/ray0728/movie">Gitee<i class="fas fa-external-link-alt"></i></a>开源，欢迎大家进行修改与改进，也期待与大家的交流。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> FFMpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学摸鱼之Excel小技巧(八) 利用透视表自定义数据信息组合</title>
      <link href="2022/11/22/221108-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E5%85%AB)%E9%80%8F%E8%A7%86%E8%A1%A8%E7%9A%84%E6%8B%86%E5%88%86%E7%BB%84%E5%90%88/"/>
      <url>2022/11/22/221108-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E5%85%AB)%E9%80%8F%E8%A7%86%E8%A1%A8%E7%9A%84%E6%8B%86%E5%88%86%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/logo.png" alt="logo.png" style="zoom:50%;"><p>  接<a class="link" href="https://www.ray0728.cn/2022/10/28/221028-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%B8%83)-%E6%83%B3%E6%80%8E%E4%B9%88%E6%8E%92%E5%B0%B1%E6%80%8E%E4%B9%88%E6%8E%92/">上一期<i class="fas fa-external-link-alt"></i></a>我们分享了表格排序的小技巧，本期我们继续聊一聊Excel其它看上去很酷炫的操作。</p><p>  本期内容同样是天选打工人熬夜整理出来的，吐血推荐。</p><p>  下面就开始我们今天的<strong>摸鱼小技巧</strong>吧。</p><hr><p>  数据透视表是Excel一项非常重要的功能，特别是在做数据分析的时候，透视表拥有举足轻重的地位。当然要熟练使用透视表所需要付出的学习成本也并不低，今天并不打算对使用透视表做入门介绍，而是以一个工作中可能出现的场景跟大家分享一下如何利用透视表实现信息的快速组合排列。</p><p>  一般正经的公司都会给自己的员工设计工作证（工卡），上面会有员工的姓名、部门甚至工号等基本信息，比如下面这样：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/11/IDCard.png" alt="工卡样例"></p><p>  那么如果某天老板需要我们根据员工信息表对每位员工生成一张带基础信息的工卡照，我们该怎么做呢？方法肯定有千千万万，不过咱的主题是Excel，那么就来看看用Excel怎么做吧。</p><span id="more"></span><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>  首先我们需要在数据表中设计出我们工作证的模板，这里可以任意发挥。比如我设计的是这样的风格：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/11/145474a74dbfe12ee5932e5aad494769.jpg" alt="工卡模板"></p><p>  里面包含了基本的姓名工号等信息，最顶上也有公司（瞎编的一个名字）信息。这样一个简单的工作证模板就做好了。</p><h3 id="创建透视表"><a href="#创建透视表" class="headerlink" title="创建透视表"></a>创建透视表</h3><p>  下面再来看看我们的员工信息表长啥样，其实就是我前几章中用到的数据表，是不是有些熟悉？☺</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/11/53b7646e4ee665b88aac9608b5bfbfd9.jpg" alt="员工名单"></p><p>  我们选中它，并点击插入数据透视表，并根据工作证模板中的内容选取“照片”、“姓名”、“工号”、“部门”（为了方便，我这里选取的是二级部门信息）。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/13/gifski06cbac85cef9f283.gif" alt="创建透视表"></p><p>  由于工作证模板设计是从上到下的的排列，因此在报表字段中按模板中的顺序将字段都放在<strong>行</strong>当中。</p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/12/1.jpg" alt="数据字段" style="zoom:67%;"><p>  如果Excel没有自动打开报表字段窗口，可先在数据表中选中数据报表区域，然后点击数<strong>据透视表分析</strong>菜单中的<strong>字段列表</strong>即可显示。</p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/12/0275a7976052c390e0b71ff457301628.jpg" alt="菜单入口" style="zoom:50%;"><p>  然后再选择以<strong>压缩布局</strong>的方式进行显示透视图，通过以上的操作，我们就能把工作证所需的内容安装模板的顺序排列整齐。</p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/12/57420b74b13c1858879af33a7f57e1d8.jpg" alt="压缩布局" style="zoom:50%;"><h3 id="调整布局"><a href="#调整布局" class="headerlink" title="调整布局"></a>调整布局</h3><p>  仔细观察工作证模板会发现，姓名与照片之间有一个空行，而照片上方也有一个空行和一个公司名称信息。如果将<strong>空行</strong>也作为因此工作证上的数据实际是按照下述表格进行排列的：</p><table><thead><tr><th align="center">工作卡中的信息</th><th align="center">举例数据</th><th align="center">当前透视表数据</th></tr></thead><tbody><tr><td align="center">公司名称</td><td align="center">RAY TECH EMPEEY ID CARD</td><td align="center">/</td></tr><tr><td align="center"><em>空行</em></td><td align="center"><em>&lt;空白数据&gt;</em></td><td align="center">/</td></tr><tr><td align="center"><strong>照片</strong></td><td align="center">假装此处有照片</td><td align="center">/</td></tr><tr><td align="center"><em>空行</em></td><td align="center"><em>&lt;空白数据&gt;</em></td><td align="center"><strong>照片</strong></td></tr><tr><td align="center"><strong>姓名</strong></td><td align="center">Ray0728</td><td align="center">姓名</td></tr><tr><td align="center"><strong>工号</strong></td><td align="center">RID_1234567890</td><td align="center">工号</td></tr><tr><td align="center"><strong>部门</strong></td><td align="center">科学摸鱼办公室</td><td align="center">二级部门</td></tr></tbody></table><p>  显然透视表中现有的数据无法和工作证中所需数据是无法匹配上的，如果按逐行对应来看，甚至会出现错位（行）的情况。</p><p>  因此我们还需要向透视表中插入更多的内容。以便数据表的数据能完全符合工作证的要求。但是透视表只能插入原数据表中已有的内容，无法插入自定义内容。那么<strong>怎样向透视表中插入数据表中没有的内容呢？</strong></p><h4 id="透视表的节点汇聚"><a href="#透视表的节点汇聚" class="headerlink" title="透视表的节点汇聚"></a>透视表的节点汇聚</h4><p>  在处理这个问题前，我们需要了解一点透视表的简单小常识。Excel支持<strong>为每一个项目后插入空行</strong>，这里的项目是指数据透视表中的一级分组或者一级节点。节点是以透视表行字段的先后顺序来决定的，相同的节点会自动合并，比如我们将部门信息作为第一节点，那么这个部门下的所有数据都将汇聚在一个节点下。</p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/13/4af119006c55dfff572a889d086a882e.jpg" alt="节点汇聚" style="zoom:67%;"><p>  因此透视表行字段的顺序一定要特别留意，通过<strong>调整顺序以便透视表结果符合我们的预期</strong>。</p><p>  知道上面这个小常识后，再回头看我们的问题，数据透视表是无法插入原数据表中没有的内容，但是从我们的工作证模板中能知道没有的数据不是空行就是固定的公司信息，而我们在<a class="link" href="https://www.ray0728.cn/2022/10/17/221016-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E5%9B%9B)-%E5%8D%95%E5%85%83%E6%A0%BC%E6%A0%BC%E5%BC%8F/">《单元格格式更智能》<i class="fas fa-external-link-alt"></i></a>分享了一种简单的单元格内容隐藏方法<kbd>;;;</kbd>。</p><p>  结合在一起就有了解决的思路，就是通过向透视表行字段的合适位置中插入无关紧要的字段（首字段必须是唯一的），<strong>避免数据错位（行）的情况</strong>，同时在模板上对应的单元格上设置格式为<kbd>;;;</kbd>，将这些无关的数据隐藏即可。因此我们可以得到以下字段信息。</p><table><thead><tr><th align="center">工作卡中的信息</th><th align="center">透视表数据</th></tr></thead><tbody><tr><td align="center">公司名称</td><td align="center">\</td></tr><tr><td align="center"><em>空行</em></td><td align="center">电话号码</td></tr><tr><td align="center"><strong>照片</strong></td><td align="center">照片</td></tr><tr><td align="center"><em>空行</em></td><td align="center">入职时间</td></tr><tr><td align="center"><strong>姓名</strong></td><td align="center">姓名</td></tr><tr><td align="center"><strong>工号</strong></td><td align="center">工号</td></tr><tr><td align="center"><strong>部门</strong></td><td align="center">二级部门</td></tr></tbody></table><p>  最后再利用Excel可向数据透视表中插入空行的功能，最终实现如下效果：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/13/0a3292ef9f9222b7dbcca0f1d40ca8aa.jpg" alt="增加信息后的行字段"></p><p>  注意看，第11行和19行都有一个空行，后续字段中也有同样的空行。</p><h3 id="批量生成"><a href="#批量生成" class="headerlink" title="批量生成"></a>批量生成</h3><p>  至此我们的数据都准备好了，现在可以开始批量生成我们的员工工作证了。首先从透视表中将数据拷贝至新的Sheet页中，当然也可以拷贝至任何想保存的地方。</p><p>  注意拷贝后的粘贴，需要选择<strong>值粘贴</strong>。</p><h4 id="值粘贴"><a href="#值粘贴" class="headerlink" title="值粘贴"></a>值粘贴</h4><p>  Excel拷贝数据之后，在粘贴的时候可以选择粘贴内容，比如<strong>粘贴公式、数值以及格式</strong>等等。我们首先将透视表的数值粘贴至新的区域。</p><p>  方法很简单，使用鼠标右键粘贴时，选择对应的图标即可。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/13/gifski727a556cccca112f.gif" alt="复制透视表数值"></p><p>  注意粘贴的时候错一行粘贴。</p><h4 id="模板复制"><a href="#模板复制" class="headerlink" title="模板复制"></a>模板复制</h4><p>  有了数据后，就需要将工作证模板复制到刚刚粘贴的数据当中正确的位置上，这里我们使用简单的<strong>数据组函数</strong>来实现。</p><p>  因为模板中的工作证一共有7行，因此选中7个单元格，然后直接输入<code>=工卡模板!$A$1:$A:$7</code>，然后按下<kbd>CTRL+SHIFT+ENTER</kbd>。此时工作表会自动变成下列数据：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/13/418a709c14068e58b7770e126bfa5b27.jpg" alt="组函数"></p><p>  之后就只需要将这7行复制给剩余的行即可。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/13/gifski1421b0bdcf493de9.gif" alt="函数复制"></p><p>  注意这里需要使用<strong>函数粘贴</strong>，其使用方法和值粘贴类似。</p><h4 id="格式复制"><a href="#格式复制" class="headerlink" title="格式复制"></a>格式复制</h4><p>  现在我们的工作证数据表中的数据已全部准备就绪，接着将模板的格式（比如单元格颜色、字体样式等等）复制给所有的数据单元格即可。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/13/gifski.gif" alt="格式复制"></p><p>  这个时候已经能看见员工工作证的雏形了，但是由于是默认的行高和列宽，所以显示效果并不算好，比如工号由于单元格列宽限制，只能显示为####，而照片单元格又显得太短了。为了更好的显示工作证，需要对数据表中的特定单元格进行行高、列宽的调整。</p><h4 id="行高列宽调整"><a href="#行高列宽调整" class="headerlink" title="行高列宽调整"></a>行高列宽调整</h4><p>  以照片单元格举例，每个人员的工作证都会有这样一个单元格，但是如果分别对每一个员工的工作证进行行高调整，似乎太费体力了，有没有什么办法可以批量对特定单元格进行调整呢？当然是有的。</p><p>  我们利用Excel的查找替换功能，以<strong>照片</strong>作为关键字对当前数据表进行搜索，在搜索结果中能看到所有相关的单元格信息。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/13/0a95f14e4b487f388db48363ac2593b9.jpg" alt="批量搜索"></p><p>  使用<kbd>CTRL + A </kbd>，将所有结果全选上。然后在开始菜单的单元格选项中，选择<strong>格式</strong>下拉菜单。这样就可以对搜索结果批量进行行高和列宽的设置。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/13/5096e2cb7008cea46d05b82fd65121e4.jpg" alt="调整行高列宽"></p><p>  这样我们就可以简单快速的对我们的内容进行行高、列宽的调整以便达到最佳的显示效果。</p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>  如文章开头所说<strong>透视表</strong>是Excel一个重要的功能，但是它绝不是仅仅用来做数据分析，如果能灵活使用，它还能做很多意料之外的事。</p><p>  当然Excel的小技巧不止于此，有特别想了解的，或困惑的都可以给我留言。在后面的摸鱼小技巧中再跟大家分享总结吧。</p>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让在线代码编辑器更加丰富</title>
      <link href="2022/11/08/221108-CodeMirror%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
      <url>2022/11/08/221108-CodeMirror%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>  在<a class="link" href="https://www.ray0728.cn/2021/06/20/210620-%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">《搭建Selenium在线执行环境》<i class="fas fa-external-link-alt"></i></a>中，基于<a class="link" href="https://codemirror.net/6/">CodeMirror<i class="fas fa-external-link-alt"></i></a>我做了一个界面简单的在线代码编辑器，界面大概就长这个样子：</p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/20/Screenshot_20210620_232604_mark.via.jpg" alt="UI" style="zoom: 33%;"><p>  输入输出均是利用CodeMirror完成的，只不过设计了不同的显示风格而已。输入框支持语法高亮、行号等特性，而输出框则模拟终端的黑白输出以及简单的行号显示。</p><p>  前后端通过WebSocket进行简单的消息发送，后来在<a class="link" href="https://www.ray0728.cn/2022/10/10/221010-%E8%AE%A9WebSocket%E6%94%AF%E6%8C%81Oauth2-TOKEN%E9%AA%8C%E8%AF%81%E7%9A%84%E5%B0%9D%E8%AF%95/">《让WebSocket支持Oauth2-TOKEN验证的尝试》<i class="fas fa-external-link-alt"></i></a>中，通过改造后端，让前后端的通信不仅变更安全，也能传送更多类型的数据了。那么当前的输出界面就变得有些简陋了，毕竟当前无法显示除了字符串之外的其它内容，前端的改造势在必行。不仅要显示文本内容，还要让它显示更多富媒体的信息。</p><span id="more"></span><p>  CodeMirror使用<code>replaceSelection</code>将文本内容指定插入的位置，但是这个接口仅支持插入文本内容，并不支持插入其它数据。</p><blockquote><p><a href="https://codemirror.net/docs/ref/#state.EditorState.replaceSelection"><strong>replaceSelection</strong></a>(text: string | Text) → TransactionSpec</p><p>Create a <a class="link" href="https://codemirror.net/docs/ref/#state.TransactionSpec">transaction spec<i class="fas fa-external-link-alt"></i></a> that replaces every selection range with the given content.</p></blockquote><p>  如果要插入别的内容得想想其它的办法，这里顺道提一下初次使用CodeMirror的API时，不会那么容易理解每个API的作用，甚至不太容易找到需要的API接口，这与近代编程语言易于理解的API写法存在不小的区别。比如，通常使用<code>insertXXX</code>表示插入某种类型、使用<code>append</code>表示在末尾追加，但是在CodeMirror中很难直接找到对应的API。</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>  既然从API中一时半会也没找到可直接使用的API，那么不妨先看看文本内容在CodeMirror中是如何显示的吧。</p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/08/codemirror-code.png" alt="code"><p>  如上图，在CodeMirror中显示一行文本，并在HTML代码中查看这行文本是如何显示的，很容易地能看出文本在CodeMirror中就是一个<kbd>div</kbd>块，看来上文中用到的API，最终是创建了这么一个块呀，这就有意思了。</p><p>  如果我能自定义div的内容，比如包装一张图片，岂不是也能在CodeMirror中显示了？那么我们想在CodeMirror中显示富文本信息的诉求就变成<strong>如何在CodeMirror中插入HTML自定义元素了</strong>。</p><p>  幸运的是，CodeMirror提供了一个添加Widget的接口<code>addLineWidget</code>。换句话讲我们可以通过这个接口可以向CodeMirror添加任意一个HTML对象。</p><blockquote><pre class="line-numbers language-none"><code class="language-none">doc.addLineWidget(line: integer|LineHandle, node: Element, ?options: object) → LineWidget<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>Adds a line widget, an element shown below a line, spanning the whole of the editor’s width, and moving the lines below it downwards. <code>line</code> should be either an integer or a line handle, and <code>node</code> should be a DOM node, which will be displayed below the given line. <code>options</code>, when given, should be an object that configures the behavior of the widget. The following options are supported (all default to false):</p><ul><li><p><code>coverGutter: boolean</code></p><p>Whether the widget should cover the gutter.</p></li><li><p><code>noHScroll: boolean</code></p><p>Whether the widget should stay fixed in the face of horizontal scrolling.</p></li><li><p><code>above: boolean</code></p><p>Causes the widget to be placed above instead of below the text of the line.</p></li><li><p><code>handleMouseEvents: boolean</code></p><p>Determines whether the editor will capture mouse and drag events occurring in this widget. Default is false—the events will be left alone for the default browser handler, or specific handlers on the widget, to capture.</p></li><li><p><code>insertAt: integer</code></p><p>By default, the widget is added below other widgets for the line. This option can be used to place it at a different position (zero for the top, N to put it after the Nth other widget). Note that this only has effect once, when the widget is created.</p></li><li><p><code>className: string</code></p><p>Add an extra CSS class name to the wrapper element created for the widget.</p></li></ul><p>Note that the widget node will become a descendant of nodes with CodeMirror-specific CSS classes, and those classes might in some cases affect it. This method returns an object that represents the widget placement. It’ll have a <code>line</code> property pointing at the line handle that it is associated with, and the following methods:</p><ul><li><p><code>clear()</code></p><p>Removes the widget.</p></li><li><p><code>changed()</code></p><p>Call this if you made some change to the widget’s DOM node that might affect its height. It’ll force CodeMirror to update the height of the line that contains the widget.</p></li></ul></blockquote><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>  既然找到了解决办法，剩下的就好办多了，结合我自己网站的实际情况，将该接口进行了二次封装，这样更方便调用。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token parameter">type<span class="token punctuation">,</span> src</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> node<span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>            node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> src<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>            node <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"img"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">"data:image/png;base64, "</span> <span class="token operator">+</span> src<span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token parameter">cm<span class="token punctuation">,</span> type<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> mark</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> lastline <span class="token operator">=</span> cm<span class="token punctuation">.</span><span class="token function">lineCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cm<span class="token punctuation">.</span><span class="token function">setCursor</span><span class="token punctuation">(</span>lastline<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>type<span class="token punctuation">.</span>isElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cm<span class="token punctuation">.</span><span class="token function">addLineWidget</span><span class="token punctuation">(</span>lastline<span class="token punctuation">,</span> <span class="token function">createElement</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span>node<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> above<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">// cm.replaceRange(msg, { line: lastline, ch: 0 }, { line: lastline });</span>        cm<span class="token punctuation">.</span><span class="token function">replaceSelection</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mark<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cm<span class="token punctuation">.</span><span class="token function">markText</span><span class="token punctuation">(</span><span class="token punctuation">{</span> line<span class="token operator">:</span> lastline <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> ch<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> line<span class="token operator">:</span> lastline <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> ch<span class="token operator">:</span> msg<span class="token punctuation">.</span>length <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> css<span class="token operator">:</span> <span class="token string">"color: #FF6347"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  函数逻辑相对简单，如果需要添加Widget，则根据传入的Widget类型，自行判断是创建<kbd>p</kbd>还是<kbd>img</kbd>对象（当然这里可以任意扩展其它的类型对象），然后调用<kbd>addLineWidget</kbd>将组件添加进指定行即可。</p><p>  如果是普通的文本，则还是按以前的<kbd>replaceSelection</kbd>进行添加。为了满足对特定文本内容突出显示，这里单独使用了<kbd>markText</kbd>接口，它可以对指定文本设置其css样式。</p><p><strong>注意：</strong>使用每次调用addLineWidget，仅能添加一个网页控件(对象），也就是说所添加的内容是独占一行的。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/11/08/gifski.gif" alt="富媒体"></p><p>  前端将输入的指令通过WebSocket（带OAUTH2 TOKEN）传递给后端，并在后端解析运行。运行结果再通过WebSocket发回前端。虽然后端服务是以Docker运行，但是从安全角度考虑，后端对可执行的Shell命令做了限制（包括且不限于禁用重定向、高危命令、长时执行等）。</p><p><a class="link" href="https://gitee.com/ray0728/resource/blob/js/src/main/resources/static/js/cm.js">源码已在Gitee上标记TAG<i class="fas fa-external-link-alt"></i></a>。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeMirror </tag>
            
            <tag> Bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学摸鱼之Excel小技巧(七) 排序就得听我的</title>
      <link href="2022/10/28/221028-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%B8%83)-%E6%83%B3%E6%80%8E%E4%B9%88%E6%8E%92%E5%B0%B1%E6%80%8E%E4%B9%88%E6%8E%92/"/>
      <url>2022/10/28/221028-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%B8%83)-%E6%83%B3%E6%80%8E%E4%B9%88%E6%8E%92%E5%B0%B1%E6%80%8E%E4%B9%88%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/logo.png" alt="logo.png" style="zoom:50%;"><p>  接<a class="link" href="https://www.ray0728.cn/2022/10/25/221026-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E5%85%AD)-%E8%B6%85%E7%BA%A7%E7%AD%9B%E9%80%89/">上一期<i class="fas fa-external-link-alt"></i></a>我们分享了用高级筛选更快更好的进行组合筛选小技巧，本期我们继续聊一聊Excel其它看上去很酷炫的操作。</p><p>  本期内容同样是天选打工人熬夜整理出来的，吐血推荐。</p><p>  下面就开始我们今天的<strong>摸鱼小技巧</strong>吧。</p><hr><p>  既然我们分享过筛选的小技巧，自然也不能把<strong>排序</strong>给落下了。因为<strong>排序</strong>同样是日常工作中高频使用的Excel功能之一。</p><p>  通常我们会利用排序实现工作表某一列按照升序或降序的方式重新排列，比如这样：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/27/d7af11c6c9a960235376042945bd2ed5.jpg" alt="排序"></p><p>排序的规则如下：</p><ul><li>数字</li></ul><p>以数字大小作为排序依据</p><ul><li>英文字符</li></ul><p>按照字符在字母表中的先后顺序进行排序</p><ul><li>中文</li></ul><p>按照对应的拼音字母顺序进行排序。 </p><p>  可是如果此时对另外一列做排序，则会发现之前排序的结果被破坏了，也就是说<strong>排序只能对一列生效</strong>。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/27/b4010d39809f5cc5afdcdeed06cad0ae.jpg" alt="对另一列排序"></p><p>  那么有没有什么办法可以同时多列进行排序呢？毕竟我们的日常工作中可不是这样简单对单列进行排序就行的呀。其实Excel中是支持更复制的多列组合排序的，接下来就跟大家分享这个小技巧。</p><span id="more"></span><h2 id="使用自定义列表排序"><a href="#使用自定义列表排序" class="headerlink" title="使用自定义列表排序"></a>使用自定义列表排序</h2><p>  Excel支持用户自己定义排序规则，即数据的排序方式。<strong>注意这里就没有正序、倒序的区别了</strong>，只会按照用户自定义的顺序进行显示。</p><p>  那么这个有什么作用呢？它允许对多列进行排序，并且按照先后顺序进行排列。这个描述略有些抽象，我们举个例子看看，大家就清楚了。</p><p>  还是以上面的员工信息表格为例子。假设我们需要以<strong>一级部门</strong>作为第一优先顺序（以<em>产品部、质量部、市场部、销售部</em>为序），筛选出这几个部门在各<strong>Base地</strong>（以<em>成都、深圳、北京</em>为序）的员工信息，并且以员工的<strong>职级从大到小</strong>进行排序。</p><p>  这是一个以多条件为基础的筛选需求，那么用Excel怎么做呢？</p><h3 id="使用多条件排序"><a href="#使用多条件排序" class="headerlink" title="使用多条件排序"></a>使用多条件排序</h3><p>  Excel提供了一个多条件排序的功能，其入口在<strong>数据</strong>菜单栏的<strong>排序</strong>当中。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/27/1eb0bbcb47df929bc65688ee08ab9cf8.jpg" alt="多条件排序入口"></p><blockquote><p>  对数据进行排序是数据分析不可缺少的组成部分。 你可能需要执行以下操作：将名称列表按字母顺序排列；按从高到低的顺序编制产品存货水平列表，或按颜色或图标对行进行排序。 对数据进行排序有助于快速直观地显示数据并更好地理解数据，有助于组织并查找所需数据，有助于最终做出更有效的决策。</p><p>  可以对一列或多列中的数据按文本（从 A 到 Z 或从 Z 到 A）、数字（从小到大或从大到小）以及日期和时间（从最旧到最新或从最新到最旧）进行排序。 还可以按自己创建的自定义序列（如大、中和小）或格式（包括单元格颜色、字体颜色或图标集）进行排序。</p></blockquote><p>  点击之后会弹出一个排序条件组合框。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/27/571fd72edd160cb4c3f85aaf4a1c6fc8.jpg" alt="排序条件"></p><p>  从组合框里面的内容可以看出，可以<strong>添加多个条件</strong>，条件与条件之间有<strong>主从</strong>之分。每一个条件对应一个<strong>关键字（表头）</strong>，并且可以选择不同的排序方式。这里我们选择<strong>自定义序列</strong>。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/27/aac172afaa1ee1fd9bd6bea1a9f69a51.jpg" alt="自定义序列"></p><p>  在<strong>输入序列</strong>里，按需要输入排序结果，然后点击<strong>添加</strong>即可添加自定义的序列。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/27/054ef32cb6ef6507abde3f8febcac479.jpg" alt="条件组合"></p><p>  如上图，按照我们期望的顺序以及逻辑先后顺序，完成自定义排序内容的填写。点击确定，就能见证到奇迹了。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/27/e7e01ff0ea6acbdddb69455fb6eeb0c1.jpg" alt="条件排序结果"></p><p>  数据表按照我们的设想，完美的进行了排序。而要实现这一切，只需要自定义几个序列就好了。是不是一个非常实用的小技巧？</p><h2 id="导入自定义序列"><a href="#导入自定义序列" class="headerlink" title="导入自定义序列"></a>导入自定义序列</h2><p>  心思缜密的你，一定会有个疑问，如果我需要自定义的序列特别长，怎么办？难道也得手工一条一条输入吗？当然不是，Excel同样允许我们从单元格中导入自定义序列。</p><p>  首先在空白的单元格区域编辑好期望的序列方式。比如这样：</p><table><thead><tr><th align="center">一级部门</th><th align="center">Base地</th></tr></thead><tbody><tr><td align="center">产品部</td><td align="center">成都</td></tr><tr><td align="center">质量部</td><td align="center">深圳</td></tr><tr><td align="center">市场部</td><td align="center">北京</td></tr><tr><td align="center">销售部</td><td align="center"></td></tr></tbody></table><p>  但是在刚刚的自定义序列里似乎没看到有导入表格的按钮呢？那么又该从哪里导入呢？Excel将这个功能隐藏得比较深，需要点击Excel的开始菜单</p><p>  进入<strong>Excel选项</strong>对话框。点击<strong>高级</strong>选项，并找到<strong>常规</strong>字段。这里有一个<strong>编辑自定义列表</strong>的按钮。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/27/49a62809a65cd5f4e71074f3a59e659f.jpg" alt="Excel选项"></p><p>  这个时候会再次弹出<strong>自定义序列</strong>对话框，但是这次会比之前多了一个<strong>从单元格中导入序列</strong>的功能。如下图：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/27/9e0c66dbe32eb7db759e4ad3dc164b7c.jpg" alt="导入"></p><p>  选中单元格，点击导入即可完成批量导入自定义序列的操作。导入之后，能在左边<strong>自定义序列</strong>中找到刚刚导入的序列。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/27/2208a4a2c251bdc26ed02ee92df55742.jpg" alt="导入结果"></p><p>  这样我们在使用的时候就可以直接从中选取已导入的序列了，而不用再手动输入。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>  <strong>排序</strong>和<strong>筛选</strong>是Excel在日常工作中最常用且最简单的功能，配合上各种各样的小技巧，让我们能用最简单的操作，带来完全不一样的体验。</p><p>  当然Excel的小技巧不止于此，有特别想了解的，或困惑的都可以给我留言。在后面的摸鱼小技巧中再跟大家分享总结吧。</p>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学摸鱼之Excel小技巧(六) 高级筛选</title>
      <link href="2022/10/25/221026-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E5%85%AD)-%E8%B6%85%E7%BA%A7%E7%AD%9B%E9%80%89/"/>
      <url>2022/10/25/221026-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E5%85%AD)-%E8%B6%85%E7%BA%A7%E7%AD%9B%E9%80%89/</url>
      
        <content type="html"><![CDATA[<img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/logo.png" alt="logo.png" style="zoom:50%;"><p>  接<a class="link" href="https://www.ray0728.cn/2022/10/24/221024-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%BA%94)-%E6%9C%89%E6%95%88%E7%AD%9B%E9%80%89/">上一期<i class="fas fa-external-link-alt"></i></a>我们分享了怎么筛选合并单元格的小技巧，本期我们继续聊一聊Excel其它看上去很酷炫的操作。</p><p>  本期内容同样是天选打工人熬夜整理出来的，吐血推荐。</p><p>  下面就开始我们今天的<strong>摸鱼小技巧</strong>吧。</p><hr><p>  Excel的<strong>筛选功能</strong>是打工人日常用得最多的功能，它简单、好用，能快速地从数据表格中筛选出想要的内容，但是这并不是筛选的全部能力，今天给大家带来不太一样的筛选 —— 高级筛选。</p><span id="more"></span><h2 id="普通的筛选"><a href="#普通的筛选" class="headerlink" title="普通的筛选"></a>普通的筛选</h2><p>  普通筛选应该是我们日常使用最多的一种筛选方式，打开的方式也很简单，使用快捷键<kbd>CTRL+SHIFT+L</kbd>，或点击<strong>开始菜单栏</strong>中的<strong>排序和筛选</strong>即可。</p><h3 id="单条件筛选"><a href="#单条件筛选" class="headerlink" title="单条件筛选"></a>单条件筛选</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/25/6641c22a3d265c2af27adb59903f4f39.jpg" alt="筛选菜单"></p><p>  启动筛选功能后，能发现表头的每个单元格都带上了一个向下的三角形按钮。点击这个按钮即可对该列的单元格进行筛选。</p><h3 id=""><a href="#" class="headerlink" title=""></a><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/25/gifski.gif" alt="条件筛选"></h3><p>  Excel会根据单元格数据类型，提供不同的二级菜单，通过这些菜单，我们可以实现简单的多条件筛选。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/25/430e1de676f8f3b691477cceb02cfa44.png" alt="筛选子菜单"></p><h3 id="多条件筛选"><a href="#多条件筛选" class="headerlink" title="多条件筛选"></a>多条件筛选</h3><p>  多条件筛选，更像是简单的<strong>逻辑判断组合</strong>。可以支持以下几种逻辑组合：</p><ul><li>符合条件A</li><li>符合条件A<strong>或者</strong>符合条件B</li><li>符合条件A<strong>并且</strong>符合条件B<br>  需要注意的是，条件A以及条件B均只对当前列进行判断、不可跨列、跨工作表判断。</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>  假设我们有这样的员工信息表，我们想从中筛选出职级处于15级与20级之间的所有员工，那么就可以用到条件筛选。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/25/446fe181943323ab014d6078b15ec1f1.jpg" alt="原始数据"></p><p>  点击职级旁边的三角形按钮，在弹出菜单中选择<strong>数字筛选</strong>，再点击子选项<strong>自定义自动筛选</strong>，在弹出的选项框中填入大于15与小于20即可。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/25/abbe5198479760324099993726ead67f.jpg" alt="自定义自动筛选"></p><p>  点击确定后，可以立即看到筛选结果，符合我们的预期。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/25/eeb30ee95372d9d67cb46a0d014bc93a.jpg" alt="条件筛选结果"></p><p>  不过这只能筛选出当前列的结果，如果有跨列筛选的需求，就得用到级联筛选。</p><h3 id="级联筛选"><a href="#级联筛选" class="headerlink" title="级联筛选"></a>级联筛选</h3><p>  级联筛选也可以叫联合筛选，是将多列筛选组合在一起的一种方式，也是一种<strong>逻辑判断组合</strong>，比如：</p><ul><li><p>同时筛选职级在15级到20级<strong>且</strong>二级部门属于研发部的员工</p></li><li><p>同时筛选Base地在成都<strong>且</strong>入职时间在2022年10月17日之后的员工</p></li></ul><p>  不知道大家发现了没有，<strong>级联筛选中列的筛选条件之间，只存在并的关系</strong>。因此级联筛选是<strong>无法筛选出</strong>职级在15级到20级<strong>或者</strong>二级部门属于研发部的员工。感兴趣的小伙伴们，可以自己找个Excel表格试试看。</p><p>  通常普通的打工人能用到的筛选就以上这些了。如果我也只分享这些，那就对不起<strong>科学摸鱼</strong>这个称号了，如果说上面介绍的几种筛选方式可以满足我们日常工作中70%的需求，那么接下来和大家分享一个<strong>高级筛选</strong>能力，则可以<strong>满足90%的需求</strong>。</p><h2 id="高级筛选"><a href="#高级筛选" class="headerlink" title="高级筛选"></a>高级筛选</h2><p>  我们常常说<strong>既要，又要，还要</strong>，在日常工作中也常常碰到这样的场景，既要满足条件A，又要满足条件B，还要满足条件C，比如下面这样的场景：</p><p>  团队即将启动新的项目，需要新建团队，需要从员工列表中筛选出符合条件的员工。条件分别是：</p><ul><li>软件研发团队最好是成都的团队，成员职级不要低于14级，但是也不要超过20级</li><li>项目做的时候需要对市场进行舆情分析和活动预热，最好由北京的同事完成</li><li>项目的成果是面向所有群体，需要所有销售同事参与，不限制区域、职级</li></ul><p>  如果是你来筛选人选，会怎么做呢？如果按照上面普通筛选方法的话，就得对表格做好几次的筛选，才能把人员都筛选出来。如果你也觉得那样很麻烦，那就请接着往下看吧。</p><h3 id="什么是高级筛选"><a href="#什么是高级筛选" class="headerlink" title="什么是高级筛选"></a>什么是高级筛选</h3><p>  Excel支持更复杂的条件筛选，支持更复杂的逻辑（与或）组合甚至支持通配符匹配。这一切都藏在<strong>数据菜单栏</strong>的<strong>高级</strong>里面</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/25/e4f8f3a37beed27f84018cd04fa5bc80.jpg" alt="入口"></p><blockquote><p>“<strong>高级</strong>”命令的工作方式在几个重要方面与“<strong>筛选</strong>”命令有所不同。</p><ul><li>它显示了“<strong>高级筛选</strong>”对话框，而不是“自动筛选”菜单。</li><li>可以在工作表以及要筛选的单元格区域或表格上的单独条件区域中键入高级条件。 Microsoft Office Excel 将“<strong>高级筛选</strong>”对话框中的单独条件区域用作高级条件的源。</li></ul></blockquote><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>  先别慌着点<strong>高级</strong>这个按钮，在使用高级筛选前，还有准备工作要做，首先需要准备一个条件表格。表格里需保存所有期望筛选的内容。并且这个表格需遵守下面四条“公约”：</p><h4 id="公约一-条件表格的表头均能在数据表的表头中找到"><a href="#公约一-条件表格的表头均能在数据表的表头中找到" class="headerlink" title="公约一 条件表格的表头均能在数据表的表头中找到"></a>公约一 条件表格的表头均能在数据表的表头中找到</h4><p>  这条公约的意思是用于表示条件的表头描述，必须能在希望筛选的数据表表头中找到，否则Excel将无法知道该表头应该对应数据表哪一列数据。假如有如下数据表：</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th><th align="center">E</th></tr></thead><tbody><tr><td align="center">这</td><td align="center">这</td><td align="center">这</td><td align="center">这</td><td align="center">这</td></tr><tr><td align="center">是</td><td align="center">是</td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td><td align="center">E</td></tr><tr><td align="center">列</td><td align="center">列</td><td align="center">列</td><td align="center">列</td><td align="center">列</td></tr></tbody></table><p>  那么条件表格的表头<strong>只能是A、B、C、D、E中的全部或部分</strong>，但不能是其它内容。</p><h4 id="公约二-条件表格的表头允许出现重复内容"><a href="#公约二-条件表格的表头允许出现重复内容" class="headerlink" title="公约二 条件表格的表头允许出现重复内容"></a>公约二 条件表格的表头允许出现重复内容</h4><p>  仍然以上面的表格为例，条件表格中的表头允许是下面这个样子。</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">B</th><th align="center">E</th></tr></thead><tbody><tr><td align="center">条件一</td><td align="center">条件二</td><td align="center">条件三</td><td align="center">条件四</td></tr></tbody></table><p>  那么它表达的意思是：满足条件一<strong>并且</strong>满足条件二<strong>并且</strong>满足条件三<strong>并且</strong>满足条件四</p><h4 id="公约三-条件表格中的单元格允许空值"><a href="#公约三-条件表格中的单元格允许空值" class="headerlink" title="公约三 条件表格中的单元格允许空值"></a>公约三 条件表格中的单元格允许空值</h4><p>  如果单元格为空值，则不作为条件参与逻辑判断，假如有下面这种格式的条件表格。</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">B</th><th align="center">E</th></tr></thead><tbody><tr><td align="center">条件一</td><td align="center">条件二</td><td align="center"></td><td align="center">条件三</td></tr></tbody></table><p>  那么它表达的意思是：满足条件一<strong>并且</strong>满足条件二<strong>并且</strong>满足条件四。</p><h4 id="公约四条件表格中每一行的逻辑组合均互不干涉"><a href="#公约四条件表格中每一行的逻辑组合均互不干涉" class="headerlink" title="公约四条件表格中每一行的逻辑组合均互不干涉"></a>公约四条件表格中每一行的逻辑组合均互不干涉</h4><p>  同一行中的逻辑关系均为<strong>并且</strong>，但是不同行之间的逻辑关系则为<strong>或者</strong>，假如有下面这种格式的条件表格。</p><table><thead><tr><th align="center">A</th><th align="center">B</th><th align="center">B</th><th align="center">E</th></tr></thead><tbody><tr><td align="center">条件一</td><td align="center">条件二</td><td align="center">条件三</td><td align="center">条件四</td></tr><tr><td align="center">条件X</td><td align="center">条件Y</td><td align="center"></td><td align="center">条件Z</td></tr></tbody></table><p>  那么它表达的意思是：</p><p>  满足条件一<strong>并且</strong>满足条件二<strong>并且</strong>满足条件四<br>  <strong>或者</strong><br>  满足条件X<strong>并且</strong>满足条件Y<strong>并且</strong>满足条件Z。</p><p>  好啦，我承认其实并没有“公约”的说法，上面只是我总结的条件表格注意事项罢了。我们知道有上面的注意事项后，结合我们的例子，就可以做出下面这样的条件表格。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/25/76331e8ed47379e00ee8e03955902095.jpg" alt="条件表格"></p><p>  这里面用到了<strong>逻辑运算符</strong><kbd>&gt;与&lt;</kbd>以及通配符<kbd>*</kbd>。通常逻辑运算符可以用来表示范围，而通配符则可以用来做模糊匹配文字内容。</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>  准备好条件表格后，就可以开始执行了，<strong>注意</strong>，高级筛选的结果只能在活动页上显示，所以建议<strong>先进入期望保存筛选的结果的Sheet页</strong>，然后再启动高级筛选。</p><p>  筛选需填入的内容很简单，指定三个区域即可。</p><ul><li>列表区域：指原始数据区域，即期望筛选的原始数据表格</li><li>条件区域：我们已准备好的条件表格区域</li><li>复制到：筛选的结果保存在什么地方，<strong>注意：只能保存在激活的Sheet页</strong></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/25/3bd86cc308d67afe7b2a160e4d7b5e64.jpg" alt="筛选选项"></p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/25/gifski36f5554b087100a9.gif" alt="高级筛选"></p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>  <strong>条件筛选</strong>和<strong>高级筛选</strong>基本能覆盖我们日常工作中90%以上的筛选场景，它们之间并无谁更好、谁更优的选择，其它也有很多操作可以做到快速筛选的效果，比如透视表。</p><p>  灵活的使用最适当的筛选，才是最好的选择。当然Excel的小技巧不止于此，有特别想了解的，或困惑的都可以给我留言。在后面的摸鱼小技巧中再跟大家分享总结吧。</p>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学摸鱼之Excel小技巧(五) 针对合并单元格的有效筛选</title>
      <link href="2022/10/24/221024-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%BA%94)-%E6%9C%89%E6%95%88%E7%AD%9B%E9%80%89/"/>
      <url>2022/10/24/221024-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%BA%94)-%E6%9C%89%E6%95%88%E7%AD%9B%E9%80%89/</url>
      
        <content type="html"><![CDATA[<img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/logo.png" alt="logo.png" style="zoom:50%;"><p>  接<a class="link" href="https://www.ray0728.cn/2022/10/17/221016-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E5%9B%9B)-%E5%8D%95%E5%85%83%E6%A0%BC%E6%A0%BC%E5%BC%8F/">上一期<i class="fas fa-external-link-alt"></i></a>我们分享了几个关于EXCEL的使用小技巧，本期我们继续聊一聊Excel其它看上去很酷炫的操作。</p><p>  本期内容同样是天选打工人熬夜整理出来的，吐血推荐。</p><p>  下面就开始我们今天的<strong>摸鱼小技巧</strong>吧。</p><hr><p>  相信Excel的<strong>筛选功能</strong>一定是各位打工人用得最多的功能之一。我们常常利用筛选功能从数据表中快速过滤出所需要的行。但是当<strong>筛选</strong>遇上<strong>合并单元格</strong>的时候，一切都变得不太一样了。今天就跟大家分享一个<strong>关于合并单元格的筛选</strong>小技巧。</p><span id="more"></span><p>  我们在日常工作中为了让数据表更易读、更简介，不可避免会将部分单元格进行合并（合并后更符合日常阅读习惯），但是合并后带来的问题是条件筛选会出现问题，无法正确筛选合并单元格。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/24/gifski931519315ad06ea3.gif" alt="无法正确筛选合并单元格"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>  Excel筛选功能是基于单元格的值（或颜色）进行筛选。对于<strong>合并单元格，仅左上角的值会保留，其余单元格均为空值。</strong><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/24/c05e44f796298fea64c149f4003190c6.jpg" alt="合并单元格实际值"></p><p>  因此<strong>筛选</strong>的时候，Excel无法将空值与筛选条件匹配上，因此筛选结果无效。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>  既然知道问题的根因，那么解决的思路就很明确了，让单元格都拥有正确的数值。</p><h3 id="方案一：取消合并单元格，每一个单元格都保存正确的数据。"><a href="#方案一：取消合并单元格，每一个单元格都保存正确的数据。" class="headerlink" title="方案一：取消合并单元格，每一个单元格都保存正确的数据。"></a>方案一：取消合并单元格，每一个单元格都保存正确的数据。</h3><p>  该方案比较容易理解，其实就是舍弃了合并单元格。让工作表回到最简单的格式上。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/24/gifski.gif" alt="取消合并单元格"></p><p>  但是这个方案舍弃了合并单元格，<strong>破坏了表格原本的阅读格式</strong>。</p><h3 id="方案二：利用格式刷，即保留合并单元格，也能正确筛选"><a href="#方案二：利用格式刷，即保留合并单元格，也能正确筛选" class="headerlink" title="方案二：利用格式刷，即保留合并单元格，也能正确筛选"></a>方案二：利用格式刷，即保留合并单元格，也能正确筛选</h3><p>  <strong>格式刷</strong>同样是Excel中一个高频使用功能，其本质是对格式的复制和粘贴。</p><blockquote><p>使用格式刷可以快速将相同的格式（如颜色、字体样式和大小或边框样式）应用于多个文本或图形。使用格式刷，可以从一个对象复制所有格式并将其应用到另一个对象。</p></blockquote><p>  因此我们可以结合方案一，再利用格式刷将合并后单元格的格式复制给单元格。这样既可以筛选，也不会破坏表格原本的格式。</p><p>  上面的描述比较抽象，我们直接看看操作步骤吧。</p><h4 id="STEP-1-先将合并单元格的格式复制到新的单元格上，作为格式备份。"><a href="#STEP-1-先将合并单元格的格式复制到新的单元格上，作为格式备份。" class="headerlink" title="STEP 1 先将合并单元格的格式复制到新的单元格上，作为格式备份。"></a>STEP 1 先将合并单元格的格式复制到新的单元格上，作为格式备份。</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/24/1.gifski.gif" alt="复制合并单元格格式"></p><h4 id="STEP-2-对单元格进行填充，确保所有单元格都有正确的数据。"><a href="#STEP-2-对单元格进行填充，确保所有单元格都有正确的数据。" class="headerlink" title="STEP 2 对单元格进行填充，确保所有单元格都有正确的数据。"></a>STEP 2 对单元格进行填充，确保所有单元格都有正确的数据。</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/24/2.gifski.gif" alt="单元格填充"></p><p>  单元格填充，这里用了两个小技巧。<strong>定位条件</strong>和<strong>函数填充</strong>，下面简单分享一下这两个小技巧。</p><h5 id="定位条件"><a href="#定位条件" class="headerlink" title="定位条件"></a>定位条件</h5><p>  定位条件，可以让我们快速地在Excel工作表中找出所有符合条件的单元格，并将输入焦点定位其上。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/24/4ec0753eacbac0ee4c530a636243f146.jpg" alt="定位条件"></p><blockquote><p>使用 “转到 “命令快速查找并选择包含特定类型的数据（如公式）的所有单元格。 此外， 使用”转到”仅查找满足特定条件的单元格，例如数据或格式 工作表 最后一个单元格。</p></blockquote><p>  定位条件有2个入口可进入。快捷键<kbd>F5</kbd>以及开始菜单中的<kbd>查找和选择</kbd>。</p><ul><li>快捷建F5<br>  按下<kbd>F5</kbd>后,会自动弹出<strong>定位</strong>选项框，其左下角就是<strong>定位条件</strong>入口。</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/24/d7c8701c4f023a3e16826eabc187fff5.jpg" alt="快捷键进入"></p><ul><li>菜单进入<br>  在<kbd>查找和选择</kbd>的下拉菜单中，也可直接打开<strong>定位条件</strong>选项框。</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/24/2050c17f679e96dcbe6bb2f91e4c9f3d.jpg" alt="菜单"></p><p>  在本例中，我们选择<strong>空值</strong>进行条件定位。定位结果有多个，输入焦点落在所有单元格中最左上角的一个。</p><h5 id="函数填充"><a href="#函数填充" class="headerlink" title="函数填充"></a>函数填充</h5><p>  在数据量小的情况，完全可以利用拖动的方式对单元格进行数据复制。但是如果数据量很大，或者需要填充的单元格并不是相邻分布，那么通过手动拖动的方式进行复制数据会变成很麻烦的一件事。这个时候我们就需要用到简单的<strong>函数填充</strong>。</p><p>  结合<strong>定位条件</strong>首先让Excel选中选区内所有的<strong>空值</strong>，注意，当Excel完成定位后，<strong>不要点击Excel上任何单元格</strong>，而是<strong>在编辑栏中直接输入</strong>=，并用键盘上的<strong>光标方向键（上下左右键）去选择</strong>希望复制数据的单元格。这个时候我们就输入了一个简单的引用函数，比如<kbd>=F3</kbd>。</p><p>  这个函数当前仅作用于定位结果中的第一个单元格（最左上角的单元格）。为了让其它单元格效仿的引用函数，使用<kbd>CTRL+ENTER</kbd>，进行函数复制。注意，这里的复制<strong>并不是简单的将函数表达式复制给其它单元格，还复制了单元格之间的位置关系</strong>，举个例子。</p><table><thead><tr><th align="center"></th><th align="center">A</th><th align="center">B</th><th align="center">C</th><th align="center">D</th></tr></thead><tbody><tr><td align="center"></td><td align="center">需复制单元格</td><td align="center">数据1</td><td align="center">数据2</td><td align="center">数据3</td></tr><tr><td align="center">1</td><td align="center">=D1</td><td align="center">a</td><td align="center">1</td><td align="center">上</td></tr><tr><td align="center">2</td><td align="center"></td><td align="center">b</td><td align="center">2</td><td align="center">下</td></tr><tr><td align="center">3</td><td align="center"></td><td align="center">c</td><td align="center">3</td><td align="center">左</td></tr><tr><td align="center">4</td><td align="center"></td><td align="center">d</td><td align="center">4</td><td align="center">右</td></tr></tbody></table><p>  假设有上表所示的工作表，通过条件定位选中了空白区域A1、A2、A3、A4。此时输入<kbd>=D1</kbd>，实际作用于结果中最左上角的单元格，即A1。然后使用<kbd>CTRL+ENTER</kbd>进行了函数复制。</p><p>  那么对于A1来说，函数表达式中的D1，相较于A1单元格，位置是<strong>同一行向右移动3列</strong>。所以对于A2，函数表达式就变成了<kbd>=D2</kbd>。因为从A2出发，同一行向右移动3列，就是D2了。对于A3以及A4可以以此类推。</p><h4 id="STEP-3-利用格式刷将备份的单元格格式粘贴回需要筛选的区域"><a href="#STEP-3-利用格式刷将备份的单元格格式粘贴回需要筛选的区域" class="headerlink" title="STEP 3 利用格式刷将备份的单元格格式粘贴回需要筛选的区域"></a>STEP 3 利用格式刷将备份的单元格格式粘贴回需要筛选的区域</h4><p>  &nbsp;现在单元格的数据已准备就绪，剩下的就是将合并单元格格式利用格式刷重新复制回来。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/24/3.gifski.gif" alt="恢复合并单元格格式"></p><p>  至此我们就能让工作表支持合并单元格的筛选了，是不是又可以提前下班回家了呢？</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>  <strong>条件定位</strong>以及<strong>格式刷</strong>这些看似简单的功能，组合在一起之后，会让我们的表格不仅好看还更好用，当然Excel的小技巧不止于此，工作中也会遇到很多让人困惑的操作，比如如何让透视表更聪明一点、如何给工作表增加图形、图标，这些在后面的摸鱼小技巧中再跟大家总结吧。</p>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Linux命令行实现将视频文件快速转GIF文件</title>
      <link href="2022/10/23/221023-%E5%9F%BA%E4%BA%8ELinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E8%A7%86%E9%A2%91%E8%BD%ACGIF/"/>
      <url>2022/10/23/221023-%E5%9F%BA%E4%BA%8ELinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0%E5%BF%AB%E9%80%9F%E8%A7%86%E9%A2%91%E8%BD%ACGIF/</url>
      
        <content type="html"><![CDATA[<p>  本人的Blog是建在自己的私有云上的，之前在<a class="link" href="https://www.ray0728.cn/2021/11/07/211107-%E6%9C%89%E4%BA%86%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88/">《有了云服务器可以做什么》<i class="fas fa-external-link-alt"></i></a>中简单提及过我在小云上跑了不少的应用服务，其中就有为Blog提供视频播放功能NextCloud。虽然后来我觉得NextCloud并不那么实用，还很占用系统资源，于是用相对更轻量的WebDAV服务替换了NextCloud，但它仍然为一款不错的私人网盘应用服务。另外通过网盘共享资源的方式，实现视频点播对小云的系统资源消耗也是挺大的，所以我又想办法<a class="link" href="https://www.ray0728.cn/2021/09/15/210915-%E8%AE%A9%E5%B0%8F%E4%BA%91%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E5%9C%A8%E7%BA%BF%E6%92%AD%E6%94%BE/">《让小云支持视频在线播放》<i class="fas fa-external-link-alt"></i></a>，即便如此，对于我的1G2G的丐版配置，仍然有不小的资源压力。</p><p>  最后我的解决方案是，Blog中的视频都用GIF代替，消耗资源的事儿就交给客户端想办法吧☺。可问题又来了，我的主力电脑系统是Linux（Deepin、Ubuntu），怎么才能把视频转换成GIF呢？</p><span id="more"></span><h2 id="使用在线转换工具"><a href="#使用在线转换工具" class="headerlink" title="使用在线转换工具"></a>使用在线转换工具</h2><p>  这类在线工具，用百度搜索一下<kbd>视频转GIF</kbd>，就能出来很多结果。但是好用的却不太多，如果视频比较大，虽然界面上显示转换完成，但是实际上却什么都没有，比如这样的：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/20/webGIF.jpg" alt="webGIF.jpg"></p><p>  有些在线工具转换的结果又会添加水印或其它什么东西，总之，<strong>效果并不是特别理想</strong>。</p><h2 id="使用软件工具"><a href="#使用软件工具" class="headerlink" title="使用软件工具"></a>使用软件工具</h2><p>  如果是在Windows平台上的话，有很多优秀的工具可以使用，比如FastStone Capture、Screen2GIF等，并且使用也很方便。对于Linux平台上，虽然没有那么多可选择的应用，但是仍然有优秀的工具，比如<a href="https://gitee.com/mirrors_phw/peek"><strong>Peek</strong></a>就是一款优秀的Linux平台视频录制转GIF工具。</p><p>  细细研究一下Linux平台的应用软件，能发现大多都是利用各种开源组件或模块组合在一起的，比如Peek中GIF功能就是利用了<a class="link" href="https://gif.ski/">gifski<i class="fas fa-external-link-alt"></i></a>，那么常用的组件有哪些呢？在Linux平台上，常用的有 <a class="link" href="https://ffmpeg.org/">ffmpeg<i class="fas fa-external-link-alt"></i></a>、<a class="link" href="https://imagemagick.org/script/index.php">convert<i class="fas fa-external-link-alt"></i></a>以及刚刚提到的<a class="link" href="https://gif.ski/">gifski<i class="fas fa-external-link-alt"></i></a>。</p><h2 id="使用三方组件"><a href="#使用三方组件" class="headerlink" title="使用三方组件"></a>使用三方组件</h2><h3 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h3><p>  FFmepg算是Linux平台用途最广、使用频率最高的开源组件了，无论是视频播放、还是视频后期处理，甚至视频推流都离不开FFmpeg，几乎所有涉及多媒体的工具都可以找到FFmpeg组件。</p><blockquote><p>FFmpeg is the leading multimedia framework, able to <strong>decode</strong>, <strong>encode</strong>, <strong>transcode</strong>, <strong>mux</strong>, <strong>demux</strong>, <strong>stream</strong>, <strong>filter</strong> and <strong>play</strong> pretty much anything that humans and machines have created. It supports the most obscure ancient formats up to the cutting edge. No matter if they were designed by some standards committee, the community or a corporation. It is also highly portable: FFmpeg compiles, runs, and passes our testing infrastructure <a class="link" href="http://fate.ffmpeg.org/">FATE<i class="fas fa-external-link-alt"></i></a> across Linux, Mac OS X, Microsoft Windows, the BSDs, Solaris, etc. under a wide variety of build environments, machine architectures, and configurations.</p></blockquote><p>  作为视频处理一哥，将视频转换为GIF，自然不在话下，配合简单的参数即可实现。</p><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>ffmpeg -i test.mp4 ffmpeg.gif</code>，这句命令的意思是将test.mp4按照其视频分辨率、帧率转换为ffmpeg.gif文件。如果想调整生产GIF文件的参数，可以配合以下参数实现：</p><blockquote><p>-ss time_off: 从指定的时间（单位为秒）开始，支持[-]hh：mm：ss[.xxx]的格式</p><p>-t duration  : 指定时长</p><p>-r rate         : 帧速率（fps）</p><p>-s size         : 指定分辨率</p></blockquote><p>  当然FFmpeg的参数可不止这点，还支持很多的操作，比如按比例缩放<code>-vf scale</code>等等，有兴起的可以去网上搜索下相关的介绍，这里就不过多展开了。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>  一般来说主流的Linux发行版都支持命令行直接安装，网上搜索一下就能找到，比如:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apt install ffmpegyum install ffmpeg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  通过命令行安装，虽然方便，但是ffmpeg版本一般比较低（与主机版本能更好的兼容）。如果想尝试新的功能，请确认当前版本可支持。</p><p>  另一种方式是通过源码进行编译安装，好处在于能用上最新版本的ffmpeg，不过编译过程稍显麻烦。因为不同的Linux发行版，编译方法也略有不同，可在网上搜索一下最新的编译方式，大致步骤如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">./configuremakemake install<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="Convert"><a href="#Convert" class="headerlink" title="Convert"></a>Convert</h3><p>  Convert并不是一个独立的组件或应用，它只是ImageMagick提供的一个图像转换功能。所以如果想在Linux平台上使用Convert，则需要完整安装ImageMagick才行。</p><blockquote><p>Use ImageMagick<a class="link" href="http://tarr.uspto.gov/servlet/tarr?regser=serial&amp;entry=78333969">®<i class="fas fa-external-link-alt"></i></a> to create, edit, compose, or convert digital images. It can read and write images in a variety of <a class="link" href="https://imagemagick.org/script/formats.php">formats<i class="fas fa-external-link-alt"></i></a> (over 200) including PNG, JPEG, GIF, WebP, HEIC, SVG, PDF, <a class="link" href="https://imagemagick.org/script/motion-picture.php">DPX<i class="fas fa-external-link-alt"></i></a>, <a class="link" href="https://imagemagick.org/script/high-dynamic-range.php">EXR<i class="fas fa-external-link-alt"></i></a> and TIFF. ImageMagick can resize, flip, mirror, rotate, distort, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses and Bézier curves.</p></blockquote><p>  convert虽然只是ImageMagick的子功能，但是其功能也是很丰富的。</p><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><p>比如这样：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">#转换图片格式，支持JPG, BMP, PCX, GIF, PNG, TIFF, XPM和XWD等类型convert xxx.jpg xxx.png   #讲jpeg转换为png文件#改变图像大小convert -resize 1024x768 xxx.jpg  xxx1.jpg #将图像的像素改为1024768(注意1024与768之间是小写字母x)*convert -sample 50%x50% xxx.jpg  xxx1.jpg #将图像缩小为原来的50%50%#旋转图像*convert -rotate 270 sky.jpg sky-final.jpg #将图像顺时针旋转270度 #为图像加上文字*convert -fill black -pointsize 60 -font helvetica -draw 'text 10,80 "hello world ! "' #xxx.jpg xxx1.jpg在图像的10,80位置用60磅全黑Helvetica字体上写hello world！#批量文件格式转换mogrify -path newdir -format png *.jpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  对于视频转GIF，则可以通过将视频按帧，拆分为很多很多的单张图片，然后将这些单张图片再合并为一个GIF图片。图片合并可用下面的命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">convert -delay 10 -loop 0 *.png convert.gif<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  这句命令的意思是将所有png图片转换为一张GIF文件，这里用到了2个新的参数<kbd>-delay</kbd>和<kbd>-loop</kbd>，它们的定义分别是：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-delay value         间隔多久（毫秒）显示下一张图片-loop iterations     在文件中添加循环播放标志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  看到这里自然就会发现一个问题，假如我的png图片足够多，或者单张png图片足够大（比如4K分辨率），那么合成的GIF文件是不是就越大？假如我构造一个足够多，且文件足够大的图库，然后执行convert转换为GIF，是不是会把主机的资源全部占完？OOM？这个假设完全没毛病，实际情况也确实这样，再需要转换超大文件的时候convert常常会报<strong>cache resources exhausted</strong>异常。</p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>  一般来说convert报cache类的异常都是因为没有足够的系统资源用于转换图片导致。不过值得庆幸的是，convert并不是将系统所有资源消耗光了，才报这样的异常，主机系统依然可以正常工作运行。</p><p>  这得益于convert自己的内存分配策略。通过命令<code>convert -list policy</code>可以查询当前系统下convert的内存策略。</p><blockquote><p>Path: /etc/ImageMagick-6/policy.xml<br>  Policy: Resource<br>    name: disk<br>    value: 2GiB<br>  Policy: Resource<br>    name: map<br>    value: 1GiB<br>  Policy: Resource<br>    name: memory<br>    value: 512GiB<br> … …<br>  Policy: Coder<br>    rights: None<br>    pattern: XPS</p><p>Path: [built-in]<br>  Policy: Undefined<br>    rights: None</p></blockquote><p>  从返回的结果中，能看到policy配置文件的路径以及各种场景下的内存配置大小，可以根据需要修改policy配置文件中对应的子项即可。</p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>  和FFmpeg一样，主流的Linux发行版都可以通过命令行直接安装。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">apt install imagemagickyum install imagemagick<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  也可以通过<a class="link" href="https://imagemagick.org/script/download.php#linux">官网下载<i class="fas fa-external-link-alt"></i></a>已编译好的二进制文件或封装包，使用安装命令进行安装。</p><h3 id="GifSki"><a href="#GifSki" class="headerlink" title="GifSki"></a>GifSki</h3><p>  GifSki是独立的开源软件，其目标就是将视频转换为更优的GIF，支持简单的参数配置，由于其目前并未部署在常见的应用仓库中，所以只能通过Rust进行安装。</p><blockquote><p><strong>gifski</strong> converts video frames to GIF animations using pngquant’s fancy features for efficient cross-frame palettes and temporal dithering. It produces animated GIFs that use <em>thousands</em> of colors per frame.</p><p><a class="link" href="https://github.com/ImageOptim/gifski">It’s open-source<i class="fas fa-external-link-alt"></i></a>! It’s a CLI tool, but it can also be compiled as a <strong>library</strong> for seamless use in other apps ([ask me](mailto: <a class="link" href="mailto:kornel@pngquant.org">kornel@pngquant.org<i class="fas fa-external-link-alt"></i></a>?) or <a class="link" href="https://supso.org/projects/pngquant">get a commercial license<i class="fas fa-external-link-alt"></i></a> if you want to use it in a closed-source app or web service).</p></blockquote><p>  上面介绍的几种工具都可以实现视频转GIF，那么他们到底谁才是最优（转换效果最好）的选择呢？接着我们就分别试试看。</p><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><p>  GifSki和FFmepg一样，支持直接从视频转换为GIF文件。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gifski -fps 10 -width 320 -o result.gif test.mp4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  上面的例子将“test.mp4”文件转换为GIF，最大分辨率为320像素，每秒10帧。</p><p>  当然也和convert一样，支持将很多的PNG图片。按帧率生成GIF文件。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">gifski -o result.gif *.png<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h3><p>  那么它们转换效果到底怎么样呢？我们对同一个视频（1920 × 1080）文件（27M）进行转换，看看转换之后是什么样。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ffmpeg -i test.mp4 -r 5 ffmpeg.gifffmpeg -i test.mp4 -r 5  tmp/frame%04d.pnggifski --width 1920 -o gifski.gif tmp/frame*.pngconvert -delay 10 -loop 0 tmp/frame*.png convert.gif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  转换之后会发现一个共性问题，无论哪一种方式转换的GIF文件，文件大小都会比原视频更大。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ray@MyDeepin:~/Videos/MyVideos/Screen Recordings$ ls -lh-rw-r--r-- 1 ray ray 433M 10月 22 12:50 convert.gif-rw-r--r-- 1 ray ray 150M 10月 22 12:42 ffmpeg.gif-rw-r--r-- 1 ray ray 200M 10月 22 12:45 gifski.gif-rw-r--r-- 1 ray ray  27M 10月 22 12:38 test.mp4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="GIF压缩"><a href="#GIF压缩" class="headerlink" title="GIF压缩"></a>GIF压缩</h3><p>  那么要怎么才能减少GIF文件的大小呢？一般从3个方面下手。</p><ul><li>图像分辨率大小</li></ul><p>  通过缩小图像的分辨率，可以在很大程度上减少最终GIF文件的大小，这也是最有效的方法。</p><ul><li>图像帧率</li></ul><p>  降低帧率是另一个减少GIF文件大小的方法，不过太低的帧率会让GIF的效果大打折扣。</p><ul><li>降低颜色通道与增加透明值</li></ul><p>  简单来说就是将颜色鲜艳程度降低、并适当增加透明值，这样图片中颜色数据大小就会下降，但是会明显影响GIF的显示效果。</p><p>  如果前面2步都已无法再调整了，那么可通过convert的转换命令完成。</p><p><code>convert result.gif -fuzz 10% -layers Optimize result.min.gif</code></p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>  最后分享一个基于上述三方组件的Shell脚本。该脚本可自动将目录下的视频文件转换为GIF文件（同时保留未压缩与压缩的文件）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!/bin/bashhelpinfo() {    echo "Version: GIF Creator Tools 1.0.0"    echo "Usage: $0 [options ...] Video File Directory"    echo ""    echo "Video File Settings:"    echo "-w       video size scaling width"    echo "-r       set frame rate (Hz value, fraction or abbreviation)"    echo "GIF File Settings:"    echo "-f       colors within this distance are considered equal"    exit -1}createDirectories(){    if [ ! -d "$DSTPATH" ];then        mkdir -p "$DSTPATH"    fi    if [ ! -d "$TMPPATH" ];then        mkdir -p "$TMPPATH"    fi}convertgif(){    for FILE in `ls "$SRCPATH"/*.mp4 | tr " " "\?"`    do        FILENAME=`echo "$FILE"|awk -F "/" '{print $NF}'|awk -F "." '{print $1}'`        ffmpeg -i "$SRCPATH/$FILENAME.mp4" -r $RATE -vf scale=$WIDTH:-1 "$TMPPATH"/TMP_%04d.png        gifski -W $WIDTH -r 10 -o "$DSTPATH/$FILENAME.gifski.gif" "$TMPPATH"/TMP_*.png        convert -delay 10 -loop 0 "$TMPPATH"/TMP_*.png "$DSTPATH/$FILENAME.convert.gif"        rm -rf "$TMPPATH"/TMP_*.png        convert "$DSTPATH/$FILENAME.gifski.gif" -fuzz $FUZZ% -layers Optimize "$DSTPATH/$FILENAME.gifski.min.gif"        convert "$DSTPATH/$FILENAME.convert.gif" -fuzz $FUZZ% -layers Optimize "$DSTPATH/$FILENAME.convert.min.gif"    done    rm -rf "$TMPPATH"}setdefault(){    if ["$SRCPATH" = ""]; then        SRCPATH=`pwd`    fi    if ["$WIDTH" = ""]; then        WIDTH=800    fi    if ["$RATE" = ""]; then        RATE=5    fi    if ["$FUZZ" = ""]; then        FUZZ=10    fi}while getopts ':w:r:f:h' OPT; do    case $OPT in        w) WIDTH="$OPTARG";;        r) RATE="$OPTARG";;        f) FUZZ="$OPTARG";;        h) helpinfo;;    esacdoneshift $(($OPTIND - 1))SRCPATH=$*setdefaultDSTPATH="$SRCPATH/gif"TMPPATH="$SRCPATH/tmp"createDirectoriesconvertgif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> FFMpeg </tag>
            
            <tag> Shell </tag>
            
            <tag> Convert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学摸鱼之Excel小技巧(四) 单元格格式更智能</title>
      <link href="2022/10/17/221016-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E5%9B%9B)-%E5%8D%95%E5%85%83%E6%A0%BC%E6%A0%BC%E5%BC%8F/"/>
      <url>2022/10/17/221016-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E5%9B%9B)-%E5%8D%95%E5%85%83%E6%A0%BC%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/logo.png" alt="logo.png" style="zoom:50%;"><p>  接<a class="link" href="https://www.ray0728.cn/2022/10/13/221012-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%B8%89)-%E6%88%91%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%8C%E4%BD%A0%E5%88%AB%E5%8A%A8/">上一期<i class="fas fa-external-link-alt"></i></a>我们分享了几个关于EXCEL的使用小技巧，本期我们继续聊一聊Excel其它看上去很酷炫的操作。</p><p>  本期内容同样是天选打工人熬夜整理出来的，吐血推荐。</p><p>  下面就开始我们今天的<strong>摸鱼小技巧</strong>吧。</p><hr><p>  Excel日常使用中，免不了会输入各种格式的内容，比如时间、编号、金额等等。但是却常常遇到实际显示效果与期望相差甚远的情况。比如下面这样：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/16/1793a8e13dff75dd0694130809181041.jpg" alt="单元格自动转换.jpg"></p><p>  根本原因在于Excel非常“聪明”的替我们做了一系列的决定，将一些了它自以为了解的单元格式都做了<strong>自动转换</strong>。可这样的转换大多时候都违反了用户原本的意志，实在让人头大。不过如果能有效控制单元格的格式，倒是真的能显著提升使用者的效率，今天就跟大家分享关于<strong>单元格格式</strong>的几个小技巧吧。</p><span id="more"></span><h3 id="自动添加前（后）缀"><a href="#自动添加前（后）缀" class="headerlink" title="自动添加前（后）缀"></a>自动添加前（后）缀</h3><p>  有时候我们会批量输入相同格式的数据内容，比如都带有相同的前（后）缀。假设我们在录入员工信息的时候需要录入员工的工号信息，并且工号信息都带有一个固定的前缀RID，比如某人的工号为RID-123456我们当然可以直接输入，比如这样：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/16/1603d9041807636043e451bd485c232f.jpg" alt="手动输入"></p><p>  但是我们也可以这样设置单元格格式，让单元格自动添加前缀RID。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/16/ed454920ec00f21d52233b90c74fc215.jpg" alt="前缀单元格格式"></p><p>  设置后，单元格会自动在输入的内容前加上RID前缀。当然如果要设置后缀也可以用同样的方法。效果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/16/eb491f8652eba99cd34ac93c33c22c98.jpg" alt="效果"></p><h3 id="自动格式化输入内容"><a href="#自动格式化输入内容" class="headerlink" title="自动格式化输入内容"></a>自动格式化输入内容</h3><p>  不过有时候我们需要录入的数据并不是简单的有一个固定前缀或后缀。而是具备更复杂的格式。比如我们录入手机电话号码的时候，希望能自动根据号码位数进行分割，一方面更容易阅读另一方面也更容易记忆。假设我们想将11位的手机号码按照XXX-XXXX-XXXX的格式进行录入该怎么做呢？</p><p>  在设置之前，需要先了解一个简单的小常识，<strong>Excel中的占位符</strong>。占位符这个概念应该是来源于软件编程，是指在位数不够的情况下，用指定的字符填充空白区域，使得最终输出的结果符合预期设计的格式。是不是有点生硬、拗口，不好理解，没关系，我们举个例子。</p><p>  比如，需要输出一个固定的4位数，且在输入位数不足的情况下，用0进行占位。即输入123，实际输出为0123，此处的0即为占位符。</p><p>  在Excel中有2种占位符，0和#，<strong>占位符仅对数字有效</strong>。</p><h4 id="占位符0"><a href="#占位符0" class="headerlink" title="占位符0"></a>占位符0</h4><p>  如果输入数字的位数足够，则显示输入的数字，如果输入的位数不够，会用0进行补位，并显示在单元格中。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/16/0afb8615df7544c71.jpg" alt="0占位符"></p><p>  如果输入1234567890，则会在数字前补充1个0，以便位数达到11位。效果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/16/0.jpg" alt="效果"></p><h4 id="占位符"><a href="#占位符" class="headerlink" title="占位符#"></a>占位符#</h4><p>  如果输入数字的位数足够，则显示输入的数字，如果输入的位数不够，会用0进行补位（<strong>但是不会显示无意义的0</strong>），并显示在单元格中。</p><p>  所谓无意义的0是指，不会影响数字大小的0，比如0123实际等于123，再如123.00实际等于123。这些0都是无意义的0，如果使用**#占位符**，则均不会显示。比如我们这样设置：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/16/5022a5ccf235627d58bf1972960aadb4.jpg" alt="#占位符"></p><p>  虽然位数不够11位，但是仍然不会在前补充0，效果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/16/f928a4ffd1f98afd8524f6ea147ef811.jpg" alt="效果"></p><h3 id="自动隐藏输入内容"><a href="#自动隐藏输入内容" class="headerlink" title="自动隐藏输入内容"></a>自动隐藏输入内容</h3><p>  有时候，我们希望对单元格内容做些快速且简单的隐藏，比如在跟大家介绍员工信息的时候，希望能把职级信息隐藏。这个时候当然可以通过单元格格式中的隐藏选项来实现这个效果。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/17/cfcecf3f410c08bda1bb06042afa4683.jpg" alt="保护-隐藏选项"></p><p>  不过该隐藏选项<strong>必须在使用了工作表保护的前提下才会生效</strong>。有兴趣的小伙伴可以自己试试看，效果还是挺好的。</p><p>  不过今天的主题可是单元格格式呢，所以我们来试试看另一种方式隐藏吧。在<strong>设置单元格格式</strong>中选择<strong>自定义</strong>，填入<kbd>;;;</kbd>，注意，这里是英文的<kbd>;</kbd>。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/17/895ac266d019c9a263c3de5f76f60ac4.jpg" alt="隐藏格式"></p><p>  效果如下，能看到单元格中已不显示内容，但是点击选中后，会在编辑框中看到真实的数据。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/17/1af7d92452b7779bc1d492b0c87e1ef8.jpg" alt="效果"></p><p>  这里需要简单介绍下<kbd>;</kbd>的含义，它其实表示了单元格中4种数据的显示方式，定义如下：</p><blockquote><p>正数;负数;0;文本</p></blockquote><p>  通过<kbd>;</kbd>进行分割，单元格根据数据内容，采用所对应的格式进行显示，如果格式为空，则表示隐藏。举个例子，如果我们想只显示正数，则可以设置为<kbd>G/通用格式;;;</kbd>，因为只有正数有对应的显示格式定义，因此非正数的内容都将隐藏。</p><h3 id="条件格式组合"><a href="#条件格式组合" class="headerlink" title="条件格式组合"></a>条件格式组合</h3><p>  看到这里，心思细腻的你一定想到了，单元格格式能不能组合在一起使用呢？当然是可以的。而且组合后的效果也许会让你眼前一亮呢。比如，我们在统计员工当月获得的奖励时，就可以利用上面讲的几种格式进行组合，先看看效果。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/17/556d6936c5c85908a95ff0b88a83d28a.jpg" alt="效果"></p><p>  根据输入的内容自动设置颜色，自动添加前缀备注。要做到这样的效果，只需要在<strong>单元格格式设置</strong>中输入</p><p><code>[蓝色]("奖""励")¥0.00;[红色]("罚""款") ¥0.00;[黄色]("无""激""励");</code>即可。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/17/07d65356ebe6f9062b812134b2b6e203.jpg" alt="设置"></p><p>  根据上面介绍过关于<kbd>;;;</kbd>的格式说明，我们通过对正数负数以及0设置不同的显示格式，来实现预期的效果。这里也用到了<kbd>[颜色]</kbd>这样的特殊表达格式，其实这是Excel的内置颜色代码，除了例子中的蓝色、红色以及黄色。还有其它的颜色代码，如下所示，有兴趣的小伙伴可以自己试试看。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/16/2a9318a97d5ffb67d6c9437756e1e759.jpg" alt="颜色代码"></p><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>  巧妙的使用Excel小技巧，会让我们日常使用的Excel变得“聪明”一点，做出的表格也会更直观，更好看，当然Excel的小技巧不止于此，工作中也会遇到很多让人困惑的操作，比如如何筛选带合并单元格的工作表、如何增加图形、图标，这些在后面的摸鱼小技巧中再跟大家总结吧。</p>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学摸鱼之Excel小技巧(三) 我的表格，你别动</title>
      <link href="2022/10/13/221012-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%B8%89)-%E6%88%91%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%8C%E4%BD%A0%E5%88%AB%E5%8A%A8/"/>
      <url>2022/10/13/221012-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%B8%89)-%E6%88%91%E7%9A%84%E8%A1%A8%E6%A0%BC%EF%BC%8C%E4%BD%A0%E5%88%AB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/logo.png" alt="logo.png" style="zoom:50%;"><p>  接<a class="link" href="https://www.ray0728.cn/2022/08/04/%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%BA%8C)/">上一期<i class="fas fa-external-link-alt"></i></a>我们分享了几个关于EXCEL的使用小技巧，本期我们继续聊一聊Excel其它看上去很酷炫的操作。</p><p>  本期内容同样是天选打工人熬夜整理出来的，吐血推荐。</p><p>  下面就开始我们今天的<strong>摸鱼小技巧</strong>吧。</p><hr><p>  针对不同的保护需要，今天向大家介绍几种简单好用的表格保护功能。</p><ul><li>工作表的保护</li><li>Sheet页的保护</li><li>工作簿的保护</li></ul><span id="more"></span><p>  日常办公中免不了会有各种各样的表格需要分发给不同的人使用，如将统计数据后发给部门同事查看。但是又不想让Excel中的数据被修改，即<strong>“普通用户”</strong>只拥有<strong>只读</strong>权限。这个时候我们可以用到Excel中最基础的<strong>工作表保护</strong>功能。</p><h2 id="我的工作表不让动"><a href="#我的工作表不让动" class="headerlink" title="我的工作表不让动"></a>我的工作表不让动</h2><h3 id="工作表仅可查看"><a href="#工作表仅可查看" class="headerlink" title="工作表仅可查看"></a>工作表仅可查看</h3><p>  该功能可限制用户对工作表中的操作。<strong>注意</strong>该功能仅对当前的工作表（即当前Sheet页）有效。它的操作很简单：</p><ul><li><p>STEP1. 点击菜单栏中的<strong>审阅</strong></p></li><li><p>STEP2. 再点击<strong>保护工作表</strong>即可。</p></li></ul><p><a href="https://arts.ray0728.cn/image/ZE77"><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/09/21/86a024f68afb089d62b10d7bf476cfa5.jpg" alt="工作表保护" style="zoom:50%;"></a></p><p>  默认保护情况下，只允许选中单元格，其余操作都不允许。若需更改，根据实际需要选取不同的选项即可。连续2次输入密码后，工作表就处于被保护状态，默认状态为只可查看，不可编辑。效果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/02-.min.gif" alt="02-.min.gif"></p><p>  要取消也很简单，点击<strong>审阅</strong>中的<strong>撤销工作表保护</strong>即可。</p><h3 id="工作表仅允许部分区域编辑"><a href="#工作表仅允许部分区域编辑" class="headerlink" title="工作表仅允许部分区域编辑"></a>工作表仅允许部分区域编辑</h3><p>  可有的时候，并不是简单的允许或不允许编辑，就像这个世界一样，并不是只有黑色和白色，还是要允许有多种多样的颜色存在。在实际工作中我们也确实会遇到<strong>既要</strong>让别人不能动我的表格，<strong>又要</strong>别人能在表格中回填信息的场景。假设我们想在上述例子的表中既要员工不能动自己的部门信息，又要员工能自己填入联系方式该怎么办呢？</p><p>  我们可以设置<strong>单元格格式</strong>进行指定哪些区域的单元格不受保护。</p><ul><li>STEP1. 选择不需要保护的单元格，并单击右键，选择<strong>设置单元格格式</strong></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/ab08bb2da2d0c836cfe00caa4f53790b.jpg" alt="ab08bb2da2d0c836cfe00caa4f53790b.jpg"></p><ul><li><p>STEP2.  在弹出的<strong>设置单元格格式</strong>窗口中，选择<strong>保护</strong>页，并取消<strong>锁定</strong>勾选框。</p></li><li><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/bddd2b7f4050df00b769a0bbcad0292a.jpg" alt="bddd2b7f4050df00b769a0bbcad0292a.jpg"></p></li><li><p>STEP3. 按照<strong>【工作表仅可查看】</strong>中介绍的步骤对工作表进行设置即可。</p><p>效果如下：<br><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/03-.min.gif" alt="03-.min.gif"></p></li></ul><h3 id="工作表允许不同的人编辑不同的区域"><a href="#工作表允许不同的人编辑不同的区域" class="headerlink" title="工作表允许不同的人编辑不同的区域"></a>工作表允许不同的人编辑不同的区域</h3><p>  感谢能耐心的读到这里，那么，我们再进一步。如果我们希望工作表中某些区域允许A用户编辑，另一些区域允许B用户编辑，同时A用户与B用户不可以编辑对方的数据，又该怎么做呢？</p><p>  我们可以通过设置<strong>允许编辑区域</strong>来实现这一目的。</p><ul><li>STEP 1. 通过工具栏中的<strong>审阅</strong>选项卡，点击<strong>允许编辑区域</strong>，打开设置选项窗口。</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/c5d5208df21f190e39d35ea743ce9f1a.jpg" alt="c5d5208df21f190e39d35ea743ce9f1a.jpg"></p><ul><li><p>STEP 2. 在弹出窗口中点击<strong>新建</strong>，打开新区域参数窗口。其中的<strong>标题</strong>可以取任意方便理解的名字，<strong>引用单元格</strong>则指需要作用的范围。<strong>区域密码</strong>是指访问（编辑）该区域所需要的密码。</p><p>举个例子：假设仅成都的HR有权对Base地为成都区域的人员做薪资信息修改，那么配置如下图。</p></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/13915ede8bc3424c617e214bb0bc5815.jpg" alt="13915ede8bc3424c617e214bb0bc5815.jpg"></p><ul><li>STEP 3. 将所有需要设置的区域按上面的步骤设置完之后，大概就长下面这个样子。</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/a06b6780fc778f409434d3bc83d72309.jpg" alt="a06b6780fc778f409434d3bc83d72309.jpg"></p><ul><li>STEP 4. 按照<strong>【工作表仅可查看】</strong>中介绍的步骤对工作表进行设置即可。</li></ul><p>效果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/04-.minb35fe735defc6f31.gif" alt="04-.minb35fe735defc6f31.gif"></p><h2 id="我的Sheet页不让看"><a href="#我的Sheet页不让看" class="headerlink" title="我的Sheet页不让看"></a>我的Sheet页不让看</h2><p>  上面介绍了几种保护工作表的方法，不过都仅局限于工作表，对于Sheet页是无效的。那么Sheet页有保护的需要吗？这样的场景应该是存在的，比如上面示例中的表格包含三个Sheet页，其中有一个Sheet页是部门信息，如果为了更好的保护信息，可能需要隐藏这个Sheet页，那么又该怎么做呢？</p><h3 id="初级隐藏术"><a href="#初级隐藏术" class="headerlink" title="初级隐藏术"></a>初级隐藏术</h3><p>  最简单的方法当然就是鼠标右键点击希望隐藏的Sheet，选择隐藏即可。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/Sheeta804141789c470db.jpg" alt="Sheeta804141789c470db.jpg"></p><p>  这个方法操作很简单，但是也很容易被破解，只需要在剩下的Sheet页上同样用鼠标右键点击，选择取消隐藏即可恢复。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/Sheet.jpg" alt="Sheet.jpg"></p><h3 id="高级隐藏术"><a href="#高级隐藏术" class="headerlink" title="高级隐藏术"></a>高级隐藏术</h3><p>  简单隐藏术并不适用需要深度隐藏的Sheet，我们可以使用进阶版隐藏术达到更好的隐藏效果。再开始之前需要知道一个小技巧（快捷键）：<kbd>ALT + F11</kbd>，这个快捷键可以打开Excel的VBA编辑器。好了，我们来看看怎么做。</p><ul><li>STEP 1. 使用快捷键打开VBA编辑器，这里能看到我们的Sheet页都在左边的树状结构中，点击其中需要隐藏的Sheet页名称。</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/VBSheet.jpg" alt="VBSheet.jpg"></p><ul><li><p>STEP 2. 可以在左下方看见有一个属性窗口，其中有一个<strong>Visible（可见性）</strong>的选项，点击右侧的下拉选项菜单，根据需要选择即可。Excel提供了三种选项，分别是：</p><p>-1 ：可见</p><p> 0 ： 隐藏（效果等同于简单隐藏术中的效果）</p><p> 2 ： 超级隐藏（深度隐藏的意思）</p></li></ul><p>效果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/06-.min.gif" alt="06-.min.gif"></p><p><strong>备注</strong> 使用了高级隐藏术，隐藏的Sheet页在表格中是完全看不见的，包括鼠标右键菜单也无<strong>取消隐藏</strong>的选项。但是如果使用者同样知道这个方法，只需要打开VBA编辑器，即可轻松恢复。因此还需要进一步增强。</p><h3 id="增强版高级隐藏术（隐藏VBA）"><a href="#增强版高级隐藏术（隐藏VBA）" class="headerlink" title="增强版高级隐藏术（隐藏VBA）"></a>增强版高级隐藏术（隐藏VBA）</h3><p>  上面我们看到了初级和高级两种隐藏术，高级隐藏术的效果上明显优于初级，但是却存在一个很大的漏洞，所以我们需要对VBA同样进行隐藏，防止使用者通过VBA进行恢复。步骤如下：</p><ul><li><p>STEP 1. 使用快捷键（<kbd>ALT + F11</kbd>）打开VBA编辑器，<strong>如果没有任何函数，需要在其中写入任意函数</strong>。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/VBA.jpg" alt="VBA.jpg"></p></li><li><p>STEP 2. 鼠标右键单击左侧窗口中的<strong>VBAProject</strong>，并选择<strong>VBAProject属性</strong></p></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/VBA-.jpg" alt="VBA-.jpg"></p><ul><li>STEP 3. 在弹出的<strong>工程属性</strong>窗口中选择<strong>保护</strong>，并勾选<strong>查看时锁定工程</strong>，以及填入对应的<strong>密码</strong>。</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/VBAee1d7890c5f3e0cb.jpg" alt="VBAee1d7890c5f3e0cb.jpg"></p><ul><li>STEP 4. 保存VBA、保存Excel表格，若要立即生效，需重新打开当前表格。</li></ul><p>当重新打开表格后，访问VBA就需要输入密码才可访问，这样就防止隐藏的Sheet页从VBA编辑器中恢复。</p><p>效果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/VBA.gif" alt="VBA.gif"></p><h2 id="我的表格文件不让动"><a href="#我的表格文件不让动" class="headerlink" title="我的表格文件不让动"></a>我的表格文件不让动</h2><p>  上面介绍了对工作表、Sheet页的多种保护手段，那么对于Excel文件本身呢？当然也可以进行保护，并且方法也很简单（毕竟咱一开始就说好，今天介绍的方法都要简单又好用的嘛）。步骤如下：</p><ul><li>STEP 1. 选择<strong>另存为</strong>，并在弹出的保存对话框中点击<strong>工具</strong>，选择<strong>常规选项</strong>。</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/19b6c2842b3df7379b999404e11cf5c3.jpg" alt="19b6c2842b3df7379b999404e11cf5c3.jpg"></p><ul><li>STEP 2. 在弹出的对话框中，可根据需要填入<strong>打开权限密码</strong>和<strong>修改权限密码</strong></li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/13/cd8834db7bd19fff2bc028699a3e7e8e.jpg" alt="cd8834db7bd19fff2bc028699a3e7e8e.jpg"></p><p>  是的，就是这么简单，即可限制当前Excel文件的被使用范围，感兴趣的小伙伴可以自己试试看。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>  结合上面介绍的多种方法，运用合理得当，可以轻松实现Excel表格的各种保护需要，当然对与表格的保护，在实际工作中可能会更加复杂，比如希望不同的用户打开，展现不同的Sheet页，或者不同的用户打开，展现不同的单元格内容等等，这些其实都可以做到，在后面的<strong>摸鱼小技巧</strong>中再跟大家总结吧。</p>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转】开发者测试必须知道的7件事</title>
      <link href="2022/10/11/221011-%E5%BC%80%E5%8F%91%E8%80%85%E6%B5%8B%E8%AF%95%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%847%E4%BB%B6%E4%BA%8B/"/>
      <url>2022/10/11/221011-%E5%BC%80%E5%8F%91%E8%80%85%E6%B5%8B%E8%AF%95%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%847%E4%BB%B6%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>本文转至<a class="link" href="https://zhuanlan.zhihu.com/p/423958601">华为云开发者联盟<i class="fas fa-external-link-alt"></i></a>，文中的<em><strong>我司</strong></em>特指<em><strong>华为技术有限公司</strong></em>。</p><h2 id="一、“开发者测试”-就是“开发者来测试”"><a href="#一、“开发者测试”-就是“开发者来测试”" class="headerlink" title="一、“开发者测试” 就是“开发者来测试”"></a>一、“开发者测试” 就是“开发者来测试”</h2><p>开发者测试是现代软件工程中非常重要的一环，敏捷开发、主干开发这些先进的项目管理方法和流程都基于完善的开发者测试。当每个月甚至每周都要交付一个版本时，不可能投入大量的测试工程师来进行大规模的系统级别测试，这时候就需要把整个测试金字塔中的绝大部分测试通过自动化来完成。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/11/v2-5d27810e17c4aedb34d5d71e556a80e5_720w.png" alt="img"></p><span id="more"></span><p>我们今天谈开发者测试，什么是“开发者测试”？ 我司有清晰的开发与测试之分。写代码归开发攻城狮，测试归测试攻城狮，大部分情况下双方处于“红蓝对峙”状态。这与我10多年前的研发团队状况非常相似。而现在的软件工程，专职的“测试攻城狮”非常少，很多公司开发测试比例大于10:1，甚至一些部门没有测试攻城狮一说。 而测试攻城狮的角色不再是手动跑测试用例的“苦力”，而是管理产品的测试系统，对产品测试进行规划、分析；归纳功能测试的思维导图、设计测试用例及带领研发团队进行测试工作，更像一位“测试专家/测试教练”。</p><p>举个简单的例子，我之前做的产品是在线视频会议协作产品，我们每天的线上例会就是用自己做的产品，而且会使用自己开发的新功能测试站点来开“站会”。除了花少量的时间做dialy update，然后就是测试专家带领团队（包括PO、Architect、SM、Dev）按照计划来进行集中（半个小时）的测试。也就是说不止通常说的UT、API、IT等测试，包括系统级别的测试开发也会去做，所以说“开发者测试”就是“开发者来测试”，而我们传统的众多测试工程师面临三种出路：成长、转型、淘汰。而“测试专家”在项目中的话语权也很高，之前的公司使用主干开发，有个“一进一出”的评审，团队的这种类型的“测试专家”有一票否决权。甚至在公司有Principle Engineer级别的测试专家（相当于我司20-21级的技术专家）。</p><ul><li>一进：对于一个功能是否能够进入release branch，在release branch打开feature toggle进行发布级别的测试。</li><li>一出：在engineer release时，该功能质量合格，允许feature toggle进入产线。</li></ul><h2 id="二、没有什么测试不可以“自动化测试”"><a href="#二、没有什么测试不可以“自动化测试”" class="headerlink" title="二、没有什么测试不可以“自动化测试”"></a>二、没有什么测试不可以“自动化测试”</h2><p>回到测试金字塔，从测试的”开发成本”、“执行成本”、“测试覆盖率”、“问题定位”四个维度来看，基于代码级别的白盒测试是及其重要的。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/11/v2-d6c3720208da64136e7f1ed0ed9dc0f0_720w.png" alt="img"></p><ul><li>开发成本： 实现测试用例的成本。</li><li>执行成本：运行一次测试用例的成本。</li><li>测试覆盖率：我们通常所说的line coverage和branch coverage</li><li>问题定位：测试出现问题，定位问题的效率</li></ul><p>通过测试金字塔及其四个测试维度评估，我们可以得出：</p><ul><li>尽可能地多做Low Level Test ：因为他们的执行速度相较于上层的几个测试类型来说快很多且相对稳定，可以一天多次执行。一般来说，LLT灰做到持续集成构建任务中去，甚至在MR中执行，保障进入代码仓库的代码质量。</li><li>在自动化保障的情况下，执行一定规模的IT、ST、UI Test：因为他们的执行速度较慢，环境依赖较多，测试相对不稳定。通常在一天执行一两次（通常在夜里），阶段性的检查代码质量，反馈代码问题。</li><li>尽可能地少做大规模的手动测试：因为他们的执行速度相较LLT且不够稳定，人力成本较高，也无法做到一天多次执行，每次执行都要等很久才能获得反馈结果。但是，他们更贴近真实用户场景，所以要确保一定周期内或者关键节点时间进行这种测试以确保软件质量。</li></ul><p>现在很多公司已经迭代发布的周期越来越短，甚至做到了2周。手动测试显然无法适应这种开发模式，而把手动测试的测试用例通过各种技术方案自动化是唯一途径。代码层面，从底层业务代码到UI代码，只要架构设计合理，都是可以做UT。最顶层的UI交互测试，测试用例也是可以自动化运行（大部分UI框架都可以通过accessibility的接口进行UI自动化测试），我看到华为手机硬件部门都可以自动化测试“摔手机”这种极端测试，软件有啥做不到？至少有些业界技术大牛公司的某些产品，从代码提交Merge Request，到产品上产线是可以以天来计算的。这种产品的测试是不会也不可能通过手工测试来完成的。</p><h2 id="三、开发者测试“利在当下”，“赢得未来”"><a href="#三、开发者测试“利在当下”，“赢得未来”" class="headerlink" title="三、开发者测试“利在当下”，“赢得未来”"></a>三、开发者测试“利在当下”，“赢得未来”</h2><p>很多人都认为底层的开发者测试，花了大量的时间，写了大量的代码，然后来保证功能的正确性，但是每次代码功能或者结构的的变更都要修改测试代码。而我手动调试和验证效率更高，甚至一些开发者测试更多的是为了指标。实际上通过UT，API测试来调试代码与自己手动运行调试区别不大，但是通过开发者测试对代码进行调试，从而保证当前项目迭代的质量；但是其更重要的作用不是这个。通常在我们bug分类中有这样一些名词 : Build Regression Bug， Release Regression Bug。</p><ul><li>Build Regression Bug ： 开发中同样的功能在新版本出现一个bug，但是在之前的版本没有这个问题，我们叫做Build Regression Bug.</li><li>Release Regression Bug : 产线上同样的功能在新版本出现一个bug，但是在之前的版本没有这个问题，我们叫做Release Regression Bug.</li></ul><p>我们每次提交到产品中的代码，没有人可以保证其100%不会出现问题，在敏捷开发的这种快速迭代下，不太可能进行全功能的手动测试，所以开发者测试，特别是底层的UT、API测试、集成测试，能够很容易的识别发现这类问题，也就是开发者测试一个重要的功能是为了防御后面改动的代码对现在代码的影响。所以说开发者测试是”利在当下“，”赢得未来“。</p><h2 id="四、灰度TDD，不强求必须先写测试代码"><a href="#四、灰度TDD，不强求必须先写测试代码" class="headerlink" title="四、灰度TDD，不强求必须先写测试代码"></a>四、灰度TDD，不强求必须先写测试代码</h2><p>对于TDD，大家的认知是先写测试代码，再在写实现代码，这个说法对也不对。概念上没错，但是如果严格这样做，效率未必最高，这也是TDD很难推广的原因之一。我们把编码实现分成3个部分：实现代码、测试代码、调试代码。按照TDD的概念时先写测试代码、然后编码，最后调试。我们通常在代码实现时，一开始不大可能考虑的非常清晰，把接口定义的完全准确，如果严格按照测试、编码、调试来做，测试代码要随着编码频繁修改。 当然这本身不是什么大问题，在实际执行过程中，很多人习惯先搭好代码框架、测试框架，然后再编码，测试。等测试完成后再进行调试。所以从华为灰度管理的角度上来说，只要单元测试在调试之前，都可以称作TDD开发模式。BTW，当然现在开始流行BDD，这里想说的是如果连我说的TDD都做不到的团队，就不要考虑BDD了。</p><p><em>（Behavior-Driven Development：BDD将TDD的一般技术和原理与领域驱动设计(DDD)的想法相结合。 BDD是一个设计活动，您可以根据预期行为逐步构建功能块。 BDD的重点是软件开发过程中使用的语言和交互。 行为驱动的开发人员使用他们的母语与领域驱动设计的语言相结合来描述他们的代码的目的和好处。 使用BDD的团队应该能够以用户故事的形式提供大量的“功能文档”，并增加可执行场景或示例。 BDD通常有助于领域专家理解实现而不是暴露代码级别测试。它通常以GWT格式定义：GIVEN WHEN＆THEN。）</em></p><h2 id="五、UT覆盖率100-真的很不好"><a href="#五、UT覆盖率100-真的很不好" class="headerlink" title="五、UT覆盖率100%真的很不好"></a>五、UT覆盖率100%真的很不好</h2><p>于单元测试，我们都会关注一个指标“覆盖率”。不管模块、函数、行、分支覆盖率，必须要有一定比例的覆盖率。但是每一项你都做到了100%，那么会给你打“差评”。不是说你做到不好（这里不谈是不是用了正确的方式），而是成本和性价比问题。以最难达到的分支覆盖率（branch coverage）为例，如果要做到100%的覆盖率，有些内存分配或者容错保护的分支都必须测试到，那么你的测试用例考虑要翻倍，但是并没有带来的相应价值。甚至一些代码条件分支在程序运行的生命周期内都没有被执行过。</p><ul><li>模块覆盖率：业务模块代码通过UT，架构模块代码通过IT；就从UT的覆盖率的角度上去看，不需要去测试架构代码。</li><li>函数覆盖率：不要专门为一些无任何逻辑的代码去写UT。比如我们有些函数就是get/set一个属性，内部实现就用一个变量来赋值保存。这种函数写UT就是为了覆盖率而写，没有任何真正的意义。</li><li>行覆盖率：通常来看平局80%上下的行覆盖率是一个合理的指标，有些可以为0%，而有些需要100%，如果全部代码都超过90%，其成本较高，效率较低，不建议这样做。</li><li>分支覆盖率：越复杂的业务逻辑，越要写更多的测试用例来覆盖，而一些内存分配出错逻辑判断可以不需要测试。</li></ul><h2 id="六、用测试来驱动架构和代码质量"><a href="#六、用测试来驱动架构和代码质量" class="headerlink" title="六、用测试来驱动架构和代码质量"></a>六、用测试来驱动架构和代码质量</h2><p>这里谈测试驱动架构和代码质量，主要说的是让代码具备完善的可测试性，什么是代码的可测试性？简单的说就是类与类之间，模块与模块关系解耦，类与类，模块与模块通过接口编程。依赖的接口通过被动注入式传入，而不是主动获取式。对于程序正常运行时，所传入的接口参数是真实的业务对象，而做测试时，可以传入fake的模拟实现。当然不是所有的依赖模块都这样做，一些与业务无关的Utility Library，或者一些特定的数据对象实现，可以直接调用。</p><p>这里我们讲到了fake与mock，关于Test Doubles，基本上的概念如下，具体每种代表什么意义，大家可以自行上网搜索</p><ul><li>虚拟对象（dummy）</li><li>存根（stub）</li><li>间谍（spy）</li><li>模拟对象（mock）</li><li>伪对象（fake）</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/11/v2-9008d7b476fef1455e8cf837a8603aba_720w.png" alt="img"></p><p>当前我司大家在做开发者测试时，基本上都在用Mock Object（实际上在用的过程中，很多是在用入参返回值控制的Stub）。还记得前些年DHH（David Heinemeier Hansson）的那篇文章《TDD is dead, Long live testing》，其中一点对于TDD中过度的使用Mock/Stub导致架构上诸多问题。而TDD创始人Kent Beck则说他从来不用Mock。 虽然通过Mock的方式也是可以测试代码，但是实际上不得不用Mock基本上意味着我们的代码关联性较强，模块显示依赖较重，模块移植性较差，特别是C语言编程这种问题特别多。以至于现在很多模块根本无法开展单元测试，更多的是在做集成测试。</p><p>为什么会出现这种情况？ 我们的高级别的架构师更多的在考虑系统级别的架构设计，把系统模块，各个应用之间的关系梳理的非常清晰，通常情况下，高级别的架构师可以把系统模块或应用之间的关系设计的较为合理。然而到了具体的应用业务内部的设计与实现，交给了低级别的架构师来完成。实际上这些模块内部的代码量并不小，很多都是几十万行甚至上百万行的代码量。这时候架构师的水平决定了代码的Clean Code质量。我司目前代码上的问题很多不是系统架构的问题，而是具体业务实现中，缺少严格的要求和合理的架构设计。如果在应用级别有一套架构方案来规范，那么至少在模块的接口以及模块与模块之前的交互上也能达到和系统设计一样较为清晰合理。那么不确定的部分就时每个子模块内部几千上万行的代码部分。</p><p>最近做项目技术评审时，遇到一个典型的例子。一个团队写了一个socket库，底层依赖特定平台的系统库。如果要把该socket库移植到linux或者别的平台，就需要较大规模的重构。重构的方法应该很容易理解，就是通过适配器模式，把底层的操作抽象成接口（这里针对socket库来说，底层库是一种依赖，不同的场景要区别对待底层库，不要一概而论），实际代码不关注具体平台的具体实现，而通过实现不同平台的adapter来进行适配解决该问题。然而在开发初期，其设计在搭建代码框架、测试框架时就会发现底层库是一种耦合，测试时不得不做Mock来实现测试替身。如果这时候就考虑解耦式设计，那么当支持不同平台时，架构本身就天然支持而不需要再重构了。</p><p>之所以提出用测试驱动架构和代码质量，当给测试提出一个很高的标准时（之前做过的项目中有的项目明确UT不允许使用Mock，测试框架甚至只有单一的Catch2），大家不得不从架构上去解决测试的问题，当测试的问题解决时，代码架构上的Clean Code L3自然而然就达到了。</p><h2 id="七、从“我要写测试依赖代码”到“我要写测试依赖代码”"><a href="#七、从“我要写测试依赖代码”到“我要写测试依赖代码”" class="headerlink" title="七、从“我要写测试依赖代码”到“我要写测试依赖代码”"></a>七、从“我要写测试依赖代码”到“我要写测试依赖代码”</h2><p>这句话看着很奇怪，实际上是从根本上去解决底层开发者测试的根本方法。 模块之间有依赖，不管是通过Mock还是Fake的方法，不管架构上如何合理，这种依赖是不能消除的，我们做到更多的是合理的设计让依赖与模块解耦。第一个“我要写测试依赖代码”，指的是当我实现我的模块时，我要写测试代码来测试。然而我要考的是如何写我的测试依赖。这时候常常出现了的问题，比如是A1, A2, A3三个模块依赖与B1， B2两个模块，通常情况下我司的做A1，A2，A3的团队或者个人会自己去写B1，B2的依赖，导致重复的测试代码，如果模块设计不合理，测试依赖太多，单元测试成本太高。而第二个“我要写测试依赖代码”指的是，当我实现我的代码时，我要考虑的是依赖我的模块在测试时，对于我的依赖该怎么解决，”我要写测试依赖代码”（就是我说的fake对象与实现）来帮助依赖我的模块解决测试依赖问题。同样的情况在测试A1，A2，A3的时候，B1，B2的依赖已经存在，只要直接关注在测试用例本身就可以了。具体来说：</p><ul><li>思维转变、测试驱动：开发一个模块，不要先考虑怎么测试自己，先考虑如果别人依赖我，我该怎么让别人更容易测试。模块的提供者，不止要提供模块代码，还要提供一个可复用的Faked对象（调用验证；返回值；参数验证；参数处理；功能模拟等）。</li><li>模块代码的编写者实现自己的Fake实现，基本上大部分的代码是由模块编写者来完成，同时这是一个可复用的Fake实现。模块依赖方根据自己一些特殊的业务需求来添加自己的代码。基本上遵循80/20原则。</li><li>架构上依赖解耦，通过注入依赖的方式进行接口编程。产品运行时，模块使用真实的实现对象，而开发者测试使用Fake对象。</li><li>当编写测试代码时，所有依赖的接口、依赖的实现都基本完成，更多的关注些测试用例而不是测试依赖。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 敏捷项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发者测试 </tag>
            
            <tag> 敏捷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让WebSocket支持Oauth2 TOKEN验证的尝试</title>
      <link href="2022/10/10/221010-%E8%AE%A9WebSocket%E6%94%AF%E6%8C%81Oauth2-TOKEN%E9%AA%8C%E8%AF%81%E7%9A%84%E5%B0%9D%E8%AF%95/"/>
      <url>2022/10/10/221010-%E8%AE%A9WebSocket%E6%94%AF%E6%8C%81Oauth2-TOKEN%E9%AA%8C%E8%AF%81%E7%9A%84%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>​        很早的时候在下用一种比较简陋的方式利用WebSocket实现了在线Selenium执行功能<a class="link" href="https://www.ray0728.cn/2021/06/20/%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">《一》<i class="fas fa-external-link-alt"></i></a>、<a class="link" href="https://www.ray0728.cn/2021/06/24/%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%EF%BC%88%E4%BA%8C%EF%BC%89/">《二》<i class="fas fa-external-link-alt"></i></a>。大概效果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/26/Screenshot_20210622_232534_com.huawei.browser.jpg" alt="codeonline"></p><p>​        其实实现原理挺粗暴的，服务端开启一个WebSocket服务端，一直处于监听状态。浏览器利用js脚本发起连接，并将内容通过WebSocket发送给服务端。只要发送的格式符合服务端的定义，理论上讲，服务端会<strong>无条件执行任何请求</strong>。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/10/59136ae0da0391e7329f8d9d0b918f8e.png" alt="59136ae0da0391e7329f8d9d0b918f8e.png"></p><p>​        虽然过去了这么久，但是一想到服务器上还运行这么危险的服务，我便久久无法入眠（其实并没有）。趁着这次国庆大假，在家又折腾了一下我的在线代码执行服务，最主要的目标就是让websocket能更安全的运行。</p><p>​        怎么才能更安全的运行呢？当然要利用小云上已运行的KeyCloak所提供的OAuth2认证啦。</p><span id="more"></span><h3 id="OAuth2-Token"><a href="#OAuth2-Token" class="headerlink" title="OAuth2 Token"></a>OAuth2 Token</h3><h4 id="什么是OAuth2？"><a href="#什么是OAuth2？" class="headerlink" title="什么是OAuth2？"></a>什么是OAuth2？</h4><blockquote><p>OAuth</p><p>允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的2小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要分享他们的访问许可或他们数据的所有内容。</p><p>OAuth是OpenID的一个补充，但是完全不同的服务。</p><p>OAuth 2.0</p><p>是OAuth协议的下一版本，但不向后兼容OAuth 1.0。 OAuth 2.0关注客户端开发者的简易性，同时为Web应用，桌面应用和手机，和起居室设备提供专门的认证流程。2012年10月，OAuth 2.0协议正式发布为RFC 6749</p></blockquote><h4 id="什么是Token？"><a href="#什么是Token？" class="headerlink" title="什么是Token？"></a>什么是Token？</h4><p>​        Token就是OAuth2服务器向用户发放的一个令牌，用户持有这个令牌就可以访问所有允许被访问的资源。令牌与密码的作用是一样的，都可以用于身份的校验，但是在OAuth2协议之下也有些差异。</p><blockquote><ol><li>令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化</li><li>令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</li><li>令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</li></ol></blockquote><p>​        正是由于令牌的灵活性，保证了其既可以让三方应用获得权限，又随时可控（范围、时间），不用担心像密码那样危及整个系统的安全。</p><h4 id="什么是SSO？"><a href="#什么是SSO？" class="headerlink" title="什么是SSO？"></a>什么是SSO？</h4><blockquote><p>单点登录(SingleSignOn，SSO)，就是通过用户的一次性鉴别登录。当用户在<a class="link" href="https://baike.baidu.com/item/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%99%A8/10881881?fromModule=lemma_inlink">身份认证服务器<i class="fas fa-external-link-alt"></i></a>上登录一次以后，即可获得访问单点登录系统中其他关联系统和应用软件的权限，同时这种实现是不需要管理员对用户的登录状态或其他信息进行修改的，这意味着在多个应用系统中，用户只需一次登录就可以访问所有相互信任的应用系统。这种方式减少了由登录产生的时间消耗，辅助了用户管理，是比较流行的。</p></blockquote><p>​        结合上文，OAuth2提供Token不就是实现SSO最好的方式吗？</p><p>​        基于之前在小云上搭建<a class="link" href="https://www.ray0728.cn/2021/10/27/gatway%E4%BD%BF%E7%94%A8Security%E9%80%82%E9%85%8DKeycloak/">《适配KeyCloak的网管服务》<i class="fas fa-external-link-alt"></i></a>，Beta小云已支持SSO登录。换言之，用浏览器打开我的在线执行地址，通过SSO，可以从KeyCloak获取到一个Token。有了这个Token，就意味着从当前会话中发出的请求都可以带上这个Token，如果Token有效，则运行继续访问，如果无效则拒绝当前的请求。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/11/Video_20221011_113316_122.gif" alt="Video_20221011_113316_122.gif"></p><p>​        那么WebSocket是否也可以呢？</p><h3 id="Spring-Security-如何验证Token？"><a href="#Spring-Security-如何验证Token？" class="headerlink" title="Spring Security 如何验证Token？"></a>Spring Security 如何验证Token？</h3><p>​        在<a class="link" href="https://www.ray0728.cn/2022/03/19/Spring_resource_server/">《Spring极简资源服务器》<i class="fas fa-external-link-alt"></i></a>中介绍了一种利用Spring Security快速构建资源服务器的方法，并且该资源服务器可验证访问请求中的Token是否合法有效。不过这只是解决了如何做（How），并没有解释为什么能这样（Why）。</p><p>​        其实关于Spring Security如何进行OAuth2验证的文章，网上挺多的，我这里就简单说说吧。</p><p>​        Spring 对请求报文的处理大部分都是在Filter中进行的，我们在代码<code>WebSecurityConfigurerAdapter</code>中配置了资源管理策略，大部分的配置差不多都长这个样子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void configure(HttpSecurity http) throws Exception{        http.authorizeRequests(authz -&gt; authz                .antMatchers(HttpMethod.GET, "/xxx/").permitAll()                .antMatchers(HttpMethod.GET, "/xxx/auth/**").hasRole(role_auth)                .antMatchers(HttpMethod.GET, "/xxx/admin/**").hasRole(role_admin)                .anyRequest().authenticated())                .oauth2ResourceServer().jwt().jwtAuthenticationConverter(converter);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        其实就是向Spring Filter Chain 添加了OAuth2校验Filter。当然这一步仅仅是让Spring框架知道，接收到请求报文后需要进行对应的处理而已，并不是真正验证的地方。真正进行验证的入口地方在</p><p><kbd>org.springframework.security.authentication.ProviderManager</kbd>的<strong>authenticate</strong>函数。</p><p>​        因为我的KeyCloak提供的是JWT Token，因此Spring框架会进一步将收到的Token交给</p><p><kbd>org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationProvider</kbd>的<strong>authenticate</strong>函数。</p><p>​        之后经过一系列眼花缭乱的封装转换后，Spring框架将收到的Token转换为一个<strong>JWT</strong>对象，<strong>注意</strong>这个JWT对象中的数据均与请求中的数据保持一直，即<strong>并不判断其是否有效</strong>。</p><h4 id="服务端公钥比对"><a href="#服务端公钥比对" class="headerlink" title="服务端公钥比对"></a>服务端公钥比对</h4><p>​        终于来到重点操作部分了，<kbd>com.nimbusds.jose.proc.JWSVerificationKeySelector</kbd>的<strong>selectJWSKeys</strong>函数，这个函数只做一件事儿，从OAuth服务端获取<strong>JWT公钥信息</strong>。对于KeyCloak来说可以访问”/realms/Beta/protocol/openid-connect/certs”来获取。拿到JWT公钥信息之后，则会与之前转换的JWT对象进行对比（主要对比签名的公钥是否一致），如果比对成功则会进入下一步解析Token的操作。那么如果比对不成功呢？就会抛出异常：</p><p><code>throw new BadJOSEException("Signed JWT rejected: Another algorithm expected, or no matching key(s) found");</code></p><p>​        毕竟比对了半天都找不到合适的公钥，这对Spring来说，也是相当懵逼的呢？不是吗？</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/11/3c3b789312d61078cab0f9b32cd53f1d.png" alt="3c3b789312d61078cab0f9b32cd53f1d.png"></p><h4 id="解析-amp-校验Token"><a href="#解析-amp-校验Token" class="headerlink" title="解析&amp;校验Token"></a>解析&amp;校验Token</h4><p>​        经历了上面的的操作后，Spring框架基本可以认为当前收到的Token，是未被篡改过的，如果有篡改，则无法匹配上OAuth2服务端的公钥。既然未篡改，那么接下来就需要确认下Token是否过期、Token是否拥相关的权限资格。</p><p>​        Spring Security框架会用到2个校验器对Token进行校验，分别是：</p><ul><li>org.springframework.security.oauth2.jwt.JwtTimestampValidator</li><li>org.springframework.security.oauth2.jwt.JwtIssuerValidator</li></ul><p>​        首先会用到<kbd>JwtTimestampValidator</kbd>的<strong>validate</strong>h函数对过期时间进行判断。如果Token中的过期时间已在服务器时间之前，那么Spring会返回一个<strong>OAuth2Error</strong>的错误，内容大概是“你的JWT 过期时间是xxxx”。</p><p>​        紧接着会用到<kbd>JwtIssuerValidator</kbd>的<strong>validate</strong>函数对权限进行判断。还记的我在<a class="link" href="https://www.ray0728.cn/2022/03/19/Spring_resource_server/">《Spring极简资源服务器》<i class="fas fa-external-link-alt"></i></a>中我自定义了一段权限解析器的代码吗？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">JwtAuthenticationConverter converter = new JwtAuthenticationConverter();converter.setJwtGrantedAuthoritiesConverter(new Converter&lt;Jwt, Collection&lt;GrantedAuthority&gt;&gt;() {    @Override    public Collection&lt;GrantedAuthority&gt; convert(Jwt source) {        JSONArray roles = (JSONArray) ((JSONObject) (source.getClaims().get("realm_access"))).get("roles");        //                JSONArray scopes = (JSONArray) ((JSONObject) (source.getClaims().get("resource_access"))).get("roles");        ArrayList&lt;GrantedAuthority&gt; roleArray = new ArrayList&lt;&gt;();        for(int i = 0; i &lt; roles.size(); i++){            roleArray.add(new Role(roles.get(i)));        }        return roleArray;    }});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        是的，没错！<strong>JwtIssuerValidator</strong>最终会调用到这段代码，以便按照我们预期的方式解析出Token中的权限（角色）信息，再和被请求访问的资源所要求的权限（角色）信息进行对比。</p><p>​        好了，校验完成后，如果存在错误信息，则会抛出<strong>JwtValidationException</strong>异常，剩下的就交给Filter继续处理吧，该报401的报401，该报302的报302。</p><h3 id="WebSocket-能否支持Token验证？"><a href="#WebSocket-能否支持Token验证？" class="headerlink" title="WebSocket 能否支持Token验证？"></a>WebSocket 能否支持Token验证？</h3><p>​        遗憾的是，似乎WebSocket协议本身并不支持OAuth2协议，无法在头部中插入<kbd>Authorization</kbd>字段（可能有办法，只不过我还不知道罢了）。同时Spring的Security Filter也并不会处理<strong>ws/wss协议</strong>过来的数据。</p><p>​        既然无法利用Spring Security自动完成Token的校验，那么唯一可行的办法就是让WebSocket将Token作为信息的一部分传送给服务端，我们就自己去OAuth2 服务端验证吧，大不了模仿Spring框架再做一套呗。</p><h3 id="OAuth2-Server-Endpoint"><a href="#OAuth2-Server-Endpoint" class="headerlink" title="OAuth2 Server Endpoint"></a>OAuth2 Server Endpoint</h3><p>​        如果你用过早期的Spring cloud OAuth2 Server，一定知道它提供了多个Endpoint，比如这些：</p><ul><li>/oauth/authorize：获取授权码的端点</li><li>/oauth/token：获取令牌端点。</li><li>/oauth/confifirm_access：用户确认授权提交端点。</li><li>/oauth/error：授权服务错误信息端点。</li><li>/oauth/check_token：用于资源服务访问的令牌解析端点。</li><li>/oauth/token_key：提供JWT公有密匙端点。</li></ul><p>​        其中有一个端点很有意思，<kbd>check_token</kbd>，资源服务器接收到带Token的访问请求后，会将Token发回这个端点，并根据端点返回的结果判断，当前请求是否具有必要的访问权限。</p><p>​        那么我可否先将WebSocket接收到的Token，送给OAuth2服务器做一次验证，如果验证通过，则表明当前请求是被授权了的呢？</p><p>​        答案当然是可以。不过我的OAuth2服务器是KeyCloak，这个端点需要做些调整。</p><h3 id="KeyCloak-Endpoint"><a href="#KeyCloak-Endpoint" class="headerlink" title="KeyCloak Endpoint"></a>KeyCloak Endpoint</h3><p>​        KeyCloak的端点有很多，通过访问</p><p><kbd>$OAuth2_Server_Address/realms/$OAuth2_Realm/.well-known/openid-configuration</kbd></p><p>可以查看到当前服务对外提供的所有端点（当然也包含很多其它的信息，感兴趣的小伙伴可以自己查查看）：</p><blockquote><p>{<br>    “authorization_endpoint”: “<a class="link" href="http://localhost:8080/realms/Test/protocol/openid-connect/auth&quot;">http://localhost:8080/realms/Test/protocol/openid-connect/auth"<i class="fas fa-external-link-alt"></i></a>,<br>    “token_endpoint”: “<a class="link" href="http://localhost:8080/realms/Test/protocol/openid-connect/token&quot;">http://localhost:8080/realms/Test/protocol/openid-connect/token"<i class="fas fa-external-link-alt"></i></a>,<br>    “introspection_endpoint”: “<a class="link" href="http://localhost:8080/realms/Test/protocol/openid-connect/token/introspect&quot;">http://localhost:8080/realms/Test/protocol/openid-connect/token/introspect"<i class="fas fa-external-link-alt"></i></a>,<br>    “userinfo_endpoint”: “<a class="link" href="http://localhost:8080/realms/Test/protocol/openid-connect/userinfo&quot;">http://localhost:8080/realms/Test/protocol/openid-connect/userinfo"<i class="fas fa-external-link-alt"></i></a>,<br>    “end_session_endpoint”: “<a class="link" href="http://localhost:8080/realms/Test/protocol/openid-connect/logout&quot;">http://localhost:8080/realms/Test/protocol/openid-connect/logout"<i class="fas fa-external-link-alt"></i></a>,<br>  ……<br>    “registration_endpoint”: “<a class="link" href="http://localhost:8080/realms/Test/clients-registrations/openid-connect&quot;">http://localhost:8080/realms/Test/clients-registrations/openid-connect"<i class="fas fa-external-link-alt"></i></a>,<br>  ……<br>    “introspection_endpoint_auth_methods_supported”: [<br>        “private_key_jwt”,<br>        “client_secret_basic”,<br>        “client_secret_post”,<br>        “tls_client_auth”,<br>        “client_secret_jwt”<br>    ],introspection_endpoint</p><p>……</p><p>}</p></blockquote><p>​        这是在本地执行的一个KeyCloak环境上查询的结果，这当中有一个<strong>introspection_endpoint</strong>。该端点的作用可以用来校验Token是否有效。</p><p>​        只需要以POST的方式向该Endpoint提交包含如下信息的表单即可进行Token的验证。</p><ol><li>username      : 用户名</li><li>client_id        : Client ID</li><li>client_secret : Client Credentials Secret Code</li><li>token              : 需要验证的Token</li></ol><p>​        无论Token是否有效，只要前面三项填写正确，端点都将返回200。而验证结果以JSON的格式在Respond Body中体现。</p><p>​        如Token无效（错误或过期）时，返回如下图：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/10/active_false.jpg" alt="active_false.jpg"></p><p>​    如果Token有效，则返回如下图：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/10/10/active_true.jpg" alt="active_true.jpg"></p><p>​        返回结果中最关键的就是<kbd>active</kbd>字段，因此Token是否有效、合法，完全可通过该字段进行判断。</p><h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a>Java代码实现</h3><p>​        有了上面的判断，那么用代码实现就变成顺理成章的事儿了。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static Boolean verfiyOAuthToken(String url, String clientid, String clientsecret, String username, String token){        Boolean ret = null;        OutputStreamWriter out = null;        BufferedReader in = null;        StringBuilder result = new StringBuilder();        try{            URL introspectUrl = new URL(url);            HttpURLConnection conn =(HttpURLConnection)introspectUrl.openConnection();            conn.setDoOutput(true);            conn.setDoInput(true);            conn.setRequestMethod("POST");            conn.setRequestProperty("accept", "*/*");            conn.setRequestProperty("connection", "Keep-Alive");            conn.setRequestProperty("user-agent",            "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1;SV1)");            conn.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");            conn.connect();            out = new OutputStreamWriter(conn.getOutputStream(), "UTF-8");            String data = String.format("username=%s&amp;client_id=%s&amp;client_secret=%s&amp;token=%s", username, clientid, clientsecret, token);            out.write(data);的            out.flush();            in = new BufferedReader(new InputStreamReader(conn.getInputStream(), "UTF-8"));            String line;            while ((line = in.readLine()) != null) {                result.append(line);            }            System.out.println(String.format("verfiyOAuthToken: params(%s),", data, result.toString()));            ret = JSONObject.parseObject(result.toString()).getBoolean("active");        }catch(IOException e){            e.printStackTrace();        }finally{            try{                if(out != null){                    out.close();                }                if(in != null){                    in.close();                }            }catch(IOException e){                e.printStackTrace();            }        }        System.out.println("verfiyOAuthToken ret:" + ret);        return ret;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        至此，我们的服务程序就可以去校验WebSocket传送的Token，是否合法有效（这里，我做的比较简单，仅仅判断Token是否处于激活状态）。</p><p>相关代码已更新至<a class="link" href="https://gitee.com/ray0728/resource">Gitee<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> KeyCloak </tag>
            
            <tag> Nginx </tag>
            
            <tag> Websocket </tag>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学摸鱼之Excel小技巧(二)</title>
      <link href="2022/08/04/220804-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%BA%8C)/"/>
      <url>2022/08/04/220804-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/logo.png" alt="logo.png" style="zoom:50%;"><p>  接<a class="link" href="https://www.ray0728.cn/2022/07/31/%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%B8%80)/">上一期<i class="fas fa-external-link-alt"></i></a>我们分享了几个关于EXCEL的使用小技巧，本期我们继续聊一聊EXCEL其它看上去很酷炫的操作。</p><p>  本期内容同样是天选打工人熬夜整理出来的，吐血推荐。</p><p>  下面就开始我们今天的<strong>摸鱼小技巧</strong>吧。</p><hr><h2 id="多级菜单"><a href="#多级菜单" class="headerlink" title="多级菜单"></a>多级菜单</h2><p>  EXCEL不仅仅只是单纯的录入数据，还可以变得非常“智能”的自动选择录入的内容，比如这样：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/08/03/71df79a21b61ccb74725aeca0679ed37.gif" alt="员工信息录入"></p><p>  这是一个常见的员工登记表格，不同的员工在不同的部门下工作。假设这家公司共有三级部门，每个一级部门下又有各自不同的二级乃至三级部门，在录入的时候二三级部门会跟随其上一级部门变化而变化。</p><span id="more"></span><p>  是不是让人眼前一亮，这就是多级菜单，实现方法其实很简单。</p><h3 id="STEP1-创建数据"><a href="#STEP1-创建数据" class="headerlink" title="STEP1. 创建数据"></a>STEP1. 创建数据</h3><p>  假设该公司的部门划分如图示：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/08/04/21bddac688d5360136e84a3ebcb8c4ed.png" alt="部门划分.png"></p><p>  首先将部门信息录入进EXCEL，格式可采用下图所示：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/08/04/01a7e86666aee8c002ea931c3de56aa6.png" alt="部门.png"></p><h3 id="STEP-2-设置名称"><a href="#STEP-2-设置名称" class="headerlink" title="STEP 2. 设置名称"></a>STEP 2. 设置名称</h3><p>  可以通过名称管理器，将各部门信息定义成不同的名称，以便后面更方便的使用，定义方式很简单。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/08/04/fcf81726c6f853123e00a1a27a21cee7.gif" alt="创建名称"></p><p>  一般来说，我们常常将一行或一列的数据定义为一个名称，这里我们采用列的方式，并且默认选择首行作为名称。</p><p>  在我们未定义名称前，可以看到<strong>名称管理器</strong>是一个空列表，之后选中需要定义的范围，然后点击<strong>公式</strong>菜单，再点击<strong>根据所选内容创建</strong>即可。这个时候我们再回头去看<strong>名称管理器</strong>就能发现其内容中多了一条我们刚刚创建的名称。</p><p>  之后的操作，可能看着就有点迷糊了，我仅仅是挨个选择了一遍，并没有再次点击<strong>根据所选内容创建</strong>，为什么<strong>名称管理器</strong>里面就自动增加了这么多呢？这里使用到了EXCEL的一个小技巧，<strong>自动重复操作</strong>。如果需要重复上一次的操作（快捷键、功能键等），只需要按<kbd>F4</kbd>就行了。</p><p>  当我们创建好名称后，剩下的就是去设置单元格录入内容范围。</p><h3 id="STEP3-数据校验"><a href="#STEP3-数据校验" class="headerlink" title="STEP3. 数据校验"></a>STEP3. 数据校验</h3><p>  这里会用到EXCEL数据菜单中<strong>数据校验功能</strong>，首先我们对一级部门单元格设置数据校验。将其配置为<strong>序列</strong>，来源为<code>=族类</code>。这里的族类就是STEP2中我们针对一级部门设置的名称，要是忘记了的话，可以往上再翻翻看。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/08/04/5be501358ff2ffd946be76c02915f212.png" alt="一级部门.png"></p><p>  对于二级部门，我们同样对单元格设置数据校验，来源设置为<code>=INDIRECT(C2)</code>。而三级部门的数据校验则设置为<code>=INDIRECT(D2)</code>即可。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/08/04/2.png" alt="二级部门.png"></p><p>  设置好之后，即可体验到EXCEL多级菜单的便捷之处。完整设置过程如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/08/04/0fee2e0c1b67f281bd77515485d15397.gif" alt="部门数据校验设置.gif"></p><h3 id="原理一点通"><a href="#原理一点通" class="headerlink" title="原理一点通"></a>原理一点通</h3><p>  看上去很神奇的多级菜单，背后的原理其实很简单，主要就是利用<strong>数据校验</strong>中<strong>序列</strong>的功能，使得单元格能自动限定输入的范围。而为了实现单元格限定输入范围的动态变化，我们用了INDIRECT函数，其官方解释如下：</p><blockquote><p>INDIRECT 函数简要说明<br><br>  返回由文本字符串指定的引用。 此函数立即对引用进行计算，并显示其内容。 如果需要更改公式中对单元格的引用，而不更改公式本身。</p></blockquote><p>  这段描述没看懂也没关系，简单来说INDIRECT可以返回一段指定的内容，而指定的方式可以是我们常见的单元格范围，比如：A1:A5。也可以是一个<strong>名称</strong>。范围变化或名称变化，那么INDIRECT返回的内容就会发生变化。</p><p>  所以我们将各级部门都定义成了名称，当选定了一级部门之后，只需要在二级部门单元格中显示对一级部门的引用，即可实现动态变化。</p><p>  好了今天的小技巧就分享到这里，科学摸鱼系列未完待续，敬请期待后续笔记。</p>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科学摸鱼之Excel小技巧(一)</title>
      <link href="2022/07/31/220731-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%B8%80)/"/>
      <url>2022/07/31/220731-%E7%A7%91%E5%AD%A6%E6%91%B8%E9%B1%BC%E4%B9%8BExcel%E5%B0%8F%E6%8A%80%E5%B7%A7(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/logo.png" alt="logo.png" style="zoom:50%;"><p>  做为一名天选打工人，即便在当前疫情突然加重，需要居家办公的今天，仍然要在家处理各种各样的表格，为老板们准备各种各样的汇报材料。正因为居家办公不用上下班打卡了，所以老板们似乎也觉得7x24小时待命变得合情合理，唉，生活真是太难了。</p><p>  在不断与Office三剑客爱恨纠葛之后，慢慢也掌握了一些如何<strong>高效、快捷、省时省力</strong>的完成各种<strong>数据录入、数据整理、数据呈现</strong>的奇技婬巧，天选打工之人熬夜整理出各种<strong>高频、常用、一看就会</strong>小技巧都汇总在这里，吐血推荐。</p><p>  下面就开始我们今天的<strong>摸鱼小技巧</strong>吧。</p><hr><span id="more"></span><h2 id="快速录入"><a href="#快速录入" class="headerlink" title="快速录入"></a>快速录入</h2><h3 id="按行录入"><a href="#按行录入" class="headerlink" title="按行录入"></a>按行录入</h3><p>  Excel默认是按列进行录入的，在单元格输入后按回车即可自动跳转到同一列的下一行进行输入。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/96e3c320306dd2c22ba46e3e47258cf4.gif" alt="默认录入方向"></p><p>  但实际很多时候我们是按行进行输入数据，所以Excel这个默认设置反而不便于我们的输入。这个时候就需要更改按下Enter的默认行为设置，设置方式也是很简单的。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/a255bc5767f9781dca58f0a487bc43bd.gif" alt="a255bc5767f9781dca58f0a487bc43bd.gif"></p><p><strong>备注：</strong> 我们也可以使用快捷键快速打开设置界面<kbd>Alt</kbd>+<kbd>F</kbd>+<kbd>T</kbd><br><a href="https://arts.ray0728.cn/image/ZFRY"><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/3f101336ac320abffcf706c10bf230d5.jpg" alt="3f101336ac320abffcf706c10bf230d5.jpg"></a></p><h3 id="限制录入范围"><a href="#限制录入范围" class="headerlink" title="限制录入范围"></a>限制录入范围</h3><p>  虽然通过更改设置，让EXCEL默认按行录入了，但是我们在输完一行数据后，还是需要移动输入框到下一行起始位置，确实还是有些不方便，如果能自动换行到下一个输入单元格就好了。其实方法也挺简单，就是先限制输入范围，再开始录入。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/6195dc55378ffb74e2d449b728a6a1bd.gif" alt="6195dc55378ffb74e2d449b728a6a1bd.gif"></p><h2 id="自助检查"><a href="#自助检查" class="headerlink" title="自助检查"></a>自助检查</h2><p>  在我们录入大量数据的时候，最害怕的就是看走了眼，在录入很多数据之后才突然发现录入的数据和原始数据对不上，这个时候只能重头挨个检查，找出出错的位置进行修改。如果我们录入一个数据，旁边有一个人帮我们做double check，岂不是很棒？其实Excel就能帮我们做到这步。</p><h3 id="录入朗读"><a href="#录入朗读" class="headerlink" title="录入朗读"></a>录入朗读</h3><p>  Excel支持我们完成一次单元格的输入后，自动朗读我们刚刚输入的内容，开启的步骤很简单。</p><ol><li>打开<strong>Excel选项卡</strong>（可通过快捷键<kbd>Alt</kbd>+<kbd>F</kbd>+<kbd>T</kbd>打开）。</li><li>点击<strong>快速访问工具栏</strong>，在<strong>从下列位置选择命令</strong>选项框中选择<strong>不在功能区中的命令</strong>。</li><li>在菜单列表中找到<strong>按Enter开始朗读单元格</strong>选项（位置如下图所示），并点击<strong>添加</strong>。</li><li>点击<strong>确认</strong>即可。</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/4077781c5a1515ed1c9664041f810757.jpg" alt="4077781c5a1515ed1c9664041f810757.jpg"></p><p>  这个时候我们能在Excel快速访问栏中发现多了一个按钮。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/Enter.jpg" alt="Enter.jpg"></p><p>  点击这个按钮能听到系统提示音：“从现在开始，输入单元格的内容都将朗读出来”，之后我们在任意单元格输入数字、中文、英文、特殊字符都能听到系统自动将输入内容朗读出来。这样我们就可以在输入后立即听到刚刚输入的内容，以便于判断我们输入是否正确。若想停止自动朗读，则再点击一次快速访问栏中的按钮即可。</p><p>  这里有一个有趣的事儿，如果我们输入@符号，系统会将其读为圈A，如果输入的是<a class="link" href="mailto:myname@mail.com">myname@mail.com<i class="fas fa-external-link-alt"></i></a>，这种E-Mail格式的内容，则会正确的读为at，大家可以试试看还有哪些有意思的发音。</p><h4 id="语音设置"><a href="#语音设置" class="headerlink" title="语音设置"></a>语音设置</h4><p>  系统的朗读语速可能并不适合我们的习惯，所以有需要的话可以看看下面的小贴士，若不需要跳过即可。</p><ol><li>打开系统开始菜单（按<kbd>Win</kbd>或点击Windows开始图标），直接输入<strong>控制面板</strong>，即可看见控制面板图标，单击打开。</li><li>点击右上角的<strong>查看方式</strong>，选择为<strong>大图标</strong>。</li><li>单击<strong>语音识别</strong>，进入语音识别菜单，并单击左侧菜单中的<strong>文本到语音转换</strong></li><li>在弹出的选项卡中，<strong>调节语速</strong>即可</li><li>点击<strong>确定</strong>（由于我的笔记本分辨率设置问题，无法完整显示选项卡，因此我利用<kbd>Tab</kbd>键，将光标移动到确定按钮上，再输入<kbd>Enter</kbd>，以达到鼠标点击的效果）。</li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/4cb016e6588bc536413834e1f85def20.gif" alt="4cb016e6588bc536413834e1f85def20.gif"></p><p>  这个时候Excel的自动朗读语速就会发生变化，大家可以自己动手试试看。</p><p>  但我们有时候并不希望每次录入的时候都有一次朗读，而是希望等全部录入完成后，再做一次数据检查，这能做到吗？当然是可以的。我们在快速访问工具栏中可以再添加另外两种朗读模式：<strong>按列朗读单元格、按行朗读单元格</strong>以及其对应的功能按钮：<strong>朗读单元格、停止朗读单元格</strong></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/219dd5b274464c9835fa57fe371962f0.jpg" alt="219dd5b274464c9835fa57fe371962f0.jpg"></p><p>  添加完成后，能发现在快速访问栏中又多了几个按钮。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/35f3f4084e3e8e807ea456327e259a27.jpg" alt="35f3f4084e3e8e807ea456327e259a27.jpg"></p><h3 id="按行-列朗读"><a href="#按行-列朗读" class="headerlink" title="按行/列朗读"></a>按行/列朗读</h3><p>  根据选择的不同模式，EXCEL可自动对我们选择范围内的内容按行或列的方式依次进行单元格朗读，这样我们就可以一边看着原始数据，一边听EXCEL自动朗读单元格的内容进行内容检查了。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/07/31/41b7edcb5405e43fe775cdd1e5e9c8e7.gif" alt="41b7edcb5405e43fe775cdd1e5e9c8e7.gif"></p><p>  好了今天的小技巧就分享到这里，科学摸鱼系列未完待续，敬请期待后续笔记。</p>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> office </tag>
            
            <tag> excel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次云服务器内核升级之旅</title>
      <link href="2022/05/23/220523-%E4%B8%80%E6%AC%A1%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E4%B9%8B%E6%97%85/"/>
      <url>2022/05/23/220523-%E4%B8%80%E6%AC%A1%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%86%85%E6%A0%B8%E5%8D%87%E7%BA%A7%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p>  最近突发奇想，想尝试在本就不富裕的小云上搭建一个云手机平台。于是在github上不停的搜关键字（这里吐槽一下gitee的搜索功能做得还是太弱了），终于让我找到了两个不错的开源项目，<a class="link" href="https://github.com/anbox/anbox/blob/master/README.md">anbox<i class="fas fa-external-link-alt"></i></a>和<a class="link" href="https://github.com/remote-android/redroid-doc">redroid<i class="fas fa-external-link-alt"></i></a>。</p><p>  我们都知道Android是分层的，按语言可简单分为Java和Native，按类别可分为application和service，他们之间的通信几乎都是利用ashmem或binder完成。而这2个功能又需要内核支持。所以不管是那种容器（容器与主机共用同一个内核）方案，内核都需要支持ashmem和binder。遗憾的是我的小云运行的是CentOS7，内核是3.10。默认不开启ashmem和binder功能的。所以只有一条路可走，手动编译适合的内核（yum虽能安装高版本内核，但是不确认是否已开启这2个特性）。</p><span id="more"></span><p>  通过以下命令可确认是否支持ashmem和binder。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#check modules statuslsmod | grep -e ashmem_linux -e binder_linux# example output:# binder_linux          147456  79# ashmem_linux           16384  23# we can also check like thisgrep binder /proc/filesystems # output should like: nodevbindergrep ashmem /proc/misc # output should like: 56 ashmem<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>注：centos7 默认开启binder之后，/dev下可能也没有binder节点，可以通过手动mount的方式进行确认。</em></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo mkdir /dev/binderfssudo mount -t binder binder /dev/binderfs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h2><h3 id="内核下载"><a href="#内核下载" class="headerlink" title="内核下载"></a>内核下载</h3><p>  首先要挑选<strong>合适</strong>的内核版本下载，可以通过<a class="link" href="https://www.kernel.org/">kernel.org<i class="fas fa-external-link-alt"></i></a>官网或国内镜像（如：<a class="link" href="https://mirrors.aliyun.com/linux-kernel/">阿里云<i class="fas fa-external-link-alt"></i></a>）进行下载。</p><p>  内核版本并不是越高越好，经过血泪教训，建议一定选择长周期版本，防止内核抽风（之前用5.17.3，系统老是Panic重启，让人相当的崩溃）。</p><p>  内核源码可通过wget下载到本地某个目录下，然后用tar解压即可（属于基操就不多说了）。</p><h3 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h3><p>  Linux的内核有太多配置项需要配置，且大多数配置项可能都不知道是用来干嘛的（到底应该开还是不开？懵逼ing）。所以建议在配置前先将当前的内核配置文件拷贝过来，这样只需要根据需求做增量修改置即可。</p><p><em>当前使用的内核配置依据系统的不同可能在不同的地方</em></p><pre class="line-numbers language-none"><code class="language-none">/proc/config.gz/boot/config-$(uname -r)/usr/src/linux-$(uname -r)/.config/usr/src/linux/.config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  找到配置之后将其重命名为<kbd>.config</kbd>，并拷贝至内核源码目录下即可。因为是在云上操作，只能通过ssh登录字符界面，那么可通过<code>make menuconfig</code>打开一个字符图形界面来配置内核。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/05/09/watermarktype_ZmFuZ3poZW5naGVpdGkshadow_10text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzIxNjUsize_16color_FFFFFFt_70.png" alt="内核配置"></p><p><em>备注：上图只是一个示例，Android相关的配置在红框内可以找到。</em></p><p>  除了使用界面来配置内核，还有更简单的方式，即直接在.config文件中加入想要打开的配置项，比如开启Android相关的开关，可以添加如下内容：</p><pre class="line-numbers language-none"><code class="language-none">CONFIG_ASHMEM=yCONFIG_ANDROID=yCONFIG_ANDROID_BINDER_IPC=yCONFIG_ANDROID_BINDERFS=yCONFIG_ANDROID_BINDER_DEVICES="binder,hwbinder,vndbinder,binderfs"CONFIG_ANDROID_BINDER_IPC_SELFTEST=y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>详细的配置已放在<a class="link" href="https://gitee.com/ray0728/redroid-modules/raw/master/kernel/.config">Gitee<i class="fas fa-external-link-alt"></i></a></p><h3 id="内核编译-1"><a href="#内核编译-1" class="headerlink" title="内核编译"></a>内核编译</h3><p>  配置好之后，就可以在内核源码所在目录执行<kbd>make</kbd>，开始进行内核编译。这一步会生成内核模块和vmlinuz，initrd.img，Symtem.map等文件。</p><p><strong><font color="red">强烈建议：make时带上参数LOCALVERSION，以便于更好的区分内核。如：</font></strong></p><p><code>make LOCALVERSION=android</code></p><p>  网上有资料写还需要执行make modules什么的，其实完全不用。在不特点指定make对象的时候，make会自动编译完所有内容。</p><p>  编译成功后需将模块（ko文件）以及内核镜像等文件拷贝至系统目录。执行<kbd>make modules_install</kbd>和<kbd>make install</kbd>即可。</p><p>  <kbd>modules_install</kbd>会在<kbd>/lib/modules</kbd>目录下新建一个与本次编译内核同名的文件夹，并将编译生成的ko文件拷贝进来。</p><pre class="line-numbers language-none"><code class="language-none">[core@VM-16-15-centos modules]$ pwd/lib/modules[core@VM-16-15-centos modules]$ ls3.10.0-1160.62.1.el7.x86_64  5.4.190-android[core@VM-16-15-centos modules]$ ls 5.4.190-android/build              modules.builtin.bin      modules.orderkernel             modules.builtin.modinfo  modules.softdepmodules.alias      modules.dep              modules.symbolsmodules.alias.bin  modules.dep.bin          modules.symbols.binmodules.builtin    modules.devname          source[core@VM-16-15-centos modules]$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <kbd>install</kbd>则会将内核镜像文件拷贝至启动分区（/boot）。</p><p>  至此，内核编译与安装就完成了，不过此时重启系统并不会用新的内核进行引导，还需要修改引导顺序。</p><h3 id="内核切换"><a href="#内核切换" class="headerlink" title="内核切换"></a>内核切换</h3><p>  Linux内核一般通过GRUB进行引导，发展到今天GRUB已经很稳定了（很久以前装Linux和Windows双系统，稍不注意就把GRUB搞砸了），对于内核升级的场景也不用特别担心，按步骤修改即可。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">awk -F\' '$1=="menuentry " {print $2}' /etc/grub2.cfggrub2-set-default '$your_kernel_name_or_index'vim /etc/default/grubgrub2-mkconfig -o /boot/grub2/grub.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>获取当前内核列表（在上一步<kbd>make install</kbd>后，会刷新信息），列表是有序排列，最顶上序号为0，往下依次加1。请记住需要切换内核的序号以及名称。</li><li>配置默认内核信息，通过<kbd>grub2-set-default</kbd>进行设置，参数可以是名字也可以是序号。</li><li>修改配置文件（/etc/default/grub），刷新文件中默认引导内核的序号。</li></ol><pre class="line-numbers language-none"><code class="language-none">GRUB_TIMEOUT=5GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)"GRUB_DEFAULT=0GRUB_DISABLE_SUBMENU=trueGRUB_TERMINAL="serial console"GRUB_TERMINAL_OUTPUT="serial console"GRUB_CMDLINE_LINUX="crashkernel=auto console=ttyS0 console=tty0 panic=5 net.ifnames=0 biosdevname=0 intel_idle.max_cstate=1 intel_pstate=disable"GRUB_DISABLE_RECOVERY="true"GRUB_SERIAL_COMMAND="serial --speed=9600 --unit=0 --word=8 --parity=no --stop=1"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  关键是修改<font color="red">GRUB_DEFAULT=序号</font>。完成修改后就可以重新生成GRUB引导配置了。</p><ol start="4"><li>执行<kbd>grub2-mkconfig -o /boot/grub2/grub.cfg</kbd>即可根据新的培训信息生成并覆盖之前的文件了。</li></ol><p>  有时候编译出来的内核可能与预期不符，当然我们可以继续编译一个新的同版本的内核（使用不同的后缀），然后再切换至新内核上，但是如果当前正在使用的内核与废弃的内核是同一个版本，此时是不允许被删除的（意味着系统得一直带着这个废弃的内核），所以我们需要对内核做回滚。也正因为如此，所以在主机上<font color="red">最好保留一个原始的内核版本</font>，以便在需要时能实现<strong>回滚</strong>。</p><h3 id="内核删除"><a href="#内核删除" class="headerlink" title="内核删除"></a>内核删除</h3><p>  当新内核能满足我们的需要之后，就可以删除老旧的内核了。对于系统自带或通过包管理器安装的内核，可以通过命令（比如：apt或yum等）的方式直接删除。但是对于自己编译的内核就只能通过手动的方式进行删除操作了。</p><p><font color="red">删除前需确认该内核当前未在使用</font></p><ol><li>移出modules<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo rm -rf /lib/modules/&lt;you_want_remove_kernel&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>删除boot img<pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sudo rm -rf /boot/*&lt;key_word_in_your_kernel&gt;*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><p>  由于img文件在boot中会比较多，所以删除img文件，推荐使用通配符*，进行删除。</p><ol start="4"><li>重新生成grub.cfg</li></ol><p>  这一步并非必须，只不过不做的话，在启动菜单中会包含无效内核而已。</p><p>  另外如果删除内核后会影响内核排序，那么建议参考上文【内核切换】，在删除内核文件后，重新做一次引导信息刷新。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">grub2-mkconfig -o /boot/grub2/grub.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  从删除的方式可以看出移出自己编译的内核，其实就是从系统目录删除相应的文件即可。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次小游戏的开发尝试</title>
      <link href="2022/04/03/220403-%E4%B8%80%E6%AC%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E5%BC%80%E5%8F%91%E5%B0%9D%E8%AF%95/"/>
      <url>2022/04/03/220403-%E4%B8%80%E6%AC%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E7%9A%84%E5%BC%80%E5%8F%91%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>  谁能想到闲来无事做的零玩家游戏，居然成了组内浏览器性能测试工具？这是怎么回事呢？</p><p>  这事儿还得从我在github上瞎逛，发现了一个用JScript配合Canvas实现<a class="link" href="https://wiki.swarma.org/index.php/%E5%BA%B7%E5%A8%81%E7%9A%84%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F_Conway's_Game_of_Life">康威生命游戏<i class="fas fa-external-link-alt"></i></a>的<a class="link" href="https://github.com/anm/HTML5-Game-of-Life">网页小动画<i class="fas fa-external-link-alt"></i></a>说起。</p><p>  那个时候还不了解康威生命游戏是个什么鬼，第一次看见的时候只觉得这玩意儿有点神奇啊，居然能自主进化成不同的形态。加上被原作者一句“这玩意儿很容易添加别的动画规则”给引诱了。</p><blockquote><p>It would not be hard to add other rule sets so it can be used to run other automata. It’s my platform for learning and playing with some web technologies. </p></blockquote><p>  虽然前半句说不难添加新规则，但后半句中却提到了「learning」，果然他的代码风格一言难尽啊。</p><p>  肝了几天才把原始代码按逻辑重新进行了拆分和封装。在这过程中，也顺手尝试了好几种不同的动画效果，来看看历代的变化吧。</p><span id="more"></span><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h3 id="初代-康威生命游戏"><a href="#初代-康威生命游戏" class="headerlink" title="初代-康威生命游戏"></a>初代-康威生命游戏</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/03/04/Video_20220304_025701_510.gif" alt="初代_康威生命游戏"></p><p>  设置好初始图形（点、线）后，系统可以自动进行演进，无论初始图形是什么样的，最终得到的图形一定是固定的几种情况。</p><h3 id="一代-自绘画"><a href="#一代-自绘画" class="headerlink" title="一代-自绘画"></a>一代-自绘画</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/03/30/Video_20220330_081246_537.gif" alt="一代_自绘画"></p><p>  只需要绘制任意初始图形（点、线、面）初始图形颜色为红色，系统就可自行开始演进（方向随机）。演进过程中可以人为进行干预（使用白色），最终会得到相对稳定的色块图形。</p><h3 id="二代-碰撞"><a href="#二代-碰撞" class="headerlink" title="二代-碰撞"></a>二代-碰撞</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/03/30/Video_20220330_081457_44.gif" alt="二代_碰撞"></p><p>  每次会随机出现数量不等的小绿点，每个绿点向随机方向（上下左右）运行。若两个小点相撞，则会抵消其中的一个。在运行过程中，点击或滑动屏幕可再加入白色小点。白色小点运行规则与绿色小点完全一致。</p><h3 id="三代-病毒"><a href="#三代-病毒" class="headerlink" title="三代-病毒"></a>三代-病毒</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/03/30/Video_20220330_083336_511.gif" alt="三代_病毒"></p><p>  这是在上一代的基础上做的演进。每个小点代表一个细胞，用不同的颜色（绿色-健康细胞、黄色-已感染细胞、红色-携带病毒细胞、白色-免疫细胞）代表不同的状态。并且增加了更复杂的相遇规则：</p><ul><li>红色一定能将绿色转换为黄色</li><li>黄色有一定率将绿色转换为黄色</li><li>黄色运行14步之后，较大几率转换为红色</li><li>白色可将红色变为黄色</li><li>白色可将黄色变为绿色</li><li>每个小点会保持向一个方向运行10步，之后随机改变方向</li></ul><p>  每次运行前会随机生产数量不定的红色小点（已感染）与绿色小点（健康）。因为红色具有较高几率的转换能力（高传染性），因此能很快发现绿色小点被快速变为黄色，即便他们初始位置间隔很远。此时可通过点击屏幕或滑动屏幕，向游戏中加入白色免疫细胞。但是由于运行方向的不确定性，在白细胞数量没达到临界值之前，基本上无法挽回细胞由绿转红的趋势。实测，白细胞需要数倍于病毒细胞的数量才可平衡病毒的传染。</p><p>所以这个游戏也告诉我们<font color="red">疫情期间，做好防护，不要瞎聚集</font>。</p><h3 id="战争"><a href="#战争" class="headerlink" title="战争"></a>战争</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/03/19/Video_20220319_085648_768.gif" alt="四代_战争"></p><p>  在上一个病毒版本基础上继续修改规则，最终变成类似地图战争的游戏，当然规则也发生了变化。</p><p>  运行前可在屏幕上绘制任意图形（点、线、面），点击运行后。系统会根据图形像素点的个数按比例在地图随机放置若干不同的军事单位，不同的军事单位权重不一样，从小到大分别是：</p><blockquote><p>机动部队（MO）&lt;  坦克部队（TK）&lt; 空军部队（AF）&lt;  基地（BS）  </p></blockquote><p>  而最开始所绘制的图形，会给每个点自动标记上不一样的颜色（每个颜色代表一个国家）。</p><p>  每个色块都会向四周随机扩张，若扩张的方向是空白区域，则可占领该区域。</p><p>  如果某色块占领的空白区域刚好有一个军事单位，那么这个军事单位就变为这个色块所拥有，此时它就可以去攻击别的色块了（战争爆发）。</p><p>  战争双方均有军事单位时，则会依据攻击发起方的权重，以一定的比例判定攻击是否成功。如果攻击成功则占领该色块，并获取一定的战利品（军事单位升级），若攻击失败则军事单位降级。</p><h2 id="动画原理"><a href="#动画原理" class="headerlink" title="动画原理"></a>动画原理</h2><p>  定义一个N x M的视图区域（view），并且对应一个N x M 的二维数组（data)。如果该二维数组的某一个元素有值，则在对应的视图区域绘制一个小点，当数组中有值的元素发生变化，视图区域也会随之变化，从而表现为动画效果。</p><h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>  定义一个二维数组，用于保存原始数据。原始数据可以是数字，也可以是HashMap，根据需要进行设计即可。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Grid</span><span class="token punctuation">(</span><span class="token parameter">width<span class="token punctuation">,</span> height</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span>width<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">||</span>        <span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token function">Number</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>            <span class="token string">"Grid constructor requires two numerical dimensions"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>width  <span class="token operator">=</span> width<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>length <span class="token operator">=</span> width<span class="token punctuation">;</span>    <span class="token keyword">let</span> x<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">&lt;</span> width<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>  利用canvas在可视范围内绘制 N x M 大小的矩形，该矩形由N x M个小方块组成。N 与 M 根据屏幕可视区域动态计算。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">autoConfigSize</span> <span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">divid</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> divid <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>divid <span class="token operator">=</span> divid<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>divid<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>offsetLeft<span class="token punctuation">;</span>    <span class="token keyword">let</span> top  <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>divid<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>offsetTop<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>width <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">width</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>left <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>height <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">height</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>top <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span><span class="token function">setSize</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>width<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  这样在移动设备上运行的时候，可以自适应不同的屏幕大小，也可以自适应横竖屏变化。</p><p>  绘制的时候根据设计的原始数据格式转换一下，即可绘制。因为表现为色块，所以关键信息为该色块当前应为什么颜色。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">drawCell</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> d      <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>draw<span class="token punctuation">;</span>    <span class="token keyword">let</span> offset <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>cellSize <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>borderWidth<span class="token punctuation">;</span>    <span class="token keyword">let</span> px <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>borderWidth <span class="token operator">+</span> x <span class="token operator">*</span> offset<span class="token punctuation">;</span>    <span class="token keyword">let</span> py <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>borderWidth <span class="token operator">+</span> y <span class="token operator">*</span> offset<span class="token punctuation">;</span>    <span class="token keyword">let</span> grade <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span><span class="token function">cell</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        d<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span><span class="token function">cell</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">'color'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        grade <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span><span class="token function">cell</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token string">"grade"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        d<span class="token punctuation">.</span>fillStyle <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>color<span class="token punctuation">.</span>all<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>color<span class="token punctuation">.</span>background<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    d<span class="token punctuation">.</span><span class="token function">fillRect</span><span class="token punctuation">(</span>px<span class="token punctuation">,</span> py<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>cellSize<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>cellSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>gradDraw <span class="token operator">!=</span> <span class="token keyword">undefined</span> <span class="token operator">&amp;&amp;</span> grade <span class="token operator">!=</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">gradDraw</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> px<span class="token punctuation">,</span> py<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>cellSize<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span>cellSize<span class="token punctuation">,</span> grade<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>  封装setInterval，实现一个简单的定时器，通过定时回调实现界面的自动刷新。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Clock</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> period</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>func <span class="token operator">=</span> func<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>period <span class="token operator">=</span> period<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">setPeriod</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">period</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>period <span class="token operator">=</span> period<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">start</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>func<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>period<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">stop</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">clearTimeout</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  界面刷新使用统一的接口nextGeneration实现，在这里就可以自定义的任意规则。接口只需要对N x M 的二维数组更新就可以了。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>  从原理上可以看出，如果视图区域（view）比较大，那么对应的数组大小、上色的区域都比较大，加上代码并为针对不同的浏览器做优化，导致在不同的浏览器上显示效果不一样。最明显的就是Ubuntu下的FireFox 和 Chrome。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/03/26/performce.gif" alt="performce.gif"></p><p>  移动端上的表现也各有不同，看来前端开发确实挺难的呢。</p><p>源码已在<a class="link" href="https://gitee.com/ray0728/Pixel-Wars">Gitee<i class="fas fa-external-link-alt"></i></a>上开源。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JQuery </tag>
            
            <tag> BootStrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring极简资源服务器</title>
      <link href="2022/03/19/220319-Spring_resource_server/"/>
      <url>2022/03/19/220319-Spring_resource_server/</url>
      
        <content type="html"><![CDATA[<p><font color="red">-本文为填坑文-</font></p><p>　　很早之前我在<a class="link" href="https://www.ray0728.cn/2021/10/27/gatway%E4%BD%BF%E7%94%A8Security%E9%80%82%E9%85%8DKeycloak/">《Spring cloud gatway适配Keycloak》<i class="fas fa-external-link-alt"></i></a>中给自己留了一个坑。</p><blockquote><p>可以看出token中已包含有用户相关信息，可进一步传递给下游，作为权限判断输入，符合上文中的预期。好了，用户登录有了，剩下的就是在资源服务器（即下游微服务）上实现权限验证了。</p><p>  后面再单独写一章吧，因为资源服务器的实现略有不同。</p></blockquote><p>　　其实能鉴权的资源服务器很早就实现了，不过因为最近在愉快的玩儿其他有意思的东东，没能顾上填坑，正好最近天气不错，那就把它填了吧。</p><p>　　先来看看效果。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/03/16/Video_20220316_082232_316.gif"></p><span id="more"></span><p>　　在用户未登录的情况下，点击任意链接（根据Gateway配置判断是否需要登录访问）都会跳转至Keycloak以完成SSO流程，这一点在之前的文章中已经有过介绍。</p><p>　　但是对于微服务框架（功能尽可能解耦）来讲，Gateway最好只作为用户的访问入口（将访问跳转至服务提供者）或特殊时段的流量分流器（比如灰度版本上线时）。而用户是否有权限访问/使用某一具体服务，应该由对应的该服务提供者来判断，Gateway路由时将相关的信息（如token）完整传递下去就好，这里的服务提供者就是资源服务器。</p><h2 id="服务权限限定"><a href="#服务权限限定" class="headerlink" title="服务权限限定"></a>服务权限限定</h2><ul><li>POM依赖配置<br>　　既然资源服务器要对访问的用户进行鉴权，那么需要首先给暴露的端点加上权限限定，这在Spring框架里倒是挺简单，只需要在POM中加入<strong>spring-boot-starter-oauth2-resource</strong>即可。</li></ul><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-oauth2-resource-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>　　<em>它会自动引用Security相关依赖，因此不用再单独引入。</em></p><ul><li>权限配置<br>　　有了resource-server依赖之后，就可以对端点进行权限（访问）定义了。</li></ul><p>　　resource-server默认使用<strong>WebSecurityConfigurerAdapter</strong>作为其安全配置器，其初始状态为：所有端点均需要登录后才能访问，换句话表述即为所有端点一视同仁。但是这并不是我们想要的效果（通常来讲，不同端点有不同的访问权限限制才是较常见的情况）。因此我们需要继承<strong>WebSecurityConfigurerAdapter</strong>，并重写里面的 <strong>protected void configure(HttpSecurity)</strong> 方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void configure(HttpSecurity http) throws Exception{        http.authorizeRequests(authz -&gt; authz                .antMatchers(HttpMethod.GET, "/testing/").permitAll()                .antMatchers(HttpMethod.GET, "/testing/auth/**").hasRole(role_auth)                .antMatchers(HttpMethod.GET, "/testing/vip/**").hasRole(role_vip)                .antMatchers(HttpMethod.GET, "/testing/admin/**").hasRole(role_admin)                .anyRequest().authenticated())                .oauth2ResourceServer().jwt().jwtAuthenticationConverter(new JwtAuthenticationConverter());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　代码很简单，将所有需要控制的端点按各自访问需求配置即可。又因为KeyCloak返回的是jwt格式token，所以配完权限设定后，我们告诉资源服务器使用JWT进行token解析。</p><p>　　按道理讲这样配置后就可以正常工作了，但是实际是无法完成校验的（所有访问均无法通过）。</p><h2 id="Token解析"><a href="#Token解析" class="headerlink" title="Token解析"></a>Token解析</h2><p>　　我们将KeyCloak返回的token解码后会发现一些有意思的事儿。因为我的鉴权是基于role的，因此将token里面与role相关的字段筛选出来，如下：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">{  ……  "realm_access": {    "roles": [      "offline_access",      "admin",      ……    ]  },  "resource_access": {    "realm-management": {      "roles": [        "view-realm",        "view-identity-providers",        "manage-identity-providers",        "impersonation",        "realm-admin",        "create-client",         ……      ]    },    "account": {      "roles": [        "manage-account",        "manage-account-links",        "view-profile"      ]    }  },  "scope": "profile email",  ……  "roles": [    "ROLE_offline_access",    "ROLE_vip",    "ROLE_user",    ……  ],  ……}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　可以看出token中有好几个与role相关的字段，彼此之间还都有差别，我们依次解读一下。</p><ol><li><strong>realm_access.roles</strong> 用户具有的外部自定义权限，即提供给资源服务器鉴权用的。</li><li><strong>resource_access</strong> 用户具有的内部权限，主要是指访问KeyCloak子功能的权限。<br>　　- <strong>realm-management.roles</strong> 管理当前realm的权限（如：创建、删除、查看等）<br>　　- <strong>account.roles</strong> 对当前账户的管理权限（如：查看、更改等）</li><li><strong>roles</strong> 所有已分配的角色描述</li></ol><p><strong>备注：2与3 是可以一一对应上的</strong></p><p>　　token中角色信息基本上就这些了，有用的的都有了，不怎么有用的也在token当中。回头再看看Spring Security是怎么取的这些信息呢？</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/03/18/u36094707951319161906fm253fmtautoapp138fJPEGw500h378.jpg"></p><p>　　经过一系列的定位，跟读代码，我发现Spring读取的信息是token中的scope字段（别问怎么跟的，也别问具体是那个文件，因为过去太久了，我也忘记了），而scope字段的值是profile email。所以默认情况下永远也无法校验通过（当然也可以把角色名改成profile email →_→）。</p><h2 id="Token适配"><a href="#Token适配" class="headerlink" title="Token适配"></a>Token适配</h2><p>　　怎么解决这个问题呢？至少有两种办法值得尝试。</p><p>　　- 修改KeyCloak产生的Token，使其适配Spring解析规则。</p><p>　　- 修改Spring解析方式，适应KeyCloak。</p><h3 id="KeyCloak映射"><a href="#KeyCloak映射" class="headerlink" title="KeyCloak映射"></a>KeyCloak映射</h3><p>　　KeyCloak提供了丰富而强大的映射功能，在上文解析token内容时所发现的ROLE_信息即通过映射的方式将自定义的角色信息映射到token自定义字段当中的。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/03/18/Screenshot_20220318_195502.jpg"></p><p>　　然而就算有如此强大丰富的映射功能，我们也不能将realm.roles信息映射到scope中，并不是无法配置这样的映射规则，而是配置之后在校验时会有很多莫名其妙的问题。</p><p><font color="red">如果有好心人知道如何正确配置，也请不吝赐教</font></p><h3 id="自定义解析器"><a href="#自定义解析器" class="headerlink" title="自定义解析器"></a>自定义解析器</h3><p>　　之前我们跟踪Spring Security会发现在使用JWT解析器的时候，实际的转换是通过<strong>JwtGrantedAuthoritiesConverter</strong> 中的<strong>covert</strong>完成。解析方法到也不复杂，简单来说就是读取jwt token的scpe字段。要解决这个问题就得用我们自己covert去替换默认的。</p><p>　　幸运的是Spring Security开放了相关接口。只需要用自定义的解析方法替换即可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected void configure(HttpSecurity http) throws Exception{        JwtAuthenticationConverter converter = new JwtAuthenticationConverter();        converter.setJwtGrantedAuthoritiesConverter(new Converter&lt;Jwt, Collection&lt;GrantedAuthority&gt;&gt;() {            @Override            public Collection&lt;GrantedAuthority&gt; convert(Jwt source) {                JSONArray roles = (JSONArray) ((JSONObject) (source.getClaims().get("realm_access"))).get("roles");//                JSONArray scopes = (JSONArray) ((JSONObject) (source.getClaims().get("resource_access"))).get("roles");                ArrayList&lt;GrantedAuthority&gt; roleArray = new ArrayList&lt;&gt;();                for(int i = 0; i &lt; roles.size(); i++){                    roleArray.add(new Role(roles.get(i)));                }                return roleArray;            }        });        http.authorizeRequests(authz -&gt; authz                .antMatchers(HttpMethod.GET, "/testing/").permitAll()                .antMatchers(HttpMethod.GET, "/testing/auth/**").hasRole(role_auth)                .antMatchers(HttpMethod.GET, "/testing/vip/**").hasRole(role_vip)                .antMatchers(HttpMethod.GET, "/testing/admin/**").hasRole(role_admin)                .anyRequest().authenticated())                .oauth2ResourceServer().jwt().jwtAuthenticationConverter(converter);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　因为covert需返回GrantedAuthority格式的队列，因此自定义了一个子类Role。这个子类只做一件事，给role加上ROLE_前缀。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Role implements Serializable, GrantedAuthority {    private String authority;    public Role(Object role){        authority = "ROLE_" + (String) role;    }    @Override    public String getAuthority() {        return authority;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　为什么还需要一个自定义Role呢？Token中不是带有已加有前缀的字段了吗？因为在实际部署生产环境的时候，我们更倾向只对一端进行修改，而不是两端同时修改，这也是出于减少依赖，方便日后替换另一端考虑。</p><p>　　至此，一个适配KeyColaK，支持鉴权的资源服务器就算做好了。</p><p><font color="red">本文内容在Spring boot 2.5.5版本上验证通过</font></p><p>源码 <a class="link" href="https://gitee.com/ray0728/resource">Gitee<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> KeyCloak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Python的相片导入工具</title>
      <link href="2022/02/25/220225-python_photo_importer/"/>
      <url>2022/02/25/220225-python_photo_importer/</url>
      
        <content type="html"><![CDATA[<p>  最近没顾上继续折腾 Spring Cloud，而是和 Python 相爱相杀。唉，一开始还小瞧了小小的 Python，没想到还真费了我不少劲呢，前前后后差不多搞了快 2 周，做出来的东西才稍微像那么回事。</p><span id="more"></span><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>  最近我的小手机老是提示存储空间不足，有时候连拍照都提示失败。以前也遇到过这样的情况，作为一名老司机，一般会找几个不怎么用的 APP 删掉，这样就可以腾出空间了，可最近这招似乎不太灵了。是的，就是下面这种情况。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/20/9e31678cgy1fwkt1owfvuj20xc0s0429.jpg" alt="9e31678cgy1fwkt1owfvuj20xc0s0429.jpg"></p><p>  后来仔细检查了一遍发现原来是相册太大了，整整有 80 多个 G。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/22/Screenshot_20220222_082328_com.huawei.systemmanager_edit_68467352572885.jpg" alt="dcim"></p><p>　　唉，至从有了高像素摄像头之后，越来越多的照片舍不得删掉呀。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/20/OIP-C.jpg"></p><p>  可现在没办法了，既然舍不得删掉，那就导出到电脑上吧。首先上场的是我的主力台式老爷机（拥有一颗二代i3处理器），搭载优秀的 Linux 操作系统（不需要到处找激活码），使用网上比较流行的 shotwell 进行照片导入，界面差不多就像下面这样。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/20/import.png" alt="import.png"></p><p>　　shotwell 会自动按照片创建的时间导入到指定目录下。只要能「连上手机」，操作也是相当的简单，不过要想连上手机似乎就有点困难了，比如会出现这样的错误提示。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/23/2022-02-23-22-48-35-.png" alt="error"></p><p>　　既然不能直接从设备导入照片，那就换个角度，从文件夹里导入就好了嘛，不成想自己还是太单纯了。经过漫长的等待后又再次弹框。</p><p>（此处假装有图片）</p><p>　　唉，行。可能是我的小手机不配高冷的 Linux 呢，那我换个接地气的 Windows 试试看呢？拿出尘封多年的笔记本，连上小手机，选择照片导入。看着熟悉的文件拷贝窗口，不禁感叹到，还是 Windows 懂生活啊。</p><p>　　哎？哎！怎么又报错了！看来大厂的软件也不咋滴嘛。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/22/v2-c039a1ddc57a55115a539df75ca06b69_b_edit_69941486574223.png" alt="出错"></p><p>　　究竟是手机的矫情，还是电脑的假正经，我是没想明白的，总之他俩就是合不到一块儿。</p><p>　　不就是文件拷贝吗？咋这么难呢？实在不行那就自己动手咯。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/22/u23320009453737923227fm253fmtautoapp138fJPEGw500h309.jpg" alt="动手"></p><h2 id="自己动手，丰衣足食"><a href="#自己动手，丰衣足食" class="headerlink" title="自己动手，丰衣足食"></a>自己动手，丰衣足食</h2><p>　　老规矩，先看最终效果图，觉得效果还凑合，咱再接着慢慢聊（毕竟后面的废话还挺多）。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/20/2022-02-20-22-52-36-.png" alt="2022-02-20-22-52-36-.png"></p><p>　　这是一个运行在终端上的 Python 脚本，为什么选 Python？因为我觉得小小的照片导入功能，不就是递归拷贝吗？Python 足矣！</p><h3 id="初代方案"><a href="#初代方案" class="headerlink" title="初代方案"></a>初代方案</h3><p>　　方案其实挺简单的，按如下步骤执行即可实现照片导入。</p><ol><li>递归遍历指定目录。</li><li>若遍历到的是文件且是指定文件类型则获取其 MD5 值，否则跳过该文件。</li><li>在数据库中查找刚刚获取的 MD5 值，若能找到则跳过，继续执行第二步。</li><li>不能找到说明这是一个新文件，那么获取其元数据（分辨率、地理信息等）</li><li>将文件拷贝至指定目录</li><li>将元数据和 MD5 值一起保存进数据库</li><li>重复执行第二步，直到遍历结束。</li></ol><p>　　上面看上去步骤挺多，实际代码写出来很少，而且很简单。遍历用<code>os.walk()</code>即可。</p><p>　　嗯？图片元数据怎么获取？这也不难，利用 PIL 库即可获取到照片的各种元数据。不过在获取的时候可能出现意外情况，比如图片不包含元数据（可能是被清掉了，也可能是图片本身就没有），遇到这种情况就得从文件属性里面获取其它有用信息了（如：文件创建时间）。相关代码请看这里：</p><pre class="line-numbers language-none"><code class="language-none">from support.utils.file.base import MediaFilefrom PIL import Imagefrom PIL.ExifTags import TAGSfrom support.ui.console import Log        class Picture(MediaFile):    KB = 1024    KEY_WIDTH = ['ImageWidth','ExifImageWidth']    KEY_HEIGHT = ['ImageLength','ExifImageHeight']    KEY_GPS = 'GPSInfo'    KEY_DATE = 'DateTimeOriginal'    WIDTH = 'Width'    HEIGHT = 'Height'    DATE = 'Date'    LOAC = 'Local'    HASH = 'Hash'    def __calcDMS(self, value):        return value if len(value)==1 else value[0]/value[1]    def __transDMS(self, value):        if('2' not in value.keys()):            return ""        latitudinal = self.__calcDMS(value[2][0]) + self.__calcDMS(value[2][1])/60.0 + self.__calcDMS(value[2][2]) /3600.0        longitude = self.__calcDMS(value[4][0]) + self.__calcDMS(value[4][1])/60.0 + self.__calcDMS(value[4][2]) /3600.0        return "{},{}".format(longitude if value[3].upper() == 'E' else -longitude, latitudinal if value[1].upper() == 'N' else -latitudinal)                def __hasTag(self, filtermap, key):        if(filtermap is None):            return True        for filter in filtermap:            if(isinstance(filter, str) and key == filter):                return True            if(isinstance(filter, list) and key in filter):                return True        return False            def __transKey(self, key):        if(key == self.KEY_DATE):            return self.DATE        if(key == self.KEY_GPS):            return self.LOAC        if(key in self.KEY_HEIGHT):            return self.HEIGHT        if(key in self.KEY_WIDTH):            return self.WIDTH        return key            def getMetaData(self, path, filtermap=None):        metaData = {}        metaData[self.HASH] = self.calHash(path)        if(self.isVideo(path)):            metaData[self.DATE] = self.getCreateDate(path)        else:            try:                file = Image.open(path)                info = file._getexif()                if(info):                    for (tag, value) in info.items():                        key = TAGS.get(tag,tag)                        if(self.__hasTag(filtermap, key)):                            metaData[self.__transKey(key)] = self.__transDMS(value) if(key == self.KEY_GPS) else value            except Exception as e:                Log.e(__file__, type(e), str(e))            finally:                if(self.DATE not in  metaData.keys()):                    metaData[self.DATE] = self.getCreateDate(path)        return metaData    def getData(self, meta, key, default=""):        if(key not in meta.keys()):            return default        return meta[key]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>备注：元数据并不是照片导入的必要信息，只不过我在最开始做的时候，还没想好照片因以什么规则进行自动归类，是按日期？还是按地理信息？</em></p><p>　　从最初的方案里面可以看出相片的拷贝依赖主线程一个文件一个文件的处理。如果只有少量的数据这样玩儿问题不大，可我有 80 多 G 的照片呀！一个一个拷贝，得到天荒地老吗？</p><p>　　这方案完全就是在玩儿我呀！<strong>不行，得优化！</strong></p><h3 id="二代方案"><a href="#二代方案" class="headerlink" title="二代方案"></a>二代方案</h3><p>　　既然一个一个文件处理太慢了，那就并行处理呗，咱上多线程。</p><p>　　线程是个好东西，执行效率提升很明显，但是线程的创建是会消耗系统资源的，总量80G的小文件，每个文件都创建一个线程，呵呵～</p><p>　　我们在提高效率的时候，也得注意系统资源的占用情况，所以采用线程池来管理。好在 Python 已经有非常成熟的线程池方案了，直接使用即可。方案如下：</p><ol><li><font color="red"><strong>[new]</strong></font>初始化指定大小的线程池</li><li>递归遍历指定目录。</li><li>若遍历到的是文件且是指定文件类型则获取其 MD5 值，否则跳过该文件。</li><li>在数据库中查找刚刚获取的 MD5 值，若能找到则跳过，继续执行第二步。</li><li>不能找到说明这是一个新文件，那么获取其元数据（分辨率、地理信息等）</li><li><font color="red"><strong>[new]</strong></font> 从线程池中分配一个线程执行文件拷贝动作</li><li>如果当前执行队列中的线程数量已达到阈值，则等待至少 1 个线程完成拷贝动作后再继续执行</li><li>将元数据和 MD5 值一起保存进数据库</li><li>重复执行第二步，直到遍历结束。</li><li><font color="red"><strong>[new]</strong></font>遍历结束后，等待执行队列中所有线程执行完成。<pre class="line-numbers language-none"><code class="language-none">self.threadPool = ThreadPoolExecutor(maxqueue)self._lock = RLock()self.dashboard = dashboardself.idleQueue = []self.runningQueue = []<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>　　这里设计 2 个队列来保存任务，<strong>是有优化空间的</strong>。</li></ol><p>　　最初的想法是主线程先将任务 push 进空闲队列，当空闲队列中待执行任务数量达到阈值后再去线程池中取线程逐一执行，并将分配的线程 push 进执行队列。<strong>防止主线程不停的向线程池要线程，导致线程池创建线程总数远远超过期望数量</strong>。</p><p>　　而当执行队列中线程数达到 2 倍阈值就强行等待线程执行完毕，期望通过这种方式让线程池中的线程尽可能利用起来。</p><p>　　可是这个设计<font color="red"><strong>存在不可修改的缺陷</strong></font>，首先线程执行完之后是直接回到线程池中的，我所设计的执行队列无法感知到这个变动，那么就会出现某线程实际已处于空闲状态，可是仍然在执行队列当中。其次线程真正开始执行需要等待空闲队列中的任务数量达到阈值，那么在未到达阈值这个时间段内，其实线程未被合理利用，同时由于队列的限制，在实际运行时会出现一批一批的执行，而不是滚动执行。</p><p>　　所以后面就优化成先执行，后判断是否需要等待线程空闲的模式。但是代码上仍然留有之前方案的痕迹（其实就是自己懒得改了）。</p><pre class="line-numbers language-none"><code class="language-none">def execJobs(self, force=False):        self._lock.acquire()        for task in self.idleQueue:            self.runningQueue.append(self.threadPool.submit(task['func'], task['args']))        self.idleQueue.clear()        while(len(self.runningQueue) &gt;= self.maxqueue):            Log.i(Task.TAG, "waiting for all running thread completed", len(self.runningQueue))            for thread in as_completed(self.runningQueue):                self.runningQueue.remove(thread)                break        if(force):            for thread in as_completed(self.runningQueue):                Log.i(Task.TAG, thread)            self.runningQueue.clear()        self._lock.release()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　现在线程有了，执行速度也提上去了，用小手机试试，发现也能正常拷贝完 80 多 G 的照片了，并且能将照片单独保存在以日期命名的各个文件夹当中。</p><p>　　如果事情到这就及时截止，一切都那么美好。可是做完后，我突发奇想，如果能有一个进度条来指示拷贝进展就好了，于是我就掉进了一个大坑当中。</p><h3 id="Rich"><a href="#Rich" class="headerlink" title="Rich"></a>Rich</h3><blockquote><p>  <a class="link" href="https://github.com/Textualize/rich">Rich<i class="fas fa-external-link-alt"></i></a> 是一个 Python 库，可以为您在终端中提供富文本和精美格式。<br><br>  <a class="link" href="https://rich.readthedocs.io/en/latest/">Rich API<i class="fas fa-external-link-alt"></i></a> 可以很容易的在终端输出添加各种颜色和不同风格。Rich 还可以绘制漂亮的表格，进度条，markdown，突出显示语法的源代码及回溯等等，不胜枚举。</p></blockquote><h2 id="上述均转自-Rich-的-readme-文件，不可否认效果确实挺漂亮的，而且封装非常好。就是文档太少了。国内的相关文档要么把人家的-readme-拷贝一次，要么就是同一篇文章抄来抄去。唉，也许这也是国内技术博客的现状吧。"><a href="#上述均转自-Rich-的-readme-文件，不可否认效果确实挺漂亮的，而且封装非常好。就是文档太少了。国内的相关文档要么把人家的-readme-拷贝一次，要么就是同一篇文章抄来抄去。唉，也许这也是国内技术博客的现状吧。" class="headerlink" title="　　上述均转自 Rich 的 readme 文件，不可否认效果确实挺漂亮的，而且封装非常好。就是文档太少了。国内的相关文档要么把人家的 readme 拷贝一次，要么就是同一篇文章抄来抄去。唉，也许这也是国内技术博客的现状吧。"></a>　　上述均转自 Rich 的 readme 文件，不可否认效果确实挺漂亮的，而且封装非常好。就是文档太少了。国内的相关文档要么把人家的 readme 拷贝一次，要么就是同一篇文章抄来抄去。唉，也许这也是国内技术博客的现状吧。</h2><p>　　<font color="red">下文为 rich 踩坑实录。均为个人理解，若与Rich官方文档冲突，以官方为主</font></p><h3 id="layout"><a href="#layout" class="headerlink" title="layout"></a>layout</h3><p>　　既然用上了 rich，我当然希望能更好的使用它强大的显示特性，我不仅仅想要有进度条，还想有状态、日志等相关信息展示。所以这里就需要用到 layout 功能，将屏幕进行分割。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/25/60995284905417873.jpg" alt="我全要"></p><p>　　layout 的 API 其实挺简单的，将屏幕按行分割或按列分割，分割之后的每一个区域又可以再按行或列分割。同时可以指定分割后的区域大小，占比等信息。比如我就是这样分割整块屏幕的。</p><pre class="line-numbers language-none"><code class="language-none">layout = Layout(name="root")layout.split(    Layout(name="header", size=3),    Layout(name="main", ratio=1),    Layout(name="copyright", size=9),)layout["main"].split_row(    Layout(name="info", ratio=2),    Layout(name="progress", ratio=1))layout["progress"].split(     Layout(name="overall", size=3),     Layout(name="jobs", ratio=1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/25/bc8baf0e91de6357605f95758fd3a829.png" alt="layout"></p><p>　　分割好之后就需要向各个区域填充想要显示的控件。rich 支持多种填充控件，我这里主要用到了进度条（progress）、文本显示（panel）。</p><h3 id="进度条-Progress"><a href="#进度条-Progress" class="headerlink" title="进度条 Progress"></a>进度条 Progress</h3><h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><p>　　首先需要给 progress 定义显示样式。Rich 封装了几种常用的样式，按需组合即可。在初始化 progress 时即可指定样式：</p><pre class="line-numbers language-none"><code class="language-none">self.overallProgress = SmartProgress(TextColumn("[progress.description]{task.description}"), CountColumn(), BarColumn(), TextColumn("[progress.percentage]{task.percentage:&gt;3.0f}%"))self.jobsProgress = SmartProgress(TextColumn("{task.description}", justify="left"),"|",DownloadColumn(),BarColumn(bar_width=None),"|",TextColumn("[progress.percentage]{task.percentage:&gt;3.0f}%"),"|",TimeRemainingColumn())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>　　这里的 SmartProgress 是我二次封装的 progress，但是初始化函数与 Progress 是一致的，参数乍看上去挺复杂的。但是拆解一下就一目了然了。</p><p>　　以第一个 overallProgress 为例。它的参数分别是<code>TextColumn(), CountColumn(), BarColumn(), TextColumn()</code>。这些参数共同构成了 overallProgress 的显示样式，其排列的顺序就是最终显示的顺序。显示的效果即：</p><p><code>文本 计数器 进度条 文本</code></p><p>　　而前后两个文本到底显示什么呢？我们继续拆解参数。</p><p>　　第一个 TextColumn 参数为<code>"[progress.description]{task.description}"</code>，它表示会显示 progeess 的 description 属性，同时也显示自定义属性 task.description 的内容，内容排序以参数中定义的顺序排列。</p><p>　　第二个 TextColumn 参数为<code>"[progress.percentage]{task.percentage:&gt;3.0f}%"</code>，它表示显示 progress 的 percentage 属性，同时显示自定义 task.percentage 并在最后加上百分号。</p><p>　　这样回头再看 overallProgress 的显示样式会是这样的：</p><p><code>进度描述 计数器 进度条 当前百分比</code></p><p>　　而第二个 jobsProgress 经过拆解后也能得知其显示样式为：</p><p><code>任务描述 | 下载计数 | 进度条 | 进度百分比 | 预计剩余时间</code></p><h4 id="列"><a href="#列" class="headerlink" title="列"></a>列</h4><p>　　列是 progress 中的术语，多个 progress 在一起的时候，会 Rich 会保持其列对齐。因此列只需要关注自己的显示内容即可。在 progress 参数中出现的 CountColumn 同样是二次封装的列，其代码如下：</p><pre class="line-numbers language-none"><code class="language-none">from rich.progress import BarColumn, DownloadColumn, Progress, TextColumn, TimeRemainingColumn, ProgressColumnfrom typing import Optionalfrom rich.text import Text, TextTypefrom rich.table import Columnclass CountColumn(ProgressColumn):    def __init__(        self, binary_units: bool = False, table_column: Optional[Column] = None    ) -&gt; None:        self.binary_units = binary_units        super().__init__(table_column=table_column)    def render(self, task: "Task") -&gt; Text:        if(task.total is None):            count_status = f"{task.completed}/?"        else:            total = int(task.total)            count_status = f"{task.completed}/{total}"        count_text = Text(count_status, style="progress.download")        return count_text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　可以看出列最主要的作用就是返回此时应该显示什么内容。</p><h4 id="进度条控制"><a href="#进度条控制" class="headerlink" title="进度条控制"></a>进度条控制</h4><p>　　在上文提到多进度条的时候 Rich 会保证其列对齐。可是我们似乎只初始化了 2 个进度条呢，是指他两列对齐吗？当然不是。先来了解 一下Progress 提供的 API ，然后就明白了。</p><p>　　Progress并不是看到的某一个具体的进度条，而是某一类（相同样式）的集合。通过<code>add_task</code>的方式可以在其中添加任意条实际会显示的progress。该方法每调用一次就会返回一个taskID，之后可以通过ID操作某一个具体的进度条。</p><p>　　Progress可操作的内容均和其显示的内容有关，常用的如：</p><ul><li>description 进度条的描述信息</li><li>total 进度条总长（默认100）</li><li>completed（当前已完成长度）</li><li>advance（类似追加的概念，每次设置后会在当前completed的基础上再追加advance，并重新设置completed）</li><li>自定义属性</li></ul><p>　　除上述内容外，还可以获取当前所有的task，遍历每一个task状态等。详细的可参考Rich的源码progress.py。</p><h3 id="文本显示-panel"><a href="#文本显示-panel" class="headerlink" title="文本显示 panel"></a>文本显示 panel</h3><p>　　Panel很特殊，它更像是一个“容器”，将另一个控件包裹起来，通常里面会放入Table.grid(网格控件)或上文提到的Progress。下面是一个放入网格的例子：</p><pre class="line-numbers language-none"><code class="language-none">class CopyrightPanel:    def __init__(self, title="[ Copyright ]", style="bright_blue"):        self.title = title        self.style = style    def __rich__(self) -&gt; Panel:        sponsor_message = Table.grid(padding=1)        sponsor_message.add_column(style="green", justify="right")        sponsor_message.add_column(justify="left")        sponsor_message.add_row(            "Gitee",            "[u blue link=https://gitee.com/ray0728/multimedia-file-synchronizer/tree/release-mfs]https://gitee.com/ray0728/multimedia-file-synchronizer/tree/release-mfs",        )        sponsor_message.add_row(            "Blog",            "[u blue link=https://www.ray0728.cn/]https://www.ray0728.cn/",        )        sponsor_message.add_row(            "Email",            "[u blue link=mailto://51101661@qq.com]51101661@qq.com",        )        intro_message = Text.from_markup("""\Please provide more comments and bugs! or buy me a coffee to say good job.- RayThe UI is developed based on the [bold magenta]Rich[/] component.[u blue link=https://github.com/sponsors/willmcgugan]https://github.com/sponsors/willmcgugan[/]""")        message = Table.grid(expand=True)        message.add_column()        message.add_column()        message.add_row(intro_message, sponsor_message)        message_panel = Panel(            message,            title=self.title,            border_style=self.style,        )        return message_panel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>　　这是封装过的panel，提供静态的copyright信息。</p><h3 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h3><p>　　准备好progress和panel之后就可以向layout装载这些东西了。</p><pre class="line-numbers language-none"><code class="language-none">self.logRedirect = LogPanel()# Log.logRedirect = NullDev()Log.logRedirect = self.logRedirectlayout["info"].update(self.logRedirect)layout["copyright"].update(CopyrightPanel())layout["header"].update(ClockPanel(title, "white on blue"))layout["overall"].update(Panel(self.overallProgress, title="Overall Progress", border_style="orange4"))layout["jobs"].update(Panel(self.jobsProgress, title="[ Jobs Progress ]", border_style="green"))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="刷新-Live"><a href="#刷新-Live" class="headerlink" title="刷新 Live"></a>刷新 Live</h3><p>　　Rich使用Live来实现控件刷新的，比如progress，上文装载的多个控件都可以通过Live的方式实现控件的定时刷新。</p><h4 id="Live刷新的本质"><a href="#Live刷新的本质" class="headerlink" title="Live刷新的本质"></a>Live刷新的本质</h4><p>　　Live刷新是通过根控件，逐一查找其子控件，并根据子控件当前数据以及状态重绘子控件来实现界面刷新。</p><p>　　这个方法被封装在Live的update当中。当Live启动定时线程后，由定时线程去调用update方法。</p><p>　　因为Rich最终是在stdout或自定义file中输出。如果存在多个Live同时刷新界面，那么输出一定是乱序的，所以Rich不允许同时启动多个Live。</p><p>　　实测发现在不同操作系统上Rich表现不一样，Linux上的表现比在Windows上更丰富，且平滑。</p><h4 id="Live手动刷新"><a href="#Live手动刷新" class="headerlink" title="Live手动刷新"></a>Live手动刷新</h4><p>　　回到我的相片拷贝业务上来，文件的遍历一定是主线程该干的事儿，文件拷贝是子线程干的事儿，界面刷新则是Live干的事儿。界面主要显示内容应该是拷贝的进度。</p><p>　　因为Live与各拷贝子线程之间并无联系，因此拷贝进度无法通知到Live，并实时刷新界面显示。但如果让拷贝子线程有能力通知并触发Live刷新了，这就又与Live的定时刷新机制相冲突。</p><p>　　幸运的是Live提供了不开启定时刷新的开关，因此不用侵入式修改Rich源码，只需要将Live的相关动作封装一下，就可以在不使用定时刷新线程的情况下，手动刷新界面了。</p><pre class="line-numbers language-none"><code class="language-none">def show(self):    self.live = Live(self.layout, refresh_per_second=1, screen=True, auto_refresh=False)    #self.live = Live(self.layout, refresh_per_second=4, screen=True)    self.live.start(True)def update(self):    self._lock.acquire()    if(self.live is not None):        self.live.update(self.layout)    self._lock.release()def hiden(self):    if(self.live is not None):        self.live.stop()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="何时刷新"><a href="#何时刷新" class="headerlink" title="何时刷新"></a>何时刷新</h4><p>　　一般来说可以在任意时候调用，不过为了让调用更优雅，我将刷新调用逻辑封装在了线程task.py当中，简单来说子线程在必要的时候可回调Live刷新接口。</p><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/02/20/record.gif" alt="record.gif"></p><p>　　虽然看上去还行，但是代码还是有些小毛病，比如刷新不够平滑，进度条有时候会有跳变，如果有好心人发现了bug，也非常欢迎提交修改合入。</p><p>相关源码已在<a class="link" href="https://gitee.com/ray0728/multimedia-file-synchronizer/tree/release-mfs">Gitee<i class="fas fa-external-link-alt"></i></a>开源</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云上编译器 随时随地编代码</title>
      <link href="2022/01/29/220129-%E4%BA%91%E4%B8%8A%E7%BC%96%E8%AF%91%E5%99%A8/"/>
      <url>2022/01/29/220129-%E4%BA%91%E4%B8%8A%E7%BC%96%E8%AF%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>  在<a class="link" href="https://www.ray0728.cn/2022/01/13/SpringCloudConfig/">《Spring Cloud配置服务》<i class="fas fa-external-link-alt"></i></a>中提到本人在小云上瞎折腾，奈何学艺不精，折腾得挺费劲的，为了让折腾变得轻松点，上线了配置服务一事。其实除了折腾配置参数之外，代码的修改也是不可避免的事儿（虽然常常只是增删一句代码）。比如跨域访问资源的时候会被CSRF拦截，为了验证功能，就不得不加上<code>.csrf().disable()</code>试试效果。为了能进一步让我的折腾之路走得更从容，我开始寻找轻量化、免费的CI环境。</p><p>  大约是几年前的时候吧，那时候用Github做代码仓库，就顺手白嫖了Travis CI的资源，他的用法很简单，在代码中加入.travis.yml配置文件（可参考<a class="link" href="https://gitee.com/ray0728/authserver/blob/master/.travis.yml">这个<i class="fas fa-external-link-alt"></i></a>），这个文件作用是告诉Travis CI需要做什么，然后在Travis CI控制面板中添加Github账户公钥即可。当代码提交到Github代码仓库的master分支以后，会被自动编译成jar包，然后打包进容器，并进一步自动发布到 Docker hub上，而云端只需要更新容器即可实现部署（注1：其实Travis CI可以再调用云端接口，实现真正全自动部署，只不过当时购买的菊厂弹性服务器并未开放相关接口。注2：其实也有办法，Travis CI 推送完DockerHub之后，向Github指定仓库再提交一个issue，利用Github的WebHook向云端发起POST请求，从而触发Docker更新，只不过这条路也太折腾了。）<br>。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/01/26/u17511744642555063419fm26fmtauto.jpg" alt="travis ci"></p><span id="more"></span><h2 id="对标"><a href="#对标" class="headerlink" title="对标"></a>对标</h2><p>  现在小站长的代码仓库早已切换到Gitee， Travis CI又不支持小小的Gitee，没办法只好寻找替代品，不过好在可以以它作为标定。</p><p>  能提供类似功能的产品很多，不过要么收费，要么太重载，比如Gitee Go再比如Jenkins。并不是说他们不够好，只不过不太适合我的应用场景罢了。</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ol><li>能随时快速启动，结束后不常驻系统（毕竟小云资源有限）。</li><li>能编译Spring Cloud工程，并打包为docker （不用发布到DockerHub，因为已经在云上了，直接运行即可）。</li><li>不影响主机环境配置，保持主机稳定运行。</li></ol><h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>  好消息是Spring Boot现在支持直接编译为Docker了，可参考<a class="link" href="https://blog.csdn.net/duysh/article/details/106823211">《SpringBoot 构建 Docker 镜像的 3 种方式》<i class="fas fa-external-link-alt"></i></a>，但是他们都无法满足第三点需求，因为它们至少需要在主机搭好maven环境。那么maven环境会影响主机运行吗？我想可能性很低，但如果主机运行的不是常见系统，那么可能得费很大的劲来搭建了。不幸的是在下的小云就是这样的系统—<a class="link" href="https://baike.baidu.com/item/CoreOS/9843813">CoreOS<i class="fas fa-external-link-alt"></i></a>，一个已停止更新并被收购的系统。🤣</p><p>  要保持主机稳定，不能更改主机运行环境，我的主机上现在有什么呢？有docker、有git、有nginx，其他的啥都没有了。看来得利用已有的工具完成代码编译和容器打包呢。既然最终输出物为docker image，那么得在docker上找找突破口。</p><h2 id="Docker-多阶段构建"><a href="#Docker-多阶段构建" class="headerlink" title="Docker 多阶段构建"></a>Docker 多阶段构建</h2><p>  Docker 17.05之后原生支持多阶段构建，什么是多阶段构建呢？请点<a class="link" href="https://www.jianshu.com/p/410b0c5129b0">这里<i class="fas fa-external-link-alt"></i></a>。简单来说就是可以将docker build按需要划分为多个阶段，并控制各阶段的输入输出。那么我们可以将编译作为构建第一阶段，最终打包成镜像则作为第二阶段。因此我的Dockerfile可以这样写：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">FROM registry.cn-hangzhou.aliyuncs.com/acs/maven:3-jdk-8 AS build-envLABEL stage=tmp-buildENV MY_HOME=/appRUN mkdir -p $MY_HOMEWORKDIR $MY_HOMEADD pom.xml $MY_HOMERUN ["/usr/local/bin/mvn-entrypoint.sh", "mvn", "validate", "clean", "--fail-never"]ADD . $MY_HOMERUN ["/usr/local/bin/mvn-entrypoint.sh", "mvn", "verify", "-Dmaven.test.skip=true"]FROM openjdk:8-jre-alpineCOPY --from=build-env /app/target/*.jar /app.jarADD run.sh run.shRUN chmod a+x run.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  第一阶段为名为build-env的编译阶段，它的目标是编译输出最终的jar包，因此这个阶段不用考虑docker镜像大小以及层级（反正都是中间产物）。即便如此，这个阶段也挺有意思的，首先选取带JDK的maven镜像，然后先加pom文件，并依据pom拉取需要的库文件。然后再加源码工程进行编译。这一阶段应该有可进一步提速的空间，不过就这样吧。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/26/fe14691e308e8353c137350a4ade9397.jpg" alt="又不是不能用"></p><p>  第二阶段则是为了输出最终的image，因此选取了相对较小的alpine镜像。同时为了减少层级并提高可阅读性，我将容器执行入口封装进run.sh脚本(为了调试方便，并未添加自动执行，实际应用的时候用docker-compose指定run.sh即可）。</p><p>  准备好Dockerfile之后，将其与Spring Cloud工程放在一起随代码更新即可。使用的时候执行<code>docker build -t &lt;imagename&gt; .</code>就行了。正常情况下可以看到这样的效果：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/01/29/Video_20220129_115028_493.gif" alt="编译"></p><h3 id="附加效果"><a href="#附加效果" class="headerlink" title="附加效果"></a>附加效果</h3><p>  想想看在大家聚在一起喜气洋洋过年的时候，你默默的拿出手机，看似随意的点几下然后就轻轻的放在桌上，转身和大家云淡风轻的聊着家长里短。而屏幕上哗哗不停的显示，一定会引起所有人的好奇，最终会有人问你这是在干嘛，这个时候你一定要控制好情绪和声调，慢慢的说：“哦，这不美国佬的小飞机掉水里了嘛，今天刚好有空，我帮国家找一下”。是不是完成了一次完美装逼？正所谓无形装逼最为致命。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/01/29/u41202252121185342323fm253fmtautoapp120fJPEGw430h342.jpg" alt="装逼"></p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>  多阶段构建确实很方便，合理利用能很好满足我的小需求，不过多阶段构建会产生的中间产物并不会自动删除，通过<code>docker images -a</code>可以看到有很多标记为none的image，不过也不用惊慌，执行一条shell命令即可批量删除：</p><p><code>docker rmi $(docker images -a | grep none | awk '{print $3}')</code></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>  因为有云，很多以前做不到的事现在能做了。因为有云，资源利用率可以更高了。因为有云，便携设备的作用以及边界被扩展了。因为有云，各种想象正在逐渐变为现实。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/01/29/IMG_20220129_123920.md.jpg" alt="云"></p>]]></content>
      
      
      <categories>
          
          <category> 云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud配置服务</title>
      <link href="2022/01/13/220113-SpringCloudConfig/"/>
      <url>2022/01/13/220113-SpringCloudConfig/</url>
      
        <content type="html"><![CDATA[<p>  这一段时间都在小云上折腾微服务的事儿，一边愉快的加着新功能，一边苦逼的调试着参数。也许这就是痛并快乐着吧。所幸Spring  Cloud是一款优秀的服务框架。</p><blockquote><p>它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p></blockquote><p>  最大的特点就是代码与配置相互独立，开箱即用（写入极少代码），通过更改配置就可以调整功能细节，我这么努力吹Spring Cloud，社区不考虑请我吃饭吗？哈哈哈哈</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/01/04/16655322702792683390.gif" alt="恰饭饭"></p><span id="more"></span><p>  虽然有如此优秀的框架，奈何本人学艺不精，技不如人，即便只加了极少的功能，也只能一遍又一遍的在云上不断的修改配置进行调试（为啥不在本地调好再上云呢？因为我买云就是为了随时随地想怎么玩就怎么玩呀😏）。可是为了验证一处小修改就重新编译一次，似乎又太重载了。一开始还只是一个微服务需要修改配置验证，觉得忍一忍也就算了，后来发展到需要多个微服务配合修改才能验证一个功能，就实在受不了了，于是乎决定上线<strong>配置服务器</strong>，一劳永逸的解决这个痛点。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/01/04/srchttp3A2F2Fgd2.alicdn.com2Fimgextra2Fi22F15855076372FT2kid7X2VXXXXXXXXX_21211585507637.gifreferhttp3A2F2Fgd2.alicdn.gif" alt="yahoo"></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>  上述场景就是配置服务一个典型应用场景。通常软件开发的时候，首先会制作一个通用版本，以满足大部分场景使用，而落地到实际生产环境上又会有不同的配置参数（如：用户名、密码、超时时间等），这就促使开发人员将配置文件与功能逻辑相互独立保存（也就是常说的不要在代码中有硬编码行为）。</p><p>  配置服务就是一个配置文件管理服务，通过Rest接口对外提供<strong>配置查询功能</strong>，并且支持<strong>多种存储方式（如本地文件、Git仓库等）</strong>。基于Spring Cloud有很多优秀的配置服务，如：Spring Config、Spring Consul、携程Apollo、蚂蚁金服disconf 等，因此给大伙的可选项还是挺多的。</p><h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><p>  Spring Cloud Config的历史挺长，也算是Could框架中最早的几个成员之一，虽然现在更新较慢（似乎很长时间未更新了），不过其提供的服务已能满足我这样小白用户的需求。其秉承Spring Boot的优良传统，同样支持开箱即用。</p><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>  既然Spring Cloud Config服务是基于Spring Boot的REST应用程序，因此我们可以将Spring Cloud配置服务嵌入在其它Spring Boot当中，当然也可以完全新建一个独立的Spring Cloud Config服务。</p><p>  创建方式很简单，只需要在POM中引入<kbd>spring-cloud-config-server</kbd>即可。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-config-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  在入口函数中添加上Spring Cloud注解（<code>@EnableConfigServer</code>），即告诉Spring Cloud启动配置服务。</p><p>  此时程序就拥有了提供配置服务的能力，不过还需要做更多的配置，以便告诉服务需要如何运行。相对来说从一个文件目录中检索配置信息是最简单的运行模式，而这个目录可以是本地目录，也可以是网络映射目录。</p><h3 id="基于文件系统管理"><a href="#基于文件系统管理" class="headerlink" title="基于文件系统管理"></a>基于文件系统管理</h3><p>  基于文件系统管理的配置服务，只需要告诉Spring Cloud Config在哪个或哪几个目录搜索配置文件即可，在配置文件中添加如下信息：<br><code>spring.cloud.config.server.native.searchLocations: file:///mnt/config-repo/ms-gateway</code></p><p>  file后面的路径需为服务可直接访问的目录，若需要多个则可用<strong>半角逗号（,）</strong>进行分隔。这句配置的意思是Spring Cloud Config服务以Native方式运行（文件系统），且在以下路径中（<code>file:///mnt/config-repo/ms-gateway</code>）匹配配置文件。</p><ul><li><strong>优点</strong></li></ul><p>  基于文件系统的配置服务操作简单，不需要提供额外的服务即可支持。</p><ul><li><strong>不足</strong></li></ul><p>  配置文件更新维护成本较高，这里的成本并不是指对配置文件本身的验证成本，而是文件系统维护的成本，如：如何确保文件系统的容错性（误删、误改等）。</p><h3 id="基于Git管理"><a href="#基于Git管理" class="headerlink" title="基于Git管理"></a>基于Git管理</h3><p>  针对文件系统的不足，业内早就有各种解决方案，比如版本管理工具（如Git以及 SVN等）。而Spring Cloud Config就可以支持Git仓库。</p><ul><li><strong>优势</strong></li></ul><p>  对于文本类型的配置文件来说引入Git优势就太多了，可以跟踪修改记录、可以标记tag、可以分支管理、可以回退更改等等。而这一切带来的结果就是维护成本降低了。</p><ul><li><strong>不足</strong></li></ul><p>  非要说有啥不足，可能是需要git仓库以及懂得基本的git操作吧，否则还真没发现有啥不足的，有钱的站长可以自建gitlab私有仓库，像我这样没钱又爱瞎折腾的则可以选择github或者gitee做仓库。</p><p>  同样除了在POM中指定Config依赖之外，还需要在配置文件中添加以下内容：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">spring.cloud.config.server.git.uri=$GIT_SERVER_URI spring.cloud.config.server.git.username=$GIT_USERNAME spring.cloud.config.server.git.password=$GIT_PASSWORD spring.cloud.config.server.git.search-paths=$GIT_SEARCH_PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  相较于基于文件系统的配置，基于Git的则多了用户名、密码以及Git地址的信息。而<code>spring.cloud.config.server.git.search-paths</code>和之前的一样，用逗号区分多个目录。</p><h3 id="配置查询"><a href="#配置查询" class="headerlink" title="配置查询"></a>配置查询</h3><p>  上文说过Spring Cloud Config是基于 Rest的应用程序，那么使用方式当然绕不开 Get/Post。可通过Get的方式从配置服务中查询某个配置文件内容，目前支持以下访问格式。</p><blockquote><ol><li>/{name}-{profiles}.properties</li><li>/{name}/{profiles}/{label:.}</li><li>/{name}/{profiles:.[^-].}</li><li>/{name}/{profiles}/{label:.}</li><li>/{label}/{name}-{profiles}.properties</li><li>/{name}-{profiles}.json</li><li>/{label}/{name}-{profiles}.json</li><li>/{label}/{name}-{profiles}.yaml</li><li>/{label}/{name}-{profiles}.yml</li><li>/{name}/{profiles:.[^-].}</li><li>/{name}-{profiles}.yaml</li><li>/{name}-{profiles}.yml</li></ol></blockquote><p>  假设我们的配置服务器地址为<a href="https://localhost:8080，那么可以通过浏览器访问https://localhost:8080/ms-discovery/prod获取服务名为ms-discovery的配置信息。">https://localhost:8080，那么可以通过浏览器访问https://localhost:8080/ms-discovery/prod获取服务名为ms-discovery的配置信息。</a></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/01/11/Screenshot_20220111_084820.jpg" alt="example"></p><p>  也可以直接访问文件名，如：<a class="link" href="https://localhost:8080/ms-discovery-prod.yml">https://localhost:8080/ms-discovery-prod.yml<i class="fas fa-external-link-alt"></i></a></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/01/11/Screenshot_20220111_090449_com.huawei.browser_edit_404169521696659.jpg" alt="example"></p><p>  二者的区别在于是否返回文件的Git信息，在第一种方案当中能看到多了label、version等内容，其中version对应 Git commit id。</p><p>  上述查询的是prod属性配置文件，如果我们还有一个dev文件，则可以通过访问<a class="link" href="https://localhost:8080/ms-discovery/dev%E6%88%96https://localhost:8080/ms-discovery-dev.yml%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E3%80%82%E6%AD%A4%E5%A4%84%E7%9A%84">https://localhost:8080/ms-discovery/dev或https://localhost:8080/ms-discovery-dev.yml进行查询。此处的<i class="fas fa-external-link-alt"></i></a> <em>prod</em> 以及 <em>dev</em> 对应配置文件的<strong>profiles</strong>。</p><p>  服务端的配置差不多就这样了吧，现在再来看看客户端的配置。</p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>  和服务端一样首先在POM中加入配置服务的依赖。</p><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;   &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;   &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  其次在配置文件中指明配置服务器的相关信息。同样以服务名为ms-discovery的程序为例，其配置如下：</p><pre class="line-numbers language-none"><code class="language-none">spring:  application:    name: ms-discovery  config:    import: optional:configserver:${server.config.uri}  cloud:    config:      name: ${spring.application.name}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  配置信息告诉应用程序三件事儿，第一件<strong>我是谁？</strong>、第二件<strong>配置在哪里？</strong>、第三件<strong>配置文件叫什么？</strong>，这里我将配置服务器地址以变量的方式传入（确保即便服务器地址发生变化，程序依然可访问到正确的地址）。其实除了配置服务器地址是通过变量传递的，程序运行时还有其他参数也是通过变量控制。完整运行命令如下：</p><pre class="line-numbers language-none"><code class="language-none">java $JAVA_OPTIONS \     -Dserver.tomcat.max-threads=$MAX_THREADS \     -Dserver.config.uri=$CONFIG_URI \     -Dspring.profiles.active=$PROFILE \     -Dserver.port=$PORT \     -Ddiscovery.server=$DISCOVERY_HOST \     -Dtrace=$DEBUG \     -jar /app.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  其中<code>$JAVA_OPTIONS</code>与<code>$MAX_THREADS</code>均为优化选项，用于调整程序运行时性能参数（以后有机会再做介绍）。而<code>$PROFILE</code>与<code>$CONFIG_URI</code>则是指明配置文件属性和服务器地址信息。在<strong>配置查询</strong>章节，我们已了解如何通过profiles参数去读取不同的配置内容。</p><p>  正如本文开篇所述，在折腾微服务的时候常常需要调整配置信息以适配新加的功能特性，而已经走到这里的我们具备了配置和代码分离管理的能力，修改配置后只需要重启微服务即可让配置生效。</p><p>  但是所谓“因为我懒，所以我要改变世界”，有没有什么办法不重启服务也让配置生效呢？那就得聊一聊配置刷新了。</p><h3 id="配置刷新"><a href="#配置刷新" class="headerlink" title="配置刷新"></a>配置刷新</h3><p>  Spring Cloud Config通过添加注解<code>@RefreshScope</code>的方式，让应用的变量支持热更新（即通过访问应用的/refresh端点触发应用再次读取配置）。关于配置刷新网上有很多有深度且专业的代码解读，这里就不重复了。不过关于配置刷新我有另一种观点，在容器化流行的今天，也许重启一次容器会比热刷新配置效果更好。如本小站的每一个服务均运行在独立的Docker环境中，配合Docker-compose编排工具进行管理，如果有需要更新某个应用的配置，只需要执行<code>docker-compose restart xxxx</code>即可，既简单又高效。所以特性并没有谁更厉害，只有适合才是最重要的。</p><h2 id="敏感信息保护"><a href="#敏感信息保护" class="headerlink" title="敏感信息保护"></a>敏感信息保护</h2><p>  在应用服务使用过程中不可避免会用到账号、密码这类敏感信息，如果放在配置文件中交给配置服务统一管理，又会担心信息的泄露（比如服务被攻击或者git仓库被破解），为了降低此类问题发生时带来的风险， Spring Cloud Config提供了一个重要的功能，即信息加密。</p><h3 id="加-解密"><a href="#加-解密" class="headerlink" title="加/解密"></a>加/解密</h3><p>  我们在配置文件中以密文的形式写下敏感信息，并告诉配置服务这是密文请解密后使用。密文格式为<code>{cipher}密文</code>。</p><p><strong>准备</strong></p><p>  首先需要将执行环境中的JCE策略文件替换为无限制版本。</p><blockquote><ol><li><strong>什么是JCE？</strong><br><br>JCE全称：Java Cryptography Extension，<br>默认的内置JCE策略文件是一个受限版本，主要体现在加/解密的长度受限。因此我们需要用官网上下载的非受限版本替换本地的对应文件。<br></li><li><strong>为什么受限？</strong><br><br>这不是美国佬的祖传操作吗？什么技术无国界，都是骗鬼的<br></li><li><strong>怎么替换？</strong><br><br>下载好之后替换至<code>/usr/lib/jvm/default-jvm/jre/lib/security/policy/unlimited</code>（实际目录以系统为准）即可。</li></ol></blockquote><p>  然后配置一个只有你知道的密码，并将密码保存在执行机的环境变量当中。</p><p><code>export ENCRYPT_KEY=这里是切勿泄露的密码哟</code></p><p>  请按照执行机实际运行的系统设置环境变量。以环境变量执行的好处在于不用硬编码，特别是在以docker方式运行时，可随时变更密码。</p><p><strong>加密</strong></p><p>  将明文以<code>text/plain</code>类型，POST到<code>/encrypt</code>端点即可。得到的返回值就是密文。</p><p>  即便是同一个明文，每次加密的结果都是不同的。这样可以有效防止彩虹表攻击。</p><p><strong>解密</strong></p><p>  将密文以<code>text/plain</code>类型，POST到<code>/decrypt</code>端点即可。得到的返回值就是明文。</p><p>  本来可以通过postman体验的，不过我都折腾到这个份上了，那就整一个web界面呗，随时随地想玩就玩(快乐有时候就这么简单)。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/01/13/Screenshot_20220113_095848_com.huawei.browser.jpg" alt="example"></p><p>  配置好之后再次通过配置服务访问配置文件就能看到密文被自动解密了。不过问题也来了，有时候我们并不想将解密后的明文就这样暴露在Rest接口返回值当中。那么我们可以告诉服务端，不要在服务端解密。而是由相关的应用程序自己对加密内容解密。</p><h3 id="禁止解密"><a href="#禁止解密" class="headerlink" title="禁止解密"></a>禁止解密</h3><p>  在配置文件中设置<code>spring.cloud.config.server.encrypt.enabled: false</code>即可禁止服务端解密。同时在应用程序的执行环境中同样加入密码的环境变量。此时我们在访问配置查询端点，会发现密文未被解密。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2022/01/13/Screenshot_20220113_152551_com.huawei.browser_edit_499234655078507.jpg" alt="decrypt"></p><p>  这样网络传输的时候就不用担心信息泄露了。</p><p>  有了web界面固然用着很爽，但是万一被好心人访问到这个端点，岂不是所有密文都可以被破解了？看来还是得做一个鉴权呢。</p><h2 id="资源服务器-权限管控"><a href="#资源服务器-权限管控" class="headerlink" title="资源服务器-权限管控"></a>资源服务器-权限管控</h2><p>  本文一开篇就提到Spring Cloud Config可加入任何Spring Cloud应用程序当中，那么自然也可以作为 Resource Server的一个功能组件。要使用Resource Server需要在 POM中加入相关依赖。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-oauth2-resource-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  其次添加相应的权限要求信息，以便在访问到相应端点的时候，能被filter拦截并做出对应的判断。文本不打算介绍 Resource Server，留在以后单独分享吧。</p><h2 id="番外篇-基于数据库的配置管理"><a href="#番外篇-基于数据库的配置管理" class="headerlink" title="番外篇-基于数据库的配置管理"></a>番外篇-基于数据库的配置管理</h2><p>  Spring拥有很棒的数据库操作能力，我们通过<code>@Entity</code>以及<code>@Repository</code>等注解可以很方便的生成Spring Data。而Spring Data提供了基本的数据库CRUD能力。</p><p>  如果我们将配置信息保存在数据库当中，并且利用Spring Data和JPA框架，即可实现配置信息自动从数据库中读取并导入至应用程序当中，从而实现基于数据库的配置管理。</p><p>  这样做有一个小问题，无法原生支持/refresh的配置刷新。不过在某些场景下，此方案也许也有用武之地吧。</p><p>本文涉及的源码在<a class="link" href="https://gitee.com/ray0728/ms-config">Gitee<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不一样的服务发现Eureka</title>
      <link href="2021/12/13/211213-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84Eureka/"/>
      <url>2021/12/13/211213-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84Eureka/</url>
      
        <content type="html"><![CDATA[<p>  在<a class="link" href="https://www.ray0728.cn/2021/11/07/%E6%9C%89%E4%BA%86%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88/">《有了云服务器能干什么》<i class="fas fa-external-link-alt"></i></a>一文中曾讲到从小小云有限的资源中扒拉了一小块来折腾微服务，在连肝数日之后，终于有了基本的微服务雏形（有SSO、有权限控制、有跨服务器资源访问）。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/12/08/SVID_20211208_084320_1.gif" alt="demo"></p><p>  接下来会用一个系列来记录微服务折腾的过程。本文主要记录服务发现Eureka的折腾之路。</p><span id="more"></span><h2 id="不一样的Eureka"><a href="#不一样的Eureka" class="headerlink" title="不一样的Eureka"></a>不一样的Eureka</h2><p>  关于Eureka 的用法网上早已有海量的文章可查阅，所以这里不再赘叙。但是作为资源有限的小云使用，本就不可能运行太多的服务（硬件天花板限制），所以需要调整Eureka Server的配置方案，使其更符合个人小云使用。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/12/10/u26025630372476872673fm26fmtauto-1_edit_254572754679905.jpg" alt="we_are_different"></p><h3 id="更改配置让刷新更快"><a href="#更改配置让刷新更快" class="headerlink" title="更改配置让刷新更快"></a>更改配置让刷新更快</h3><p>  我们都知道Eureka默认开启了自保护模式，这个模式很好很强大，就像王者荣耀一样，确实很好玩，可要是没日没夜撸太多，就变成亡者农药了，所以<strong>适度</strong>、<strong>适合</strong>才是最重要的。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/12/11/7164534473854260540.jpg" alt="适度游戏"></p><h4 id="关闭自我保护模式"><a href="#关闭自我保护模式" class="headerlink" title="关闭自我保护模式"></a>关闭自我保护模式</h4><p>  作为一个单纯的私人小云，个人觉得没有必要使用Eureka自我保护模式。为什么这么说呢？从其所适合的场景就可以看出。</p><blockquote><p>当Eureka Server节点在短时间内丢失客户端心跳超过门限后，会进入自我保护模式。在该模式下Eureka Server会保持当前客户端的注册信息，即便在未收到客户端续订心跳的时候也不会移出该客户端，以防止因网络故障而非客户端故障引起的误删除事件发生。</p></blockquote><p>  将上述内容通过简单的例子转换一下，某天小R发现通过微信联系不上女神的时候，那么大概率是对方将小R移出了好友或已读不回（<strong>收不到续订心跳</strong>），如果此时小R够理智的话接下来要做的事应该是默默的从微信中删除女神的账号（<strong>删除无效客户端</strong>），并通过朋友圈向所有好友宣布已与女神再无关系（<strong>刷新缓存，更新客户端列表</strong>），然后等待新的女神向小R发送好友申请（<strong>新的客户端注册</strong>）。但要是某天小R发现大部分人都不能通过微信联系的时候（<strong>失联的客户端超过门限</strong>），就得考虑是不是自己的微信出问题了(<strong>网络问题或其他非客户端问题</strong>)，而不是把联系不上的好友都删除（<strong>自我保护，等待故障恢复</strong>）。</p><p>  而我们小小云上运行的微服务数量基数小，一两个微服务出现异常就很容易超过Eureka自我保护的门限值，而此时更合理的处理方式是快速移出无效客户端信息，防止将流量引向已故障的服务上（<em>快速反馈502错误，减轻网关压力</em>），没必要进入自我保护模式等待故障恢复。</p><p>  关闭自保护模式：<kbd>eureka.server.enable-self-preservation=false</kbd></p><h4 id="快速更新"><a href="#快速更新" class="headerlink" title="快速更新"></a>快速更新</h4><p>  快速更新是指Eureka Server所维持的客户端信息快速更新，即当有客户端下线时，Eureka Server能立即更新客户端信息表。</p><p>  那么首先得及时判断客户端是否下线，Eureka Server通过<kbd>eureka.server.renewal-threshold-update-interval-ms</kbd>来控制以什么样的频率去检测所有已注册客户端的心跳。该选项默认为15分钟，不过考虑到本人学艺不精，技不如人做出来的客户端质量拉胯，所以越早发现，才能越早治疗（手动重启），这里我修改为2分钟检测一次。</p><p>  发现有异常客户端之后，就得抓紧将异常的客户端移出。而Eureka Server是通过<kbd>eureka.server.eviction-interval-timer-in-ms</kbd>控制以什么样的频率去移出已失效的客户端。该选项默认为60秒。当然和上面一样，我希望能更快完成无效客户端的移出动作，所以我修改为5秒。</p><p>  Eureka Server内部有自己的数据缓存策略，这里不展开细讲。为了更快完成客户端列表的刷新，我们通过禁用ReadOnlyCache缓存来实现。<kbd>eureka.server.use-read-only-response-cache: false</kbd></p><p>  服务端这样配置差不多就可以做到快速更新了，可是光服务端快是不行的，客户端也得跟上才行。而客户端最需要做的是“<strong>常联系，快退出</strong>”。</p><p>  “常联系”是要客户端加快与服务端发送心跳的间隔，两次心跳间隔时间越长，服务端的反应就越慢，理论上从客户端出现问题到客户端信息被移出，最长时间就是心跳间隔时间。如果心跳间隔为10分钟，那么该客户端最长需要10分钟（此处实际还需加上服务端的检测间隔时间）后才会被移出。</p><p>  “快退出”则是指客户端出现“失联”后，要让服务端快速、果断的移出该客户端，而不是磨磨蹭蹭拖半天。控制这一切的是由两个选项完成的。</p><p><kbd>eureka.instance.lease-renewal-interval-in-seconds</kbd></p><p><kbd>eureka.instance.lease-expiration-duration-in-seconds</kbd>。</p><p>以下是完整配置yml</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">eureka:   server:     enable-self-preservation: false    renewal-threshold-update-interval-ms: 120000     eviction-interval-timer-in-ms: 5000     use-read-only-response-cache: false  instance:     lease-expiration-duration-in-seconds: 10     lease-renewal-interval-in-seconds: 5   client:     fetch-registry: true    register-with-eureka: true    service-url: defaultZone: ${discovery.server}/eureka<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="自定义页面直达关键信息"><a href="#自定义页面直达关键信息" class="headerlink" title="自定义页面直达关键信息"></a>自定义页面直达关键信息</h3><p>  Eureka Server自带了一个web查看页面，可通过该页面查看当前服务端的状态以及注册客户端的状态。原生页面的功能很好用，只是不太适合我的小云而已（毕竟有些功能我都不会用到，自然也就不关注了）。</p><p>  对于小云上运行的微服务，我更关注的是各个注册的客户端状态是否正常、Eureka状态是否正常（小云资源有限，稍不留神就OOM Kill了）。所以需要自定义Eureka的页面，做到<strong>打开链接，直达关键信息</strong>。</p><p>  关于Eureka自定义页面网上相关教程也挺多的，这里就不重复了。简单来讲，首先将<kbd>spring-cloud-netflix-eureka-server</kbd>包中templates.erueka目录拷贝至工程resources下，然后按需修改对应的4个ftlh文件即可。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/12/09/Screenshot_20211209_152448.jpg" alt="ui"></p><h3 id="关于Docker环境下需注意事项"><a href="#关于Docker环境下需注意事项" class="headerlink" title="关于Docker环境下需注意事项"></a>关于Docker环境下需注意事项</h3><p>  当客户端向Eureka Server注册的时候，Eureka会在30秒内连续3次检测客户端的状态（健康检测），之后才会将该客户端信息刷新至客户端列表当中。而在Docker执行环境下，通常使用编排工具（如Docker-compose）将所有服务一起启动，虽然服务均已运行，但是仍有可能收到404错误（需等待30秒后再访问）。</p><p>  客户端向Eureka Server注册时默认使用主机名进行注册，但是当该客户端在Docker中运行时，使用的主机名其实为Docker Container ID。如果是跨服务器访问则无法通过其查找到真正的客户端（DNS不知道注册使用的Docker Container ID所对应的IP地址），而如果仅使用<kbd>preferIpAddress</kbd>选项，虽然可用IP地址替换主机名完成注册，但不幸的是，所使用的IP为Docker Container IP，而非跨服务器所能访问的地址（一般需公网IP地址），所以依然不可被别的服务器使用。因此还需加上<kbd>eureka.instance.ip-address</kbd>，通过手动指定IP地址的方式，让客户端可达，这在后续记录中也会提到。</p><p>本文涉及源码地址<a class="link" href="https://gitee.com/ray0728/beta-discovery/">Gitee<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有了云服务器可以做什么</title>
      <link href="2021/11/07/211107-%E6%9C%89%E4%BA%86%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88/"/>
      <url>2021/11/07/211107-%E6%9C%89%E4%BA%86%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>  从19年开始使用华为云（4核8G）到20年使用阿里云（1核2G），从基于spring cloud 按照自己对微服务的理解做了一套完整的CMS系统（虽然细节处理不怎么丝滑，不过也算微服务入门吧）到依赖成熟（开源）的解决方案快速搭建个人网站。自我评价也算是云服务的入门级用户了吧。目前在我的小小云上部署了太多的服务，出现系统资源不太够用的情况，特别是内存资源（使用率长时间在90%上下浮动）。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/11/06/Screenshot_20211106_203840.jpg" alt="memory"></p><p>  因此是时候整理下当前小云上运行的服务了，也当做是一个阶段性总结吧，顺便看看还能不能挤牙膏。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/11/06/img.alicdn-1-1.gif" alt="挤牙膏"></p><span id="more"></span><h2 id="总揽"><a href="#总揽" class="headerlink" title="总揽"></a>总揽</h2><p>  目前小小云对外提供以下服务：</p><ul><li>个人博客（Hexo）</li><li>个人图床（Chevereto）</li><li>个人网盘（NextCloud）</li><li>云端下载（Aria2）</li><li>直播转码（ffmpeg + SRS）</li><li>云端爬虫（Selenium + Chrome）</li><li>实验Beta环境（Spring cloud）</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/11/06/Screenshot_20211106_231009.md.jpg" alt="top"></p><p>  如上图所示为，每一个对外的服务均有多个子服务，子服务以docker的方式运行在云上。选择docker是因为：</p><ol><li>服务之间可隔离</li><li>遇故障服务可快速重建</li><li>对主机环境依赖低</li><li>避免在网络上暴露主机</li></ol><p>  得益于服务docker化，我可以通过docker-compose对服务进行编排，配置必要的参数。目前整体运转良好，除了开篇所说的内存占用较高以外。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/11/07/Screenshot_20211106_205445.jpg" alt="memory"></p><p>  但是说回来，运行这么多服务内存占用高一点似乎也说得过去，下面将服务展开来看。</p><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><h3 id="个人博客"><a href="#个人博客" class="headerlink" title="个人博客"></a>个人博客</h3><p>  基于轻量、支持Markdown语法、同时发布多站点的考虑，个人博客系统选择了Hexo。毕竟个人博客主要是用来承载个人的随笔，并不需要太多花哨的东西。在<a class="link" href="https://www.ray0728.cn/2020/05/07/Docker%E9%83%A8%E7%BD%B2Hexo%E5%8F%91%E5%B8%83/">《Docker + Git 部署Hexo发布》<i class="fas fa-external-link-alt"></i></a>中，详细介绍了如何利用脚本实现Hexo的多站点部署。Hexo常常被部署在github以及gitee所提供的静态页面上，如：<a class="link" href="https://ray0728.github.io/">我的github<i class="fas fa-external-link-alt"></i></a>或者是<a class="link" href="https://ray0728.gitee.io/">我的gitee<i class="fas fa-external-link-alt"></i></a>。但是这两家仓库提供商对图片的限制很大，如果博文中有较多图片可能会导致Hexo发布失败或是图片无法加载，因此最好能有一个稳定的图床作为博文图片的来源。正因为如此我在小云上紧接着就部署了Chevereto和NextCloud。</p><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>  Chevereto作为图床相当的好用，界面美观，功能丰富（完全满足博文的要求），并且提供官方的docker镜像。至于它的安装方式，网上的资料有很多，这里就不展开了，可依据应用的环境自行配置参数。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/11/07/Screenshot_20211107_212208.jpg" alt="hevereto"></p><p>  需要注意的是部分参数需要通过修改配置文件才可生效，如默认上传图片大小是有限制的（2MB），修改完成后用卷映射的方式重新指定给docker即可。</p><p>  图床顾名思义，主要是提供图片的支持。但是在丰富的博文中难免会遇上需要插入视频的时候，而此时又不想使用第三方服务（如哔哩哔哩）的话，就需要用到网盘了。</p><h3 id="网盘"><a href="#网盘" class="headerlink" title="网盘"></a>网盘</h3><p>  网盘我选择的是NextCloud，界面同样美观，具有很强的功能，完全可代替图床（因为我有一部分图片已上传至图床，实在不想迁移到网盘，所以两个都保留了）。网盘的视频功能支撑了<a class="link" href="https://www.ray0728.cn/2020/05/16/%E8%87%AA%E5%8A%A8%E9%81%8D%E5%8E%86UI%E6%8E%A7%E4%BB%B6/">《自动遍历UI控件》<i class="fas fa-external-link-alt"></i></a>中的视频播放。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/11/07/Screenshot_20211107_212308.jpg" alt="nextcloud"></p><p>  有了图床与网盘的加持，个人博客所需要的元素基本都到位了，剩下的就需坚持写下去🧐。</p><h3 id="云端下载"><a href="#云端下载" class="headerlink" title="云端下载"></a>云端下载</h3><p>  在<a class="link" href="https://www.ray0728.cn/2021/08/26/%E4%BA%91%E4%B8%8A%E5%88%A9%E7%94%A8Aria%E6%90%AD%E5%BB%BA%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/">《云上利用Aria搭建离线下载工具》<i class="fas fa-external-link-alt"></i></a>一文中描述了如何搭建云上下载工具。这里就不再细说了，不过近期发现有另一个服务好像“无意”中把未下载完的视频给转码直播了。🤣</p><h3 id="直播转码"><a href="#直播转码" class="headerlink" title="直播转码"></a>直播转码</h3><p>  在<a class="link" href="https://www.ray0728.cn/2021/09/15/%E8%AE%A9%E5%B0%8F%E4%BA%91%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E5%9C%A8%E7%BA%BF%E6%92%AD%E6%94%BE/">《让小云支持视频在线播放》<i class="fas fa-external-link-alt"></i></a>中描述了如何搭建在流媒体线播放平台。而出现上面提到的“误播”事件，则是因为写转播脚本的时候忘了加限制条件，脚本如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#! /bin/bashfunction read_dir(){for file in `ls $1`do if [ -d $1"/"$file ] then read_dir $1"/"$file else echo $1"/"$file ffmpeg -re -i $1"/"$file -c:v libx264 -ar 22050 -crf 28  -vf scale=320:240 -f flv -y rtmp://movie/live/loop fidone}root_dir=$1echo $root_dirwhile :do    IFS=$'\n'    read_dir $root_dir    IFS=$'\t\n'done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  脚本挺简单，循环遍历目录将文件用ffmpeg重新编码后推流。问题就出在遍历文件时未做判断，导致正在下载的视频也被推流了。</p><h3 id="云端爬虫"><a href="#云端爬虫" class="headerlink" title="云端爬虫"></a>云端爬虫</h3><p>  在《搭建在线Selenium执行环境》系列<a class="link" href="https://www.ray0728.cn/2021/06/20/%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">【一】<i class="fas fa-external-link-alt"></i></a>、<a class="link" href="https://www.ray0728.cn/2021/06/24/%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%EF%BC%88%E4%BA%8C%EF%BC%89/">【二】<i class="fas fa-external-link-alt"></i></a>中描述了使用selenium与websocket搭建在线selenium执行平台。并且基于此配合<a class="link" href="https://www.ray0728.cn/2021/07/13/cron%E8%B6%9F%E5%9D%91%E4%B9%8B%E6%97%85/">cron<i class="fas fa-external-link-alt"></i></a>实现自定义数据自动爬取如：<a class="link" href="https://www.ray0728.cn/2021/07/04/%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E7%94%9F%E6%88%90%E4%BA%8C%E6%89%8B%E6%88%BF%E7%83%AD%E5%8A%9B%E5%9B%BE/">房价信息<i class="fas fa-external-link-alt"></i></a>、<a class="link" href="https://www.ray0728.cn/2021/07/17/%E5%90%91%E7%9D%80%E4%BA%BA%E7%94%9F%E8%87%AA%E7%94%B1%E5%89%8D%E8%BF%9B%E4%B8%80%E5%B0%8F%E6%AD%A5/">基金信息<i class="fas fa-external-link-alt"></i></a></p><h3 id="Beta"><a href="#Beta" class="headerlink" title="Beta"></a>Beta</h3><p>  这里主要是近期在折腾的Spring cloud（如<a class="link" href="https://www.ray0728.cn/2021/10/27/gatway%E4%BD%BF%E7%94%A8Security%E9%80%82%E9%85%8DKeycloak/">Keycloak<i class="fas fa-external-link-alt"></i></a>），从目前运行情况来看，受可用资源较少的影响，相关的服务运行存在异常，还需要进一步“折腾”。</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>  截止本文，小小云上运行的服务差不多就这些，可能确实到了小云性能的瓶颈吧，刚好快到双11了，各大云服务提供商也在打折促销，是不是得考虑再买一个小小云了呢。</p>]]></content>
      
      
      <categories>
          
          <category> 云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring cloud gatway使用Spring security适配Keycloak</title>
      <link href="2021/10/27/211027-gatway%E4%BD%BF%E7%94%A8Security%E9%80%82%E9%85%8DKeycloak/"/>
      <url>2021/10/27/211027-gatway%E4%BD%BF%E7%94%A8Security%E9%80%82%E9%85%8DKeycloak/</url>
      
        <content type="html"><![CDATA[<p>  今日折腾之心又<strong>扑腾扑腾</strong>的支楞起来了，脑子一热想在小云上再搭一个授权服务中心和服务注册中心，这样从别的地方白嫖过来的服务器资源就可以和我的小云联动了。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/10/25/i0.hdslb.jpg" alt="白嫖怪"></p><span id="more"></span><p>  授权服务器嘛，不过就是OAUTH2呗，待我翻出2年前做的<a class="link" href="https://gitee.com/ray0728/authserver?skip_mobile=true">Spring 代码<i class="fas fa-external-link-alt"></i></a>那还不分分钟搞定它吗？说干就干，翻出闲置已久差点被删掉的idea，新建spring cloud项目，嗯，一切都很顺利，“不愧是我呀”心里面正美着呢，“咦？怎么现在spring配置器里没有<strong>spring-cloud-starter-oauth2</strong>了呢？”“重开也没有呢？”“难道是…今日不宜编程？”带着一堆的疑问在网上一搜，我当时的心情是这样的：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/10/25/img2.doubanio.jpg" alt="哦豁"></p><p>  为什么一个好端端的服务器框架说没就没了呢？后来在Spring官网找到这样的描述：</p><blockquote><p><strong>No Authorization Server Support</strong><br><br><br>In October 2012, RFC 6749, the OAuth 2.0 Authorization Framework, was published. Subsequently in May 2014, Spring Security OAuth released its 2.0.0 version with support for Authorization Server, Resource Server, and Client. This made a great deal of sense in the absence of OAuth 2.0 libraries and products.<br><br><br>Spring Security’s Authorization Server support was never a good fit. An Authorization Server requires a library to build a product. Spring Security, being a framework, is not in the business of building libraries or products. For example, we don’t have a JWT library, but instead we make Nimbus easy to use. And we don’t maintain our own SAML IdP, CAS or LDAP products.</p></blockquote><p>  大概意思就是说以前我们做了一件很厉害的事儿，不过现在我觉得快搞不动了，也不想维护之前的代码了，所以…大家自便吧。</p><p>  这大概也算是开源的一种“自由”吧。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/10/25/x0.ifengimg.jpg" alt="就离谱"></p><p>  怎么办呢？要么降级到springboot 2.1.4，要么寻找到替代方案。不过既然是折腾，那就折腾到底吧！经过一系列的折腾，成功入坑Keycloak，嗯，就是字面是入坑的意思，截止到此时此刻我依然在坑中躺平。</p><h2 id="Keycloak"><a href="#Keycloak" class="headerlink" title="Keycloak"></a>Keycloak</h2><p>  Keycloak可不得了，他来自名门世家（RedHat），还记得当年接触的第一款Linux就是RedHat 5，还记得那个时候第一次使用多桌面，觉得好特么神奇，也好特么鸡肋的功能。在Keycloak的个人介绍里面赫然写着：</p><blockquote><p>Add authentication to applications and secure services with minimum fuss. No need to deal with storing users or authenticating users. It’s all available out of the box.<br><br>You’ll even get advanced features such as User Federation, Identity Brokering and Social Login.</p></blockquote><p>  就问给不给力，凡是现在流行的登录方式，能想到的都给打包了。而它的用法特简单，基本上做到了开箱即用。相关的用法可在网上搜索，这里就不啰嗦了。</p><p>  但是如果使用的是docker镜像，Keycloak有一个<strong>巨大的坑</strong>，对！就我躺平的这个，关于这个坑后面单独再开一篇水文吧。关于Keycloak的配置，建议配置一个<strong>confidential</strong>的client，并作为下游Spring Oauth2的client-id以及secret。</p><p>  接下来说回Spring如何适配Keycloak。</p><h2 id="Spring-security"><a href="#Spring-security" class="headerlink" title="Spring security"></a>Spring security</h2><p>  其实适配方式挺简单的，毕竟Spring提供了现成的OAuth2客户端，当然也可以用Keycloak提供的Spring适配器。不过我不是特别建议这样做，因为我们希望网关仅仅是作为sso统一入口而已。那么它需要做到的无外乎是用户验证，而非授权判断。授权信息（token）的校验，应该由各个资源服务自行判断。对于用户验证，Spring security够用了。希望数据流转拓扑如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/10/26/Screenshot_20211026_225849.jpg" alt="数据流"></p><ol><li>用户资源访问请求首先达到Gateway（比如请求访问微服务1提供的资源）</li><li>Gateway将用户登录信息（如用户名密码亦或者Client ID Secert等）送给验证服务（keycloak），用于用户身份验证。验证通过后验证服务会传回一个token，用于标识用户信息（如用户名，权限，角色等）。</li><li>Gateway从discovery 服务中获取所有注册上来的微服务，从中找到需要使用的微服务</li><li>Gateway将用户请求以及token路由至正确的微服务</li><li>微服务获取到请求后，会去验证token是否合法并解析token中包含的用户信息，用于判断所请求的资源是否有权限访问。</li></ol><p>  对于最后一步，权限判断可放在Gateway，也可放在各微服务当中，他们实现的效果完全一样。但是个人还是倾向Gateway只做登录验证，权限验证交给资源服务（即后端的各个微服务）完成。原因如下：</p><ol><li>微服务架构本是为快速响应，快速变化而生的，即DeveOps。随着业务的发展，提供的资源越来越多样，那么需要的微服务也就越来越多。如果权限验证全由Gateway或前端控制，则意味着每更改一个微服务，Gateway或前端都可能需要更新，这和初衷是相违背的。</li><li>每个微服务应该是独立的，解耦的模块，而权限控制完全属于其专属的业务逻辑，理应由其维护。</li></ol><h3 id="依赖（pom）"><a href="#依赖（pom）" class="headerlink" title="依赖（pom）"></a>依赖（pom）</h3><p>  首先来看看需要依赖那些Spring组件。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-actuator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-oauth2-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-security<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  均采用Spring security相关组件，这样假如爬不出Keycloak的坑，更换别的授权服务，我的代码变动也会小一点吧。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/10/26/www.sina.jpg" alt="小机灵鬼"></p><h3 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h3><p>  既然用到了Spring security，那么少不了关键的安全配置，让我们来瞅瞅这个“炒鸡复杂”的配置方法吧</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity; import org.springframework.security.config.web.server.ServerHttpSecurity; import org.springframework.security.oauth2.client.registration.ReactiveClientRegistrationRepository; import org.springframework.security.web.server.SecurityWebFilterChain; @Configuration @EnableWebFluxSecurity public class SecurityConfiguration {     @Bean     public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http, ReactiveClientRegistrationRepository reactiveClientRegistrationRepository){         return http.authorizeExchange(exchanges -&gt; exchanges.anyExchange().authenticated())             .oauth2Login()             .and()             .build();     } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  没错，就只有这么一点即可实现sso登录验证。完全不用配置那些花里胡哨妖艳儿货。代码内容很简单，基本上算自注释了。</p><h3 id="关键配置"><a href="#关键配置" class="headerlink" title="关键配置"></a>关键配置</h3><p>  这一步是真关键，在数据流程拓扑中，不仅要路由，还要带上token，如何带上呢？这就需要在配置中完成了。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">security:  oauth2:    client:      provider:        keycloak:          token-uri: ${keycloak.hostname}/auth/realms/${keycloak.realm}/protocol/openid-connect/token          authorization-uri: ${keycloak.hostname}/auth/realms/${keycloak.realm}/protocol/openid-connect/auth          userinfo-uri: ${keycloak.hostname}/auth/realms/${keycloak.realm}/protocol/openid-connect/userinfo          user-name-attribute: preferred_username      registration:        beta:          provider: keycloak          client-id: ${keycloak.client-id}          client-secret: ${keycloak.client-secret}          authorization-grant-type: authorization_code          redirect-uri: "{baseUrl}/login/oauth2/code/keycloak"cloud:  gateway:    default-filters:      - TokenRelay    discovery:      locator:        lower-case-service-id: true        enabled: true        filters:          - StripPrefix=1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  这里有两个重点配置内容，第一个是按照OAuth2方式，将相关信息配置给Spring OAuth2 Client。另一个是给路由配置TokenRelay filter。</p><p>  OAuth2配置可以让我们正确与Keycloak交互，而路由filter则可以在成功登录后将token路由给下游微服务，以便下游进一步验证权限。</p><h2 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h2><p>  可通过构造一个测试端点来验证Keycloak返回的token。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping("/")public class testEndpoint {    @GetMapping("/")    public String home(@RegisteredOAuth2AuthorizedClient OAuth2AuthorizedClient authorizedClient) {        return String.format("Welcome %s&lt;br&gt; Your Access Token is:&lt;&gt;%s", authorizedClient.getPrincipalName(), authorizedClient.getAccessToken().getTokenValue());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  运行起来后，可通过访问测试端点获取到token，大约是一长串的jwt字符，在<a class="link" href="https://jwt.io/">Jwt.io<i class="fas fa-external-link-alt"></i></a>中可对字符解码，解码后的信息如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">  "iat": 1635174991,  "auth_time": 1635174688,  &lt;数据省略&gt;  "realm_access": {    "roles": [      "user-role", //包含分配的角色信息    ]  },  &lt;数据省略&gt;  "sid": "d789eba1-1461-44b6-bd50-660b4e5914ad",  "email_verified": true,  "name": "xxxxx" //在Keycloak中创建的用户名,  "preferred_username": "admin",  "given_name": "xxxx" //在Keycloak中创建的用户名,  "family_name": "admin",  "email": "xx@xxxxxxx" //在Keycloak中创建的用户邮件地址}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  可以看出token中已包含有用户相关信息，可进一步传递给下游，作为权限判断输入，符合上文中的预期。好了，用户登录有了，剩下的就是在资源服务器（即下游微服务）上实现权限验证了。</p><p>  后面再单独写一章吧，因为资源服务器的实现略有不同。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> KeyCloak </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>让小云支持视频在线播放</title>
      <link href="2021/09/15/210915-%E8%AE%A9%E5%B0%8F%E4%BA%91%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E5%9C%A8%E7%BA%BF%E6%92%AD%E6%94%BE/"/>
      <url>2021/09/15/210915-%E8%AE%A9%E5%B0%8F%E4%BA%91%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%E5%9C%A8%E7%BA%BF%E6%92%AD%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p>  在<a class="link" href="https://www.ray0728.cn/2021/08/26/%E4%BA%91%E4%B8%8A%E5%88%A9%E7%94%A8Aria%E6%90%AD%E5%BB%BA%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/">《利用Aria搭建离线下载工具》<i class="fas fa-external-link-alt"></i></a>一文末尾给自己留了一个待办事项</p><blockquote><p>配合下载工具实现下载完成后自动切片，以支持HLS在线播放</p></blockquote><p>  其实很早就在摸索落地方案了，但是最近工作确实特别忙，一边忙工作一边断断续续的探索，直到现在，基本上方案可以定型了。方案还是遵循一个原则：<strong>低代码开发，有现成的就用</strong>。</p><span id="more"></span><p>  大约在几年前吧，那个时候闲得无聊，利用SpringCloud + JS + FFMpeg做出过一个通过前端分片上传视频文件，后端自动完成切片的网站DEMO，所以在探索这个遗留事项的时候也就直奔FFMpeg而去，很快就搜索到几个候选方案。</p><h2 id="Express-FFMpeg"><a href="#Express-FFMpeg" class="headerlink" title="Express-FFMpeg"></a>Express-FFMpeg</h2><p>  一款带有CMS系统的离线转码平台。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>这套平台自带了很多挺不错的功能，如一键扫库（可自动将符合条件的文件加载进资源库中）、加水印（可加在切片中，也可加在播放器中）、TS文件加密以及生成预览图片等等，相关介绍请点<a class="link" href="https://gitee.com/quazero/express-ffmpeg">这里<i class="fas fa-external-link-alt"></i></a>。</p><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><p>  但是它也有避不开的短板（仅针对我使用过的docker版本）如：</p><ul><li>转码切片过程中CPU负载高</li><li>音频格式支持不全，蓝光格式视频文件很难转码成功。</li><li>无版本更新渠道</li></ul><p>  先说转码时的负载，对于我这样的小云（1核2G ECS）转码时CPU、内存双报警简直正常得不要不要的，虽然能理解，但接受不了。因为负载过高意味着我的其他服务就无法对外提供业务，比如我的这个博客小站。</p><p>  再说格式支持不全，通过ARIA下载的高清资源以MKV居多，而其中的音频格式又基本是DTS，我不确定是否是我使用的express-ffmpeg版本太老，无法支持还是别的原因。总之在扫库之后很容易卡在转码这一步。</p><p>  最后说说版本升级的事儿，从官网的介绍来看，我使用的docker版本已不再维护了，后续开发者专注到高级版以及纯净版（我理解这是2个更细分的领域）的开发工作上。因此要么停留在当前版本要么升级到新版本。官网也提供了新版本的下载地址，可是问题就在于新版本引入了key（可以理解为正版验证码）但是却没有提供申请或购买key的通道。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/09/14/img.wxcha.jpg" alt="What are U弄啥嘞"></p><p>  基于以上种种，我还是看看其他候选方案吧</p><h2 id="SRS-Simple-Realtime-Server"><a href="#SRS-Simple-Realtime-Server" class="headerlink" title="SRS(Simple Realtime Server)"></a>SRS(Simple Realtime Server)</h2><p>  SRS是一个简单高效的实时视频服务器，支持RTMP/WebRTC/HLS/HTTP-FLV/SRT。更多介绍可点击<a class="link" href="https://ossrs.net/releases/">这里<i class="fas fa-external-link-alt"></i></a></p><h3 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h3><p>  与express-ffmpeg相比较最大的优势在于负载。它是以实时切HLS（或RTMP）的方式提供视频网络播放功能，也就是说它仅对当前播放时间窗内的数据切片、保存，除此之外均不操作。换个词来说，这就是<strong>网络直播</strong>。</p><h3 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h3><p>  最大的劣势在于不支持点播，回放（重新推流不算），以及没有一个更简单的控制台，SRS所提供的控制台更像是一个数据看板，只能看当前的实时情况，却没办法做太多的控制（如发起推流，或设置分类），不过若SRS本身就是定位在提供实时音视频服务的话，也确实不需要提供过多花里胡哨的东西。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/09/15/Screenshot_20210915_225721.jpg" alt="console"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/09/15/Screenshot_20210915_225743.jpg" alt="console"></p><p>  同时对新手不友好，关键帮助文档欠缺。如对SRS中特有的Vhost没有更多的介绍，连Vhost之间如何跳转的没多写一个字。</p><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><p>  两套方案各有利弊，express-ffmpeg更接近开箱即用，提供端到端解决方案，虽然会遇到转码失败等问题，不过总体来讲还算不错。SRS有更强的扩展能力，并且低开销，高性能，很适合我这样的小云部署。也正是考虑到云端的开销，最终选择了SRS作为<strong>在线播放</strong>的解决方案。从部署后的运行效果来看，还算稳定。CPU实时负载游荡在告警门限值附近。</p><p><strong>12小时系统负载</strong></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/09/15/Screenshot_20210915_232736.jpg" alt="CPU"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/09/15/Screenshot_20210915_232755.jpg" alt="MEM"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/09/15/Screenshot_20210915_232811.jpg" alt="LOAD"></p><p><strong>实际效果</strong>（<em>循环推流 Tom and Jerry</em>）</p><video width="176" height="144" controls="">  <source src="https://movie.ray0728.cn/live/loop.m3u8" type="application/vnd.apple.mpegurl">  浏览器不支持 video 标签。</video><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>  选用SRS最大的困难在于不容易找到最直接的帮助文档，得多翻相关帮助说明，而这其中就以如何配置最为关键。在说明文档中可以看出VHost是SRS完成最主要工作的地方。那么什么是VHost呢？</p><p><strong>VHost</strong></p><p>  网上的资料大多说VHost就是SRS虚拟出多个主机，然后可以将业务通过域名相互隔离开。并且给出了通过配置本地hosts增加DNS解析的例子。我当前并不确定SRS中设置VHost真实的目的是什么，以下均为个人猜测。</p><ol><li>面向业务隔离的虚拟主机</li></ol><p>  SRS官方推荐的使用方式之一就是docker。既然都用docker了，为什么还要在SRS中引入虚拟主机的概念呢？这是玩无限套娃吗？另外用同一个SRS镜像多开几个容器不也可以实现业务间的隔离吗？为什么非要在一个服务里揉进这么多弯弯绕的东东呢？不担心复杂度高了，系统不稳定吗？</p><ol start="2"><li>面向对象的数据流转</li></ol><p>  从官网的Wiki所提供的几个例子中，个人感觉VHost更像是面向对象的一种设计，即一个VHost只专注于一件事情，做完了后再传递给下一个VHost继续完成业务流。如果是这样理解的话，那么VHost就完全是SRS内部数据流转的方式了，更hosts、DNS之类的完全不沾边了。</p><p>  我个人是比较倾向第二种的，当然这也仅仅是个人的猜测。</p><p><strong>配置文件</strong><br>  将Docker镜像拉下来之后，只需要修改配置文件就可以让SRS工作起来。以下是当前正在使用的配置文件，大部分都是默认参数。</p><p><strong>目标：将视频流转换成HLS，并支持通过浏览器播放。</strong></p><pre class="line-numbers language-none"><code class="language-none"># main config for srs.# @see full.conf for detail config.listen              1935;max_connections     1000;srs_log_tank        console;daemon              on;http_api {    enabled         off;    listen          1985;}http_server {    enabled         on;    listen          8080;    dir             ./objs/nginx/html;}stats {    network         0;    disk            sda sdb xvda xvdb;}vhost __defaultVhost__ {    tcp_nodelay   on;    min_latency   on;    play {       gop_cache    off;       queue_length  10;       mw_latency    100;    }    transcode {        enabled     on;        ffmpeg      ./objs/ffmpeg/bin/ffmpeg;        engine ff {            enabled         on;            vcodec          copy;            acodec          libfdk_aac;            abitrate        45;            asample_rate    44100;            achannels       2;            aparams {            }            output          rtmp://127.0.0.1:[port]/[app]?vhost=__hlsVhst__/[stream];        }    }}vhost __hlsVhost__ {    hls {        enabled         on;        hls_fragment    10;        hls_window      60;        hls_path        ./objs/nginx/html;        hls_m3u8_file   [app]/[stream].m3u8;        hls_ts_file     [app]/[stream]-[seq].ts;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h3><p>  以下依然是个人推测。通过将视频推流至SRS时，入口是<kbd><strong>defaultVhost</strong></kbd>。数据流进来后会触发<kbd>transcode</kbd>进行视频转码，以符合HLS切片要求。完成转码后会将数据流推给<kbd><strong>hlsVhost</strong></kbd>进行HLS切片，这样就完成了视频到HLS转变了。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>  SRS一旦上手后可玩性很强，而且4.0的功能更多，诸如支持多人视频会议等一系列特性都挺吸引人的，后面有机会再继续研究一下吧。</p><p>  这几天《青蛇劫起》全网上线了，作为加班星人自认是没时间去电影院了，就默默充个爱奇艺会员支持一下吧，也愿国漫能越来越好。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/09/15/www.sina.jpg" alt="白蛇2"></p>]]></content>
      
      
      <categories>
          
          <category> 云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> FFMpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云上利用Aria搭建离线下载工具</title>
      <link href="2021/08/26/210826-%E4%BA%91%E4%B8%8A%E5%88%A9%E7%94%A8Aria%E6%90%AD%E5%BB%BA%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/"/>
      <url>2021/08/26/210826-%E4%BA%91%E4%B8%8A%E5%88%A9%E7%94%A8Aria%E6%90%AD%E5%BB%BA%E7%A6%BB%E7%BA%BF%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<p>  有了一朵小云之后就忍不住去折腾。现在云上已部署静态Blog系统（<a class="link" href="https://www.ray0728.cn/2020/05/07/Docker%E9%83%A8%E7%BD%B2Hexo%E5%8F%91%E5%B8%83/">Hexo<i class="fas fa-external-link-alt"></i></a>），搭建有在线爬虫运行环境（<a class="link" href="https://www.ray0728.cn/2021/06/24/%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%EF%BC%88%E4%BA%8C%EF%BC%89/">在线Selenium<i class="fas fa-external-link-alt"></i></a>）并且由此衍生出了一个简单的数据分析工具（<a class="link" href="chrome-distiller://333d6871-dfa7-465a-bc84-7c486d19aff8_ba804a3874d585d2ab84e323ab99a95998ad9564015a24aceee5cce7a9346121/?time=26841306&amp;url=https%3A%2F%2Fwww.ray0728.cn%2F2021%2F07%2F04%2F%25E5%2588%25A9%25E7%2594%25A8%25E7%2588%25AC%25E8%2599%25AB%25E7%2594%259F%25E6%2588%2590%25E4%25BA%258C%25E6%2589%258B%25E6%2588%25BF%25E7%2583%25AD%25E5%258A%259B%25E5%259B%25BE%2F">二手房热力图<i class="fas fa-external-link-alt"></i></a>），通过设置CRON（<a class="link" href="https://www.ray0728.cn/2021/07/13/cron%E8%B6%9F%E5%9D%91%E4%B9%8B%E6%97%85/">趟坑之旅<i class="fas fa-external-link-alt"></i></a>）任务，尽可能利用夜间空闲时段进行数据爬取与分析。看上去好像小云需要执行的任务蛮多了，可实际上还远远没到小云的极限呢。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/08/24/40538115164191463676_mh1629796396076.jpg" alt="尽管作"></p><span id="more"></span><p>  在很早很早以前，那个时候网络很精彩，想要的很多，但网速却很慢，通宵挂机下载也是常有的事儿。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/08/23/5b0988e595225.cdn.sohucs-1.jpg" alt="网络卡"></p><p>  当时就想如果能有一个远程下载工具，随时随地想下就下该多好呀。后来各大下载工具也都搞出过VIP才可享受的离线下载功能，那个时候看着各位大V用着梦幻般的离线下载功能，着实令人羡慕啊。不过现在我也有自己的小云了，好像拥有离线下载也不是梦了，不过毕竟已经1202年了，实在无法满足只有一个简单的离线下载功了呢，特别是对离线下载的电影，我更希望能自动完成转码切片，并支持浏览器播放，这样晚上启动下片模式，白天就可以用手机偷偷的看了。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/08/24/i0.hdslb.jpg" alt="nice"></p><h2 id="离线下载神器"><a href="#离线下载神器" class="headerlink" title="离线下载神器"></a>离线下载神器</h2><p>  论下载速度，确实某雷说第二，没人敢当第一，可是某雷的应用并不适合部署在云端，更别说企图部署在一个资深“白嫖党”业主的云上了。其实在开源世界里还有很多优秀的下载工具供选择，<strong>aria2</strong>就是其中一个。</p><blockquote><p>Aria2是一款开源下载工具，可帮助简化不同设备和服务器之间的下载过程。它支持磁力链接、BT种子、http等类型的文件下载，与迅雷及QQ旋风相比，Aria2有着优秀的性能及较低的资源占用,架构本身非常轻巧，通常只需要4兆字节（HTTP下载）到9兆字节（用于BitTorrent交互）之间。最重要的一点是Aria2完全免费！<em>from <a class="link" href="http://aria2.baisheng999.com/">Aria2中文网<i class="fas fa-external-link-alt"></i></a></em></p></blockquote><p>  不过Aria2仅仅只是一个命令行的下载程序，类似wget命令，若想图形化管理还需要安装对应的web管理工具，官方提供的是<a class="link" href="https://github.com/ziahamza/webui-aria2">WebUI<i class="fas fa-external-link-alt"></i></a>，可以访问其提供的<a class="link" href="https://ziahamza.github.io/webui-aria2/">Demo<i class="fas fa-external-link-alt"></i></a></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/08/24/Screenshot_20210825_075336.jpg" alt="WebUI-aria2"></p><p>  WebUI与aria2之间的关系类似C/S之间的关系，通过一个WebUI可以访问多个任意aria2，因此每个aria2都可以设置一个密钥，用来验证是否允许访问。</p><p>  除了官方的WebUI之外，还有<a class="link" href="https://github.com/mayswind/AriaNg">Aria-NG<i class="fas fa-external-link-alt"></i></a>也是挺受欢迎的三方管理工具。二者相比较起来并无太大的差异，毕竟最核心的下载功能是由Aria2提供，而非Web客户端。但是后来因为选择了三方封装的Aria2-pro，而选择了Aria-NG。</p><h2 id="Aria2-Pro"><a href="#Aria2-Pro" class="headerlink" title="Aria2-Pro"></a>Aria2-Pro</h2><p>  Aria2-Pro严格来讲并不是比Aria2更强大的软件，而是由<a class="link" href="https://github.com/P3TERX/aria2.conf">P3TREX大佬<i class="fas fa-external-link-alt"></i></a>针对实际网络环境做了配置优化，换句话来说是一个带有优化配置的Aria2。可别小看这个优化配置，Aria2虽然功能强大，可是配置不正确的话，也会罢工的。来看看大佬带给我们什么惊喜吧。</p><blockquote><ul><li>BT 下载率高、速度快</li><li>重启后不丢失任务进度、不重复下载</li><li>删除正在下载的任务自动删除未完成的文件</li><li>下载错误自动删除未完成的文件</li><li>下载完成自动删除控制文件(.aria2后缀名文件)</li><li>下载完成自动删除种子文件(.torrent后缀名文件)</li><li>下载完成自动删除空目录</li><li>下载完成自动移动文件到指定目录</li><li>下载完成自动上传到 Google Drive 和 OneDrive 等网盘(RCLONE 联动功能)</li><li>BT 下载完成自动清除垃圾文件(文件类型过滤功能)</li><li>BT 下载完成自动清除小文件(文件大小过滤功能)</li><li>一键自动更新 BT tracker，进一步加速 BT 下载</li><li>有一定的防版权投诉、防迅雷吸血效果</li><li>更好的 PT 下载支持</li></ul></blockquote><p>  就问那一条特性不香了？除此之外还支持在下载完成后触发自定义脚本，这可就厉害了。让Aria2不再只是一个下载工具而可以变成智能网络中的一个节点。比如下载完成后自动根据文件属性进行分类，甚至做二次处理。</p><h2 id="Docker容器化"><a href="#Docker容器化" class="headerlink" title="Docker容器化"></a>Docker容器化</h2><p>  小云运行的是CoreOS系统，自然一切都是以容器运行为第一要务。幸运的是P3TREX还提供了一个容器化的<a class="link" href="https://github.com/P3TERX/Aria2-Pro-Docker">Aria2-Pro Docker<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>A perfect Aria2 Docker image. Out of the box, just add download tasks and don’t need to think about anything else.</p></blockquote><p>  这个slogan简直太棒了，just…don’t…else.直白而霸气呢。哈哈哈哈，行了，不吹了，部署上试试吧。</p><p>  由于Aria2-Pro提供了官方的<a class="link" href="https://github.com/P3TERX/Aria2-Pro-Docker">Docker镜像<i class="fas fa-external-link-alt"></i></a>以及参数配置说明，整个部署过程没有难度可言，这里就不赘叙，参考相关文档说明即可。部署好之后配合WebUI或AriaNG客户端使用即可。以下是我目前正在使用的docker-compose，和官方的说明差别不大。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">aria:    image: p3terx/aria2-pro    environment:      - PUID=500      - PGID=500      - UMASK_SET=022      - RPC_SECRET=&lt;密钥&gt;      - RPC_PORT=6800      - LISTEN_PORT=6888      - DISK_CACHE=64M      - IPV6_MODE=false      - UPDATE_TRACKERS=true      - CUSTOM_TRACKER_URL=    volumes:      - /home/core/data/aria2/conf:/config      - /home/core/downloads:/downloads    restart: always    networks:      - netaria    logging:      driver: json-file      options:        max-size: 1m  ariang:    image: p3terx/ariang    command: --port 6880    networks:      - netaria    logging:      driver: json-file      options:        max-size: 1m<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  因为我有一个NGINX（同样是docker）专做端口转发，因此这里没有映射本地端口到aria容器（本地容器间端口可直接访问）。另外将下载目录映射到了本地，为其他容器共享下载数据。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li>鉴权</li></ul><p>  首次使用Aria2的时候，不管用WebUI还是AriaNG都需要输入RPC密钥，这是唯一鉴别你是否具有访问权限的地方，因此请一定记牢且不要泄露RPC密钥。</p><ul><li>BT下载速度</li></ul><p>  对于BT下载资源获取很重要，提供资源的用户越多下载速度越快。目前有Peer、DHT、Tracker三种方式</p><blockquote><ul><li>Peer：在你获得一个有效用户后才会起作用，Peer 会获取该用户客户端里的用户信息。</li><li>DHT：相当于 Peer 的进阶，每个人都储存一部分 DHT 网络信息，需要的时候会通过该网络获得用户，然后再从该用户处获得更多的网络和用户，在连不上 Tracker 的时候很有效，但缺点是一开始是没有 DHT 网络的，必须要养一段时间（下载一些热门资源）才行。</li><li>Tracker：它会追踪下载同一个资源的用户，帮助你与其他用户建立连接，让其他用户把文件上传给你（给你提供下载速度），而你又把下载好的文件上传给其他需要的人（给别人提供下载速度）。</li></ul></blockquote><p>  Aria2Pro 会自动更新Tracker列表，所以为了能获得更好的下载体验，我们可以先选择一个用户数相对稳定的文件下载，以此来积累我们的DHT信息。</p><h2 id="未完"><a href="#未完" class="headerlink" title="未完"></a>未完</h2><p>  有了离线下载工具，后面我们再来看看怎么配合aria2实现视频的自动转码切片并支持HLS在线播放吧。</p>]]></content>
      
      
      <categories>
          
          <category> 云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Aria2 </tag>
            
            <tag> 下载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向着人生自由前进一小步</title>
      <link href="2021/07/17/210717-%E5%90%91%E7%9D%80%E4%BA%BA%E7%94%9F%E8%87%AA%E7%94%B1%E5%89%8D%E8%BF%9B%E4%B8%80%E5%B0%8F%E6%AD%A5/"/>
      <url>2021/07/17/210717-%E5%90%91%E7%9D%80%E4%BA%BA%E7%94%9F%E8%87%AA%E7%94%B1%E5%89%8D%E8%BF%9B%E4%B8%80%E5%B0%8F%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>  最近内卷传得越来越厉害，回头看看自己从毕业到现在这十几年，似乎也没存下啥东东，如果哪天裸辞（或被炒掉），身上这点积蓄好像也坚持不了太久呢，就这样中年危机的感觉忽如其来。</p><p>  很早之前也了解过基金、股票这类的投资理财产品，但是由于各种原因，也只是时不时的在网上随便挑几支，买一点，几年过去了，好像也没赚到什么钱，看来投资这事儿还真不是随手买买，佛系理财能干得了的，是时候认真学习理财了。</p><span id="more"></span><p>  在知乎上找了一个live课程（个人觉得<a class="link" href="https://www.zhihu.com/people/jane7ducai">简七<i class="fas fa-external-link-alt"></i></a>讲得就挺好的）学习了一段时间，确实让我对理财投资有了新的理解，基于自己还是一名打工人的现状，还是买基金靠谱一点，毕竟有专业人士操盘呢，只要选好了定投就行。可这么多基金怎么选呢？又怕app上推荐的其实是广告，其收益并不靠谱。思来想去，对呀！咱可以参考行业网站呀，比如<a class="link" href="https://www.morningstar.cn/main/default.aspx">晨星网<i class="fas fa-external-link-alt"></i></a>。这个网站早在几年前就关注到了，可是实在搞不懂它上面各种指标到底啥意思（还是懒啊），所以也就没在继续研究了。不过现在不一样了，有压力就有动力，那就仔细研究下吧。经过一系列的网上学习，大致上对晨星的各项风险指标有了初步的理解，对怎么选基金也有了个人的判断，好啦，现在理论有了，就差实践了。可是当我抱着一夜暴富的信心打开蚂蚁财富的时候，才发现理论和现实有些脱钩，这可怎么选呀。</p><video width="176" height="144" controls=""><source src="http://pan.ray0728.cn/s/Lg48dfYZXBrTYaa/download/%E8%9A%82%E8%9A%81%E8%B4%A2%E5%AF%8C-%E5%9F%BA%E9%87%91.mp4" perload="metadata">浏览器不支持 video 标签。</video><p>  显然蚂蚁财富并没有对每一个基金做详细的分析，不过想想也对，投资有风险嘛。谁也不敢拍着胸脯说跟着我买绝对不亏的。</p><p>  不过理解归理解，我还是得想想办法怎么快速选出我可以买的基金，晨星上基金资料最全，但是光是看基金列表都有500多页，这可得选到啥时候啊。不过都走到这一步了，自然就得让我们的爬虫小工具来辅助自己了。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/07/16/uri_mh1626450152541.md.jpg" alt="向着财富与自由"></p><h2 id="基金爬虫"><a href="#基金爬虫" class="headerlink" title="基金爬虫"></a>基金爬虫</h2><p>  爬虫最主要的任务是自动从晨星网上将基金各种信息都爬下来，并保存在数据库当中，然后根据自己定义的规则对基金进行排序，这样排在前面的就是符合自己购买风格的基金啦。</p><p>  基金爬虫在<a class="link" href="https://github.com/jackluson/fund-morning-star-crawler">jackluson<i class="fas fa-external-link-alt"></i></a>的基础上做了重新编码和逻辑调整。对于辅助挑选基金这个需求，脚本需要能抓取晨星上所有基金的晨星评级、购买单价、买入卖出手续费以及几大风险指标。等数据准备好之后，再按照一定的规则从数据库中查询出来即可。</p><p>  脚本主要逻辑是通过访问三个网址来获取必要信息。通过<a class="link" href="https://www.morningstar.cn/membership/signin.aspx">登录<i class="fas fa-external-link-alt"></i></a>让浏览器具有合法访问的session，然后通过遍历基金<a class="link" href="https://www.morningstar.cn/fundselect/default.aspx">列表<i class="fas fa-external-link-alt"></i></a>页面获取所有基金的基本信息（其中最重要的是晨星代码），然后通过组合出详情页(<a class="link" href="https://www.morningstar.cn/quicktake/%E6%99%A8%E6%98%9F%E4%BB%A3%E7%A0%81)%E8%8E%B7%E5%8F%96%E6%9F%90%E4%B8%80%E4%B8%AA%E6%8C%87%E5%AE%9A%E5%9F%BA%E9%87%91%E7%9A%84%E9%A3%8E%E9%99%A9%E6%8C%87%E6%A0%87%E6%95%B0%E6%8D%AE%E3%80%82">https://www.morningstar.cn/quicktake/晨星代码)获取某一个指定基金的风险指标数据。<i class="fas fa-external-link-alt"></i></a></p><p>  主逻辑调通以后，外部只需要依据规则调用对应的接口函数即可。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import os,sysfrom selenium import webdriverfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesfrom support.website.morningstar import MorningStar def initDriver():    driver = webdriver.Remote(        command_executor="http://chrome:4444/wd/hub",        desired_capabilities=DesiredCapabilities.CHROME    )    driver.implicitly_wait(10)    return driverdef close(driver):    driver.close()    driver.quit()if __name__ == "__main__":    driver = initDriver()    ms = MorningStar(driver)    try:        if(ms.login(os.getenv("MS_USERNAME"), os.getenv("MS_PASSWORD"), None)):            ms.refluseFundInfo(sys.argv[1] == "True", sys.argv[2], sys.argv[3])    finally:        ms.close()        close(driver)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  调用方式仍然套用<a class="link" href="https://www.ray0728.cn/2021/06/20/%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">《Selenium在线执行》<i class="fas fa-external-link-alt"></i></a>中设计的模板。</p><p><strong>完整代码已上传至<a class="link" href="https://gitee.com/ray0728/analysis-py/tree/master/fund/morningstar">Gitee<i class="fas fa-external-link-alt"></i></a></strong></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>  后端数据准备就绪后，前端反而简单了许多，在原<a class="link" href="https://www.ray0728.cn/2021/07/04/%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E7%94%9F%E6%88%90%E4%BA%8C%E6%89%8B%E6%88%BF%E7%83%AD%E5%8A%9B%E5%9B%BE/">《二手房热力图》<i class="fas fa-external-link-alt"></i></a>的基础上，新增一个table页即可。作为五流前端工程师就不自嗨了，勉强看看效果吧。</p><video width="176" height="144" controls=""><source src="http://pan.ray0728.cn/s/wGcPPHKbN9eaJTt/download/%E5%9F%BA%E9%87%91%E7%88%AC%E8%99%AB%E7%95%8C%E9%9D%A2.mp4" perload="metadata"> 浏览器不支持 video 标签。</video><p>  搜索功能目前暂不提供，仅有一个输入框而已。</p><h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>  一开始我以为就是爬一个较大数据量的网站嘛，最多耗时长点而已。可没成想第一次运行脚本，小云的负载直接填满，CPU使用率持续100%、内存占用率持续超98%，云平台连发两封告警邮件。而且持续时间之长，跑了3个小时也没跑完，期间导致系统使用出现各种异常比如：vim打不开，命令查询无响应，docker子网络中断等等。我粗略估计了一下，照这个进度一晚上应该是搞不定了，并且对我其他正在运行的服务也可能带来影响（目前云上共运行11个docker，提供了网关，网盘，图床，数据库等一系列的服务）。所以我决定把任务拆分成多个子任务，放在每天的凌晨执行，这也是迫使我<a class="link" href="https://www.ray0728.cn/2021/07/13/cron%E8%B6%9F%E5%9D%91%E4%B9%8B%E6%97%85/">《趟坑cron》<i class="fas fa-external-link-alt"></i></a>的原因之一。</p><p>  当然也许使用诸如分布式爬虫或更优秀爬虫框架能解决我这一问题，不过考虑到我就这么一朵小云，且算力就这么一点，我觉得还是不折腾了吧，等以后有机会再去学习各种花式操作。所以这一问题就先遗留下来了。</p><h2 id="附-晨星风险说明"><a href="#附-晨星风险说明" class="headerlink" title="附 晨星风险说明"></a>附 晨星风险说明</h2><blockquote><p>基金风险平均回报<br><br><br>平均回报为年度化的平均月几何回报，得出数据未必与过去一年实际年度回报相等。<br><br><br>标准差<br><br><br>反映计算期内总回报率的波动幅度，即基金每月的总回报率相对于平均月回报率的偏差程度，波动越大，标准差也越大。<br><br><br>夏普比率<br><br><br>夏普比率是衡量基金风险调整后收益的指标之一，反映了基金承担单位风险所获得的超额回报率（Excess Returns），即基金总回报率高于同期无风险收益率的部分，一般情况下，该比率越高，基金承担单位风险得到的超额回报率越高。<br><br><br>晨星风险系数<br><br><br>晨星风险系数反映计算期内相对于同类基金，基金收益向下波动的风险。其计算方法为：相对无风险收益率的基金平均损失除以同类别平均损失。一般情况下，该指标越大，下行风险越高。<br><br><br>相对表现阿尔法系数（α）<br><br><br>阿尔法系数（α）是基金的实际收益和按照β系数计算的期望收益之间的差额。其计算方法如下：超额收益是基金的收益减去无风险投资收益（在中国为1年期银行定期存款收益）；期望收益是贝塔系数β和市场收益的乘积，反映基金由于市场整体变动而获得的收益；超额收益和期望收益的差额即α系数。<br><br><br>贝塔系数（β）<br><br><br>贝塔系数衡量基金收益相对于业绩评价基准收益的总体波动性，是一个相对指标。β越高，意味着基金相对于业绩评价基准的波动性越大。β大于1 ，则基金的波动性大于业绩评价基准的波动性。反之亦然。如果β为1 ，则市场上涨10％，基金上涨10％；市场下滑10％，基金相应下滑10％。如果β为 1.1,市场上涨10％时，基金上涨11%, ；市场下滑10％时，基金下滑11% 。如果β为 0.9, 市场上涨10％时，基金上涨9% ；市场下滑10％时，基金下滑9% 。<br><br><br>R平方<br><br><br>R平方(R-squared)是反映业绩基准的变动对基金表现的影响，影响程度以0至100计。如果R平方值等于100 ，表示基金回报的变动完全由业绩基准的变动所致；若R平方值等于35，即35%的基金回报可归因于业绩基准的变动。简言之，R平方值愈低，由业绩基准变动导致的基金业绩的变动便愈少。此外，R平方也可用来确定贝塔系数（β）或阿尔法系数（α）的准确性。一般而言，基金的R平方值愈高，其两个系数的准确性便愈高。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Docker </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cron趟坑之旅</title>
      <link href="2021/07/13/210713-cron%E8%B6%9F%E5%9D%91%E4%B9%8B%E6%97%85/"/>
      <url>2021/07/13/210713-cron%E8%B6%9F%E5%9D%91%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p>  <a class="link" href="https://baike.sogou.com/m/v8020606.htm">cron<i class="fas fa-external-link-alt"></i></a>是Linux上的定时任务服务，可提供类似Windows上计划任务的功能，嗯，似乎cron的功能会更强大一些。为了能尽可能压榨我那可怜小云的算力，我需要定时运行一些高负载的计算任务，比如XX爬虫（参考<a class="link" href="https://www.ray0728.cn/2021/07/04/%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E7%94%9F%E6%88%90%E4%BA%8C%E6%89%8B%E6%88%BF%E7%83%AD%E5%8A%9B%E5%9B%BE/">《二手房热力图》<i class="fas fa-external-link-alt"></i></a>一文），那么自然就趟了cron的坑。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/07/13/1626167292617_edit_220816660334534.jpg" alt="心塞"></p><span id="more"></span><h3 id="坑•查看执行结果"><a href="#坑•查看执行结果" class="headerlink" title="坑•查看执行结果"></a>坑•查看执行结果</h3><p>  首先按照网上的各种cron教程，安装cron之后，创建了一个测试计划任务。</p><blockquote><p><code>*/1 * * * * echo HELLO</code></p></blockquote><p>  然后用命令<code>cron</code>启动任务，嗯？启动之后似乎没啥反应啊，“哦，对，网上大佬说过cron的结果得通过邮箱查看”，赶紧输入命令<code>mail</code>查看。嗯？然而什么都没显示。不应该啊，难道没运行起来，可是进程当中确实有cron这个进程呢，用<code>crontab  -l</code>也能看见刚刚配置的任务。“嗯，不要慌，反正慌也没啥用”，既然网上大佬说过是通过邮件通知的，那就手动在log目录（泛指Linux中产生日志，邮件的文件目录）中找找呗，最终在<code>/var/spool/mail/</code>中找到日志了。可看见每隔一段时间就有一个HELLO出现。</p><p>ps：<strong>可通过命令<code>tail -f /var/spool/mail/mail</code>持续跟踪cron任务执行结果的输出</strong>。</p><h3 id="坑•环境变量"><a href="#坑•环境变量" class="headerlink" title="坑•环境变量"></a>坑•环境变量</h3><p>  既然HELLO都可以执行了，那就来一个复杂一点的任务吧。我将需要执行的脚本统一放在了一个Shell脚本当中，脚本大概长下面这个样子。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#!/bin/bashpython 我要图片.pypython 我要应用.pypython 我要自行车.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  然后将这个脚本添加进cron任务。按预想，到时间后会依次执行“我要xx”脚本。</p><blockquote><p><code>*/1 * * * * iwant.sh</code></p></blockquote><p>  然而和上一个坑遇到的情况一毛一样，啥都没发生，唉，就说气不气人吧。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/07/13/1626170157985.png" alt="气人"></p><p>  行嘛，既然出了问题那就定位搞呗。之前直接执行echo一切正常，换成Shell脚本就出现问题，猜测是脚本执行失败，那么需要获取具体的错误原因再做进一步分析，通过重定向将错误信息保存至文本当中。发现脚本使用的是系统默认的Python2.x版本，而脚本中需要的库是安装在Python3当中的。嗯，懂了，那我就显式指定Python路径呗。将脚本修改成这个样子。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#!/bin/bash/usr/local/bin/python 我要图片.py/usr/local/bin/python 我要应用.py/usr/local/bin/python 我要不知道要什么.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  再次运行，Python倒是用对了，但是脚本依然报错，提示我某些环境变量找不到（为了便于配置，我将部分参数以环境变量的形式配置在docker-compose.yml当中，程序运行时会直接读取这部分参数），我的第一反应是脚本写错了，可是单独运行又是一切正常。这又是遇到了什么鬼！</p><p>  查看cron系统配置（/etc/crontab），简单看了下也没啥毛病呀。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># /etc/crontab: system-wide crontab# Unlike any other crontab you don't have to run the `crontab'# command to install the new version when you edit t is file# and files in /etc/cron.d. These files also have usrname fields,# that none of the other crontabs do.SHELL=/bin/shPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/bin:/usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  这下懵逼了，最怕的就是这种问题，连怎么调试都不知道。直到在网上找到这样的神文<a class="link" href="https://www.ibm.com/support/pages/cron-environment-and-cron-job-failures">《The Cron Environment and Cron Job Failures》<i class="fas fa-external-link-alt"></i></a>，看这标题怕不就是专门为我而写的吧。</p><blockquote><p><strong>What is the cron environment?</strong><br><br><br>  Since the cron daemon is a system program that is started by one of the system startup scripts, its environment will not be the same as the environment inherited from the shell when a job is run from the command line. Cron inherits its environment from its parent, which is the init process. But during cron initialization, cron can modify or extend the environment before it runs cron jobs. The default environment for a cron job consists of /etc/environment, and the default shell environment variables such as <kbd><strong>$PATH</strong></kbd>, <kbd><strong>$HOME</strong></kbd> and <kbd><strong>$PWD</strong></kbd>. Information in login files (for example, /etc/profile, ~/.profile and ~/.kshrc, so it is unlikely <kbd><strong>$PATH</strong></kbd> contains login shell directories. If the cron job needs any information in these shell initialization files, these scripts must be sourced at the top of the cron job script.<br><br><br>System limits, also known as ulimits are essential to the cron environment. The ulimits for a cron job are inherited from the root account, and will likely not be the same as the ulimits for a regular user account.<br><br><br><strong>Note</strong>: The at command is often used to test cron jobs. Because the at command is executed from the command line, unlike cron, it will automatically inherit the current environment of the shell.</p></blockquote><p>  简单来说就是cron是由init进程创建的，因此它的环境变量和init保持一致，而我们在Shell中执行脚本时用到的环境变量相较于系统启动时已有很大的变化，因此cron无法主动获取到新增（或修改）的变量，而在文中介绍的解决办法则是（简单直接）</p><blockquote><p>Any additional information needed by a cron job can also be added directly at the top of the cron job script. </p></blockquote><p>  既然蓝色大佬都这么说了，那就搞呗。可是问题又来了</p><ul><li><p>我需要的环境变量是由docker传递进来的，并非写在profile或bashrc当中，因此不能通过source或自行rc的方式让环境变量生效。</p></li><li><p>为了便于管理以及安全考虑，所以才将参数修改为docker的环境变量，难道为了cron，我还得硬编码进脚本吗？似乎和初衷相违呢。</p></li></ul><p>  这可咋整？回头再看看文档，终于发现关键的一句话<kbd>The default environment for a cron job consists of /etc/environment</kbd>。如果我能把这个文件同步成最新的变量不就OK了么。有了这个思路，那解决起来就是一句话的事儿了。</p><blockquote><p>printenv &gt; /etc/enironment</p></blockquote><p>  是的，没错就这么一句话就搞定cron变量的问题。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/07/04/b-ssl.duitang.jpg" alt="叉腰"></p><h3 id="坑•格式"><a href="#坑•格式" class="headerlink" title="坑•格式"></a>坑•格式</h3><p>  这个坑和前面的比起来只能算小泥坑，对，就是下面这种愉快的小坑。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/07/13/1626180025683_edit_228041496623536.jpg" alt="愉快的坑"></p><p>  对于首次使用cron的新手来说，cron确实不够友好，我第一次在<a class="link" href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a>上学习cron的时候，差点把我整自闭，大家可以感受下。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/07/13/Screenshot_20210713_204538.jpg" alt="菜鸟教程"></p><p>  我第一反应是这一堆的 <code>* * *</code> 是啥啊？它怎么就表示每天，每分钟，每小时了啊？这不是在逗我吗？后来才了解到不同位置的 <code>*</code> 有不同的含义（站位的重要性），可每一位具体表示什么呢？网上又出现有歧义的解读，有些说是按秒分时排序，有些说是按分时排序，感觉上在不同的平台，不同的版本的cron配置是不统一的（没确认过）。</p><p>  其实完全不用去网上找cron的配置说明，在/etc/crontab中就有详细的描述。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh"># Example of job definition:# .---------------- minute (0 - 59)# |  .------------- hour (0 - 23)# |  |  .---------- day of month (1 - 31)# |  |  |  .------- month (1 - 12) OR jan,feb,mar,ap ... # |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # |  |  |  |  | # *  *  *  *  * user-name command to be executed 17 *    * * *   root    cd / &amp;&amp; run-parts --report / tc/cron.hourly 25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily ) 47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly ) 52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   简单清晰，一看就懂。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>   至此，我的cron趟坑之旅也就快结束了，目前在cron的帮助下，我将周一至周六每天凌晨的时段都安排上了。因为最近搞了一个爬虫，数据量比较大，而我的小云负载又不是那么强，只好拆分了一下，安排在每天凌晨了呗。而这个新爬虫到底干了啥后面再单独写吧。<br> )</p>]]></content>
      
      
      <categories>
          
          <category> 云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用爬虫生成二手房热力图</title>
      <link href="2021/07/04/210704-%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E7%94%9F%E6%88%90%E4%BA%8C%E6%89%8B%E6%88%BF%E7%83%AD%E5%8A%9B%E5%9B%BE/"/>
      <url>2021/07/04/210704-%E5%88%A9%E7%94%A8%E7%88%AC%E8%99%AB%E7%94%9F%E6%88%90%E4%BA%8C%E6%89%8B%E6%88%BF%E7%83%AD%E5%8A%9B%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>  曾经在<a class="link" href="https://www.ray0728.cn/2021/06/20/%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">《搭建在线Selenium执行环境》<i class="fas fa-external-link-alt"></i></a>中树了一个Flag。</p><blockquote><p>可以通过将脚本上传至服务器上，让服务器自动挂机执行。一夜爬遍某乎也不是梦了（还不用担心妈妈让我关电脑了）</p></blockquote><p>  唉，Flag立得倒是挺轻松的，先看看我的小云已经有了那些功能吧，当前前端已能<a class="link" href="https://code.ray0728.cn/">在线编辑并运行Python脚本<i class="fas fa-external-link-alt"></i></a>，后端可<a class="link" href="https://www.ray0728.cn/2020/05/21/%E6%90%AD%E5%BB%BASelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">通过Docker执行Selenium爬虫脚本<i class="fas fa-external-link-alt"></i></a>，似乎万事具备，只欠整合了。那今天就来填坑吧，看看怎么让服务器（云）挂机执行爬虫吧。</p><span id="more"></span><h3 id="定目标"><a href="#定目标" class="headerlink" title="定目标"></a>定目标</h3><p>  万事开头都得定目标，那我也定个小目标吧，刚好最近领导想买房子，但是害怕以后增值空间不大，毕竟现在伪口岸也挺多的。那就写个爬虫爬爬某家的二手房数据吧，用数据来看看到底那些区域最红火，那些区域有价无市。</p><h3 id="写脚本"><a href="#写脚本" class="headerlink" title="写脚本"></a>写脚本</h3><p>  爬虫脚本编写很简单，这里就不展开了，简单来说就是打开、搜索、获取、点击、再搜索、再获取，并重复以上的操作，直到脚本的完成。</p><p>  在编写脚本的时候，发现采集下来的数据量很大，而且频繁爬取某家的数据，担心我的小云被关进小黑屋 以后再也不能偷爬某家的数据了，因此需要将数据缓存起来，可以选择Redis也可以选择MySQL，而我选择了MariaDB（MySQL的分支版本）。这样完成的脚本大概就像下面这样子（仅主函数代码）：</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">driver = initDriver()helper = SQLHelper()helper.clearData()try:    for page in range(1,101): driver.get("https://{}.lianjia.com/ershoufang/pg{}".format(city, page))        cards = driver.find_elements_by_xpath('//div[@class="info clear"]')        for card in cards:            house = card.find_element_by_xpath('.//div[@class="flood"]/div[@class="positionInfo"]/a[1]').get_attribute('textContent')            region = card.find_element_by_xpath('.//div[@class="flood"]/div[@class="positionInfo"]/a[2]').get_attribute('textContent')            info = card.find_element_by_xpath('.//div[@class="address"]/div[@class="houseInfo"]').get_attribute('textContent').split("|")            price = card.find_element_by_xpath('.//div[@class="priceInfo"]/div[@class="totalPrice"]/span').get_attribute('textContent')            helper.insertNewHouse(region, house, info[1].strip().rstrip("平米"),info[4].strip(), price)        helper.autoUpdateHouseInfo()finally:    helper.close()    close(driver)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  如代码所述，采集后会将关键信息保存进数据库。脚本有了，那就该让脚本能自动运行起来了。</p><h3 id="定时器Cron"><a href="#定时器Cron" class="headerlink" title="定时器Cron"></a>定时器Cron</h3><p>  要自动唤起脚本，可以用Shell定时脚本如：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sleep 3h;python yourscrip.py<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  在其基础上加上<code>while...do....done</code>就可以实现循环定时执行了。可是这个方法有个问题，就是睡眠的时间无法固定。</p><p>  举个例子，我希望每1小时执行一次脚本，所以用了sleep 1h，可是脚本执行是需要时间的，也就是说第二次执行的时间相较于第一次执行的时间并不是只过去了1个小时，而是过去了1小时加上脚本执行的耗时，而这个时差会累积的，循环次数越多，则误差越大。</p><p>  再者，我实际希望脚本能在凌晨3点执行，这样对服务器负载会轻一点。那么应该sleep多少呢？是不是一脸懵逼？综合以上两个原因，用sleep并不适合当前的场景。</p><p>  Cron是Linux的定时任务执行服务，它会根据配置定时启动任务执行，类似Windows的定时任务。详细介绍可参考<a class="link" href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">菜鸟教程<i class="fas fa-external-link-alt"></i></a>或自行百度。但是cron有一个巨大的坑，差不多有下图这么大，后面再单独写一个关于cron填坑实录吧😂。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/07/04/1625402697759.jpg" alt="天坑"></p><p>  配置好cron，安置好准备好的脚本，就可以坐等小目标实现了。不过，好像差点什么。唉？唉？是不是还差个前端显示啊，不然爬完的数据还是数据啊，居然忘了这个这么重要的事情。</p><h3 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h3><p>  前端怎么显示数据呢，柱状图？曲线？还是表格？哈哈哈，都不是，本人选择了最简单的热力图。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/07/04/b-ssl.duitang.jpg" alt="叉腰"></p><p>  热力图选择高德地图来实现的，并复用了<a class="link" href="https://www.ray0728.cn/2021/06/24/%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%EF%BC%88%E4%BA%8C%EF%BC%89/">《搭建在线Selenium执行环境》<i class="fas fa-external-link-alt"></i></a>中已实现的前后端数据通道。利用BootStrap4做了一个简单的前端界面，最终实现的效果还不错。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/07/04/Screenshot_20210704_214812.md.jpg" alt="热力图"></p><p>  高德热力图有一个小坑，他官网上能搜到多个版本的热力图数据方式，但其实只有一种能成功。传入的数据一定要是数组结构，且每个点需要是哈希结构，js大致如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">var</span> heatlayer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    heatlayer <span class="token operator">=</span> <span class="token function">initMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">loaddata</span><span class="token punctuation">(</span><span class="token parameter">type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> wss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebSocket</span><span class="token punctuation">(</span><span class="token string">'wss地址'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wss<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'close'</span><span class="token punctuation">,</span> onCloseWss<span class="token punctuation">)</span><span class="token punctuation">;</span>    wss<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'message'</span><span class="token punctuation">,</span> onMessageWss<span class="token punctuation">)</span><span class="token punctuation">;</span>    wss<span class="token punctuation">.</span><span class="token function-variable function">onopen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        wss<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'发起数据请求'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">onCloseWss</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">onMessageWss</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> hdata <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    heatlayer<span class="token punctuation">.</span><span class="token function">setDataSet</span><span class="token punctuation">(</span><span class="token punctuation">{</span>data<span class="token operator">:</span> hdata<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    heatlayer<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">initMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AMap<span class="token punctuation">.</span>Map</span><span class="token punctuation">(</span><span class="token string">'map'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>        resizeEnable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>        center<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">104.066593</span><span class="token punctuation">,</span><span class="token number">30.657789</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        zoom<span class="token operator">:</span> <span class="token number">11</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">setMapStyle</span><span class="token punctuation">(</span><span class="token string">'amap://styles/d04f6e9640ff8cc28c800c925a2dd146'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isSupportCanvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'The heat map is applicable only to browsers that support canvas. The browser you are using cannot use the heat map function. Please try another browser.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">let</span> heatlayer<span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">plugin</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"AMap.Heatmap"</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        heatlayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AMap<span class="token punctuation">.</span>Heatmap</span><span class="token punctuation">(</span>map<span class="token punctuation">,</span> <span class="token punctuation">{</span>            radius<span class="token operator">:</span> <span class="token number">25</span><span class="token punctuation">,</span>            opacity<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.8</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> heatlayer<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">isSupportCanvas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> elem <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'canvas'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>elem<span class="token punctuation">.</span>getContext <span class="token operator">&amp;&amp;</span> elem<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token string">'2d'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  前端点击按钮的时候，会触发loaddata函数，进一步通过websocket去后台获取JSON格式的数据，并转换为数组传递给Map。</p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>  最后从热力图上大致看出，果然天府新区在我大成都热得不是一点半点呢（当然滑动地铁，还能发现其他更有意思的事儿呢）。得赶紧向领导汇报下成果了，希望今年云服务器的钱可以报销了。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Docker </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建在线Selenium执行环境（二）</title>
      <link href="2021/06/24/210624-%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2021/06/24/210624-%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>  在<a class="link" href="https://www.ray0728.cn/2021/06/20/%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">《搭建在线Selenium执行环境（一）》<i class="fas fa-external-link-alt"></i></a>中描述了如何利用websocket和codemirror搭建一套Python远程执行环境，但是文章仅完成了前端与后端的数据通道，并没有让Python脚本真正的执行起来，那么今天就来实现后端实时执行这个关键需求。</p><p>  要完成<strong>远程执行Python</strong>这个目标，至少需要完成以下几点：</p><ol><li>完整获取前端脚本文本内容（包括文本缩进格式）</li><li>将执行结果完整返回至前端</li><li>将错误信息完整返回至前端</li><li>主机安全保障<span id="more"></span><h2 id="完整获取前端内容"><a href="#完整获取前端内容" class="headerlink" title="完整获取前端内容"></a>完整获取前端内容</h2>  Websocketd通过将接受到的数据转换为标准输入传递给处理脚本，之前我尝试用SHELL的<a class="link" href="https://linuxcommand.org/lc3_man_pages/readh.html">read<i class="fas fa-external-link-alt"></i></a>命令进行获取，发现这样的方案存在一个致命的缺陷，read会自动去掉读取字符串首位的空格。</li></ol><blockquote><p>The line is split into fields as with word splitting, and the first word is assigned to the first NAME, the second word to the second NAME, and so on, with any leftover words assigned to the last NAME. Only the characters found in $IFS are recognized as word delimiters.</p></blockquote><p>  由于read会自动将读取到的字符串按词组进行分割，所以如果读取的该行数据带有缩进（一般为空格）就会被丢弃掉，进而导致接收到的Python脚本无法通过语法校验（Python格式需满足<a class="link" href="https://pep8.org/">PEP8<i class="fas fa-external-link-alt"></i></a>要求）。</p><p>  这种情况下显然不能依赖简单的SHELL命令了，我们需要一个能完整读取标准输入流中数据的脚本。我选择通过一个简单的Python脚本来完成这一工作。为什么选择Python呢？在后面会做解释。</p><p>  脚本很简单，只需要实现读取保存即可，代码如下：</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">pyfile = open('tmp.py', 'w')size = sys.stdin.readline()maxsize = int(size)while(maxsize &gt; 0):    line = sys.stdin.readline().replace("\t","    ")    pyfile.write(line)    maxsize -= len(line)pyfile.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="脚本选取的考量"><a href="#脚本选取的考量" class="headerlink" title="脚本选取的考量"></a>脚本选取的考量</h3><p>  脚本首先读取即将保存的文本大小（长度），然后循环读取这么多大小（长度）的数据即可。既然涉及文件长度的判断，那么不得不考虑中英文字符串长度的差别。前后端如果对长度判断存在误差，会导致后端接收数据不完整。我们前端肯定是通过JS来获取文本长度，那么后端应该选什么样的脚本来对接呢？实测发现Python的长度判断与JS一致，因此后端选择Python做接收脚本。回过头再来看看前端如何发送数据的。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">upload</span><span class="token punctuation">(</span><span class="token parameter">editor<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> content <span class="token operator">=</span> editor<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> blob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Blob</span><span class="token punctuation">(</span><span class="token punctuation">[</span>content<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>type<span class="token operator">:</span> "text<span class="token operator">/</span>plai<span class="token punctuation">;</span>charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>"<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    wss<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>content<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    wss<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>    wss<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="执行与返回"><a href="#执行与返回" class="headerlink" title="执行与返回"></a>执行与返回</h2><p>  既然后端已完整保存了前端输入的脚本内容，剩下的只需执行Python tmp.py就好了。可是执行时发现仅有成功执行的数据被送回前端，而错误信息均未送达。这又是为啥呢？原因在于Websocketd仅接收标准输出流，对于标准错误流是不处理的。既然如此，第一反应当然就是重定向标准错误流咯。下面是执行脚本：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">env PYTHONIOENCODING=utf-8 python tmp.py 2&gt;err.logif [ -s "err.log" ]; then   cat err.logfi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  脚本将标准错误流重定向至err.log，并在该文件有内容的时候输出到标准输出流上，从而让所有信息都能通过Websocketd发送到前端。</p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/26/Screenshot_20210622_232534_com.huawei.browser.jpg" alt="codeonline"></p><p>  执行效果上看还不错，唯一有点麻烦的是每次执行完连接就会断开，再次执行前需要点一下连接。毕竟🤪</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/26/fe14691e308e8353c137350a4ade9397.jpg" alt="又不是不能用"></p><h2 id="主机安全"><a href="#主机安全" class="headerlink" title="主机安全"></a>主机安全</h2><p>  目前我也没想好怎么做好相关的防护，虽然整个环境都运行在docker里。在<a class="link" href="https://www.ray0728.cn/2020/05/21/%E6%90%AD%E5%BB%BASelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">《搭建Selenium执行环境》<i class="fas fa-external-link-alt"></i></a>一文中曾提到要特别小心docker.sock的使用，其实除此之外还要小心Docker群组以及磁盘映射的配置。毕竟每个docker内部都是以root权限在运行，如果磁盘映射不合理，很容易给主机安全带来风险。</p><p>  等以后再系统性的总结相关的内容吧，毕竟我也需要多学习一下相关的知识和实战应用的经验呢。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Docker </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建在线Selenium执行环境（一）</title>
      <link href="2021/06/20/210620-%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
      <url>2021/06/20/210620-%E6%90%AD%E5%BB%BA%E5%9C%A8%E7%BA%BFSelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>  早先用Docker在云服务器上搭了一个<a class="link" href="https://www.ray0728.cn/2020/05/21/%E6%90%AD%E5%BB%BASelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">《Selenium 执行环境》<i class="fas fa-external-link-alt"></i></a>，可以通过将脚本上传至服务器上，让服务器自动挂机执行。一夜爬遍某乎也不是梦了（还不用担心妈妈让我关电脑了）。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/20/5b0988e595225.cdn.sohucs.jpg" alt="从此走上人生巅峰"></p><p>  但是这套环境有个最大的问题，脚本怎么上传呢？紧接着还有一个更大的问题，上传之后怎么自动触发执行呢？为了上传文件这么一件小事，难道还得搞个Apache？那多麻烦呀，而且我那朵小云可只有1核2G呢。还是想个更轻量的解决方案吧。</p><span id="more"></span><h2 id="参考目标网站"><a href="#参考目标网站" class="headerlink" title="参考目标网站"></a>参考目标网站</h2><p>  相信不少人都接触过<a class="link" href="https://m.runoob.com/">【菜鸟教程】<i class="fas fa-external-link-alt"></i></a>或<a class="link" href="https://www.w3school.com.cn/">【W3C School】<i class="fas fa-external-link-alt"></i></a>这样的良心网站，他们提供了很多语言的学习教程，同时还提供了在线编程的功能，即允许用户通过网页的方式执行一段代码。比如这样的：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/20/Screenshot_20210620_230837.jpg" alt="菜鸟在线执行"></p><p>  假如我的小云也有这样一个环境，那么是不是就可以通过前端页面直接将脚本交给后端执行了呀，重要的是这样上班摸鱼也不会被发现了。<strong>完美！</strong></p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>  当然我不用像前辈做得那样复杂，能有语法高亮显示，能传给后端，能回显执行结果就好了。说干就干，当然动手之前还是好好学习下前辈的代码吧，免得走弯路不是。通过简单浏览了前辈前端代码，发现一个关键字<strong>CodeMirror</strong>，再进一步搜索了一下，发现这家伙不得了，功能强到不行，关键还开源。相关的介绍这里就不展开了，网上一搜一大把的资源，点击<a class="link" href="https://codemirror.net/6/">这里<i class="fas fa-external-link-alt"></i></a>可以跳转至CodeMirror官网。简单来说有了这位大哥的支持，满足我那一丁点的前端诉求，不要太方便了哦。参考官网的指导，我的小云很快速的上线了一个看上去还凑合的前端页面。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/20/Screenshot_20210620_233116.jpg" alt="code online"></p><p>  为了方便在触摸设备上编辑，还多增加了全屏控制开关（电脑上支持F11快捷进入）。并且还会预先填入初始化脚本（脚本来源于<a class="link" href="https://www.ray0728.cn/2021/06/03/Docker&amp;Selenium%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0Gitee%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/">《自动刷新Gitee》<i class="fas fa-external-link-alt"></i></a>一文），减少重复输入。</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>  CodeMirror只负责前端的显示，并不提供实际执行功能，如何将代码用云端的环境执行起来着实让人头疼，难道还是避免不了要开发一个后台服务吗？唉，虽说一个后台服务难度不大，可我实在不想把简单的事搞这么复杂呀（最重要的是<strong>懒</strong>）。为了躲避开发的工作，我也想了很多方案。</p><ul><li><strong>方案一：个人网盘方案</strong></li></ul><p>  很早我就在小云上部署了一套NextCloud作为个人网盘，而NextCloud提供多种语言的API接口，允许用户通过接口直接管理文件，这其中就有文件上传。那么这套方案我设想的工作流是：</p><p> <img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/20/Screenshot_20210621_001459.jpg" alt="nextcloud 流程"></p><p>  这套方案存在两处硬伤，首先通过JS保存文件需要得到用户的许可，从安全角度讲浏览器是不允许JS私自向存储器写文件的。其次NextCloud提供的API当中并没有类似钩子一样的函数，允许我们对上传的文件做处理（当然也可能是我不知道而已），因此该方案<strong>不可行</strong>。不过也多亏这个方案让我明确了我能操作的一定只有CodeMirror能提供的Blob数据而已。</p><ul><li><strong>方案二：轻量级PUT/POST服务器</strong></li></ul><p>  这套方案需要我能提供一个支持PUT/POST的web服务，因为前端需要将文件数据传到后端那么可以参考表单提交的方式传递数据，虽说GET也能实现同样的效果，但毕竟不符合语法约定。这套方案需要后端提供具备以下功能：</p><ol><li>轻量级的HTTP服务，如：Tomcat、Apache2、Nginx、IIS等，虽然这其中并不是所有都配得上轻量这个称号。</li><li>接口响应程序，这没有现成的，不过有很多开发框架可以使用如：Spring、Spring boot、Spring cloud、Servlet、PHP等等。</li></ol><p>  当前已部署有Nginx作为网关，将不同地址分发到不同的Docker上去，因此第一点满足。Gitee上也有几年前基于Spring cloud做的文件上传代码（良好上库习惯的优势），做些调整应该能很快上线，第二点也满足。可是该方案不符合我当前做个人网站的原则（优选现成方案，次选简单方案，最差才是自己动手）。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/21/n.sinaimg_edit_304979992184712_mh1624273849876.jpg" alt="正经人"></p><ul><li><strong>方案三：WebSocket实时连接</strong></li></ul><p>  就在我一筹莫展，在网上闲逛的时候，在一个不起眼的角落发现了一个名叫WebSocket的东西，进而在阮大佬的<a class="link" href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程<i class="fas fa-external-link-alt"></i></a>中大致了解到这玩意可以像Socket一样让前后端建立长连接。哎，这就有意思了。如果能像实时聊天一样将前端的BLOB传给后端，后端处理后再将结果回传给前端，那不就可以实现远程执行脚本了吗？而且看上去好像还挺简单的，那就说干就干吧。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>  其实要做很简单，之前不是已经搭建好Selenium Docker环境了吗？只需要在其基础上加上websocketd即可。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">codeonline:    image: selenium-py    command: ./websocketd --ssl --sslcert=/var/www/sl/code.pem --sslkey=/var/www/ssl/code.key bash code/run.sh    restart: always    volumes:      - /home/core/projects/websocketd/release/websocketd:/var/wss/websocketd      - /home/core/data/codeonline/run.sh:/var/wss/code/run.sh      - /home/core/data/codeonline/script:/var/wss/code/script      - /home/core/data/codeonline/tmp:/var/wss/codetmp      - /home/core/data/www/ssl/:/var/www/ssl    networks:      - netwss    depends_on:      - chrome  chrome:    image: selenium/standalone-chrome    container_name: chrome    volumes:      - /dev/shm:/dev/shm    networks:      - netwss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  在原来的基础上加了一些映射关系，而最重要的是Docker启动后会执行<a class="link" href="http://websocketd.com/">Websocketd<i class="fas fa-external-link-alt"></i></a>。</p><p><kbd>websocketd --ssl --sslcert=/var/www/s l/code.pem --sslkey=/var/www/ssl/code.key bash code/run.sh</kbd></p><p>  通过加载SSL证书，开启WSS协议。并且由run.sh接受客户端发来的消息。而为了调试，run.sh只做一件事儿，那就是回显客户端发来的消息。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">while read MSG; do echo $MSG<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  这样就打通了前端与后端的双向数据通道，并且几乎零开发工作量（前端基于bootstrap4 可快速完成自适应布局页面）。后面会再讲到如何将前端的BLOB真正的执行起来，今天就先到这里吧。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/20/Screenshot_20210620_232604_mark.via.jpg" alt="code online"></p>]]></content>
      
      
      <categories>
          
          <category> 云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeMirror </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过滤离群点让特征匹配更精确</title>
      <link href="2021/06/11/210611-%E7%A6%BB%E7%BE%A4%E7%82%B9%E8%BF%87%E6%BB%A4/"/>
      <url>2021/06/11/210611-%E7%A6%BB%E7%BE%A4%E7%82%B9%E8%BF%87%E6%BB%A4/</url>
      
        <content type="html"><![CDATA[<p> &amp;emsp在<a class="link" href="https://www.ray0728.cn/2020/05/27/SIFT+KNN%E5%8A%A0%E6%8C%81%E4%B8%8B%E7%9A%84Android%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/">《SIFT+KNN加持下的Android测试自动化脚本》<i class="fas fa-external-link-alt"></i></a>中介绍了利用特征点来快速匹配图形的方法。但是在实际使用中，特征点匹配的结果可能存在<strong>离群点</strong>，即某些特征点由于受环境的影响会远离大多数匹配上的特征点。下图展示了在Settings界面下特征匹配时出现的离群点（红框处）</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/10/935684c6dea20447da99307b1cdc8a11.md.jpg" alt="离群点"></p><span id="more"></span><p>  如果特征点中存在离群点会给计算图形边界时带来误差。如上图所示，匹配相似度超过80%，也就是说程序可以认为已匹配上图形，而匹配上的边界则需要包含所有特征点，很明显这个范围实际上已超过了真正需要覆盖的范围，那么在这个范围内的所有图形都会被认为是已被识别过，从而导致错误跳过本应该被遍历的控件。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>  既然知道了离群点的影响危害（并不是所有离群点都是有害的，在某些场景下反而是离群点才是有效的数据），那么就需要过滤掉离群点。去除算法有很多，如：MAD、3∑、百分法、LOF以及CLOF算法。这里我采用MAD算法来去除离群值。</p><p>  MAD算法简单的来讲就是将所有点与中位数比较，如果相差大于门限值，则认为该值为离群值。</p><p>  这就好像在一个操场上点名，假设所有人的声音都是一样大，那么你听到的声音约大，则表示这个人离你越近，反之则越远。而你所在的地方就是一个参考位置（中位数）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>  OpenCV读取的图片是以二维数组保存 因此处理时，需要按轴方向进行处理。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def __remove_outlier(points):     median = np.median(points, axis=0)     deviations = abs(points - median)     mad = np.median(deviations, axis=0)     remove_idx = np.where(deviations &gt; mad * Global.MAD_THRESHOLD)     return np.delete(points, remove_idx, axis=0) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  MAD_THRESHOLD是自定义的门限值，这里实际值为1。</p><p>  效果如下图所示：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/10/9ce2d361c0a0fbba9b21a9fb3ddff035.jpg" alt="去除后效果"></p><p>  匹配结果完全符合预期，效果上还是不错的。                              </p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Airtest </tag>
            
            <tag> Python </tag>
            
            <tag> 图像识别 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker + Selenium 自动刷新Gitee静态页面</title>
      <link href="2021/06/03/210603-Docker&amp;Selenium%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0Gitee%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/"/>
      <url>2021/06/03/210603-Docker&amp;Selenium%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0Gitee%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>  之前在<a class="link" href="https://www.ray0728.cn/2020/05/07/Docker%E9%83%A8%E7%BD%B2Hexo%E5%8F%91%E5%B8%83/">《Docker + Git 部署Hexo发布》<i class="fas fa-external-link-alt"></i></a>中留了一个关于页面刷新的小坑，主要针对<a class="link" href="https://gitee.com/help/articles/4136">Gitee 静态页面（免费版）<i class="fas fa-external-link-alt"></i></a>需手动刷新页面这一问题。那么在我们搭建好<a class="link" href="https://www.ray0728.cn/2020/05/21/%E6%90%AD%E5%BB%BASelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">Selenium Docker环境<i class="fas fa-external-link-alt"></i></a>之后就可以开始尝试利用爬虫完成页面的自动刷新了。</p><span id="more"></span><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>  既然是利用爬虫，那首先得弄清楚手工刷新Gitee静态页面的时候，会采取什么样的流程。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/06/03/8045ad636e970a8212e19791853b788c.jpg" alt="流程图"></p><p>  流程并不复杂，简单讲就是登陆Gitee（让浏览器获得登陆后的session），打开设置页面并点击“更新”按钮等待完成即可。唯一需要注意的就是Gitee对频繁更新做了限制，所以需要检查一下是否有“等待60秒”的提示。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>  只需要填入正确的用户名和登录密码即可。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">from selenium import webdriverfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWait as waitfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.common.action_chains import ActionChains as actionimport time, loggingdef initDriver():    driver = webdriver.Remote(        command_executor="http://chrome:4444/wd/hub",        desired_capabilities=DesiredCapabilities.CHROME    )    driver.implicitly_wait(10)    return driverdef close(driver):    driver.close()    driver.quit()    def login(driver, username, passwd):    driver.get("https://gitee.com/login")    wait(driver, 10).until(EC.presence_of_element_located((By.ID,"user_login")))    driver.find_element_by_id('user_login').send_keys(username)    driver.find_element_by_id('user_password').send_keys(passwd)    action(driver).click(driver.find_element_by_name('commit')).perform()    wait(driver, 10).until(EC.presence_of_element_located((By.XPATH, '//a[text()="{}"]'.format(username))))    def reupdate(driver, times):    action(driver).click(driver.find_element_by_xpath('//div[contains(@class, "update_deploy")]')).perform()    wait(driver,10).until(EC.alert_is_present())    alert = driver.switch_to.alert    logging.warning(alert.text)    alert.accept()        try:        if(times == 0):            wait(driver,5).until(EC.visibility_of_element_located((By.XPATH, '//span[text()="pages_deploying"]')))            wait(driver,60).until_not(EC.visibility_of_element_located((By.XPATH, '//span[text()="pages_deploying"]')))        else:            wait(driver,5).until(EC.visibility_of_element_located((By.ID, 'max_1_minute')))            # time.sleep(60)            times = 0    except Exception as e:        etype = repr(e).split('(')[0]        logging.error(etype)        if(etype == 'TimeoutException'):            times += 1    return times    def update(driver, username):    driver.get("https://gitee.com/{}/{}/pages".format(username, username, username))    wait(driver, 10).until(EC.presence_of_element_located((By.XPATH,'//div[contains(@class, "update_deploy")]')))    times = 0    while(times &lt; 3):        times = reupdate(driver, times)        if(times == 0):            breakif __name__ == "__main__":    driver = initDriver()    try:        login(driver, your_username, your_passwd)        update(driver, your_repo_name) # 此处一般都是以username作为仓库名    finally:        close(driver)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  结合之前<a class="link" href="https://www.ray0728.cn/2020/05/21/%E6%90%AD%E5%BB%BASelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/">Docker环境下运行Selenium<i class="fas fa-external-link-alt"></i></a>的方法，将脚本加入对应的run.sh中即可。运行结果如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">********************************************************Waiting for the Chrome server to start on port 4444********************************************************WARNING:root:Are you sure to redeploy Gitee Pages?ERROR:root:TimeoutExceptionWARNING:root:Are you sure to redeploy Gitee Pages?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一键部署-更新"><a href="#一键部署-更新" class="headerlink" title="一键部署+更新"></a>一键部署+更新</h2><p>  <a class="link" href="https://www.ray0728.cn/2020/05/07/Docker%E9%83%A8%E7%BD%B2Hexo%E5%8F%91%E5%B8%83/">《Docker + Git 部署Hexo发布》<i class="fas fa-external-link-alt"></i></a>中提供了一键将Hexo部署到Gitee中的方法，我们在此基础上增加一键更新功能。</p><p>  一共需要用到3个docker，并且需要依序调用，最开始设想通过在Hexo的Git仓库中增加Hook回调，来触发一键更新。但后来发现可以有更简单的方式完成，即用Shell脚本，这样更简单，且非侵入，dockr相互之间无耦合关系。脚本如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#!/bin/shcd /home/core/blog/my-blog/git pullcd /home/core/blog/themes/nextgit pull mygitee mastercd /home/core/blog/themes/ayergit pull mygitee master cd /home/core/docker/hexodocker-compose upcd /home/core/docker/seleniumdocker-compose up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  脚本一开始会从远端仓库中更新日志文件、Hexo主配置文件以及主题文件，然后依次启动Hexo-Docker和Selenium-Docker，完成一键部署和一键更新。</p><p>  <strong>注意：</strong>由于需要docker按顺序依次启动，因此在脚本中docker-compose并未使用<kbd>-d</kbd>参数。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>  在准备填这个坑的时候，才发现之前发布的文章日期都写成了2020。唉，2021已过一半，为啥潜意识里还在留恋2020呢，真是奇怪。算了，也懒得改了，就这样吧。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Docker </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SIFT+KNN加持下的Android测试自动化脚本</title>
      <link href="2020/05/27/200527-SIFT+KNN%E5%8A%A0%E6%8C%81%E4%B8%8B%E7%9A%84Android%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
      <url>2020/05/27/200527-SIFT+KNN%E5%8A%A0%E6%8C%81%E4%B8%8B%E7%9A%84Android%E6%B5%8B%E8%AF%95%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>  在之前的尝试（折腾）中 （参见<a class="link" href="https://www.ray0728.cn/2020/05/09/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E4%B8%8E%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB%E7%9A%84Android%E6%8E%A7%E4%BB%B6%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/">《基于图像识别与位置关系的Android控件遍历方式》<i class="fas fa-external-link-alt"></i></a>），我尝试基于简单的图像比对技术，做了一个<u>没啥用的</u>Android App测试自动化脚本。但是该脚本存在识别率低，耗时长等诸多问题。而用Airtest自带的图像比对功能又极易找错控件（可能是我使用姿势不对）。因此我在Github上搜寻了很久能<strong>快速</strong>完成图像比对的算法。虽然找了很多但是效果却不是特别好，要么超级复杂（完全不知道在干什么），要么耗时非常长（最长的能到10分钟），所幸在Github上搜索的时候了解到不少之前都不曾听过的算法，比如SIFT、SURF等等。行吧，还是自己正面刚吧。</p><span id="more"></span><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>  经过简单的网上自学，大体上选择了<a class="link" href="https://baike.baidu.com/item/SIFT/1396275?fr=aladdin">SIFT<i class="fas fa-external-link-alt"></i></a>、<a class="link" href="https://blog.csdn.net/li528405176/article/details/82422052">ORB<i class="fas fa-external-link-alt"></i></a>以及<a class="link" href="https://blog.csdn.net/lz20120808/article/details/49302373">SURF<i class="fas fa-external-link-alt"></i></a>作为关键点检测算法，并选择<a class="link" href="https://ieeexplore.ieee.org/document/8085676">Flann<i class="fas fa-external-link-alt"></i></a>和<a class="link" href="https://baike.baidu.com/item/BF%E7%AE%97%E6%B3%95">Brute Force<i class="fas fa-external-link-alt"></i></a>作为匹配算法。这些算法具体的工作原理，我也不懂，但是他们组合在一起的工作流程，大致如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/27/pt2021_05_27_12_42_14_mh1622091723979.jpg" alt="流程图"></p><p>  正如上文所述，关键点检测算法和匹配算法并不是唯一的，相互之间也并无固定搭配关系，因此我们根据实际情况选择最适合的算法即可。在脚本<kbd>confidence.py</kbd>中已利用Python实现了相关算法的调用。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def _sift_detect(*imgs):    ...def _orb_detect(*imgs):    ...def _surf_detect(*imgs):    ...def _bf_knn_match(des1, des2, ratio=0.75):    ...def _flann_knn_match(des1, des2, ratio=0.4):    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  具体实现，请点击<a class="link" href="https://gitee.com/ray0728/airtest-support-lib/blob/master/support/app/ui/confidence.py">查看<i class="fas fa-external-link-alt"></i></a>。需要注意的是，参数中的<kbd>ratio</kbd>默认值均为经验值，并非固定值。有了算法的调用，那么剩下的就只需要将算法进行组合即可。组合可参考博文<a class="link" href="https://blog.csdn.net/zhangziju/article/details/79754652">《应用OpenCV和Python进行SIFT算法的实现》<i class="fas fa-external-link-alt"></i></a>（该博文对我启发挺多，特此感谢）。<br>  实际测试下来，发现不同组合方式，算法的耗时差别不大（大约在0.4s至0.7s之间，如果取消掉调试显示，速度还会更快），而实际匹配效果<a class="link" href="https://baike.baidu.com/item/SIFT/1396275?fr=aladdin">SIFT<i class="fas fa-external-link-alt"></i></a> + <a class="link" href="https://baike.baidu.com/item/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/9512781?fr=aladdin">KNN<i class="fas fa-external-link-alt"></i></a>要好很多。</p><h3 id="匹配逻辑"><a href="#匹配逻辑" class="headerlink" title="匹配逻辑"></a>匹配逻辑</h3><p>  在之前我们尝试的遍历逻辑很简单，只要发现有可操作（可点击）控件，则触发点击，然后循环往复。一句话描述那就是<strong>“一点到底”</strong>。虽然很简单粗暴，但是遇到以下情况则会整个人都变得不好了。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/27/pt2021_05_27_14_04_32_mh1622095715856.jpg" alt="无限套娃"></p><p>  我们假设存在这样一个APP，每个界面对外提供的按钮、输入框等人机交互接口均是下一个功能的入口（即发生界面的跳转）。那么我们只要按照二叉树遍历的方式一层一层往下走终会完成所有入口的遍历（<em><strong>这也是为什么之前采用简单粗暴的循环遍历</strong></em>）。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/27/8d87d59f9296017fa290a3aa774ca41a.jpg" alt="二叉树"></p><p>  现在我们进一步假设，如果这些功能入口之间存在联通的情况，那么就由<strong>树</strong>变为了<strong>图</strong>,而且这个图在未完全遍历的情况下，可能存在无限的路径以及虚拟路径（如上图套娃示例，UI上已有明显的变化，但是Activity并无跳转）</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/27/3640cd334ef776323631226547db556d.jpg" alt="图"></p><p>  所以需要引入限制机制，防止<strong>套娃</strong>引起的脚本<strong>“死循环”</strong>。这里引入了测试深度。我们假设发生了“套娃”，对于程序来讲，它会认为实际执行路径如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/27/depth.png" alt="depth"></p><p>  虽然UI上能明显感知到是在A与B之间不停的来回跳转，但是程序却很开心的认为自己发现了好多好多新的界面。如果我们给A与B增加了Depth属性，情况就会变得不太一样。<br>  假设每个控件初始Depth为2，每访问一次则减1，当循环到图中A的Depth为0时，程序就可以以此为依据跳出当前循环，打破“套娃”魔咒。</p><h3 id="比对实现效果"><a href="#比对实现效果" class="headerlink" title="比对实现效果"></a>比对实现效果</h3><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/27/bt-0.4528474807739258.md.png" alt="bt_1"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/27/bt-0.44587159156799316.png" alt="bt_2"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/27/account-0.6140892505645752.md.png" alt="account_1"></p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/27/account-0.5927591323852539.md.png" alt="account_2"></p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>  部分控件匹配不上。目前原因未知，猜测是特征点太少导致无法匹配。后续做针对性的进行分析和优化吧。</p><ul><li>当前发现无法匹配上的图形有：</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/27/Screenshot_20210527_150818.jpg" alt="disable_button"></p><p>代码已归档至<a class="link" href="https://gitee.com/ray0728/airtest-support-lib">Gitee<i class="fas fa-external-link-alt"></i></a></p>]]></content>
      
      
      <categories>
          
          <category> 自动化测试 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Airtest </tag>
            
            <tag> Python </tag>
            
            <tag> 图像识别 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 搭建Selenium执行环境</title>
      <link href="2020/05/21/200521-%E6%90%AD%E5%BB%BASelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/"/>
      <url>2020/05/21/200521-%E6%90%AD%E5%BB%BASelenium%E6%89%A7%E8%A1%8C%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>  如果能用Docker搭建出一套Selenium执行环境，并部署在云端。当我们把脚本上传至云后，可以自动执行脚本（<strong>按需执行</strong>），而脚本执行结束后又能自动退出（<strong>不占用资源</strong>）。让我们小小的云能最大化利用起来，想想就很激动呢。</p><span id="more"></span><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>  首先当然是需要一个具有完整Selenium执行环境的Docker，另外需要一个具有浏览器Driver的Docker环境。为什么不合在一个Docker里面呢？一方面希望Docker尽可能功能独立（<strong>低耦合</strong>），另一方面如果我们自己做Driver的话挺麻烦的（<strong>有现成的</strong>），<u>所以还是分为两个Docker吧</u>🤔。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/22/tmp_pic_1621677533751.png" alt="流程图"></p><p>  差不多如上图所示一个docker为另一个docker提供服务，完成一次网页访问。接下来我们看看这两个docker如何搭建吧。</p><h3 id="Docker-搭建"><a href="#Docker-搭建" class="headerlink" title="Docker 搭建"></a>Docker 搭建</h3><p>  前文提到Driver有现成的docker，那么就先从这里入手吧🤣。</p><p><strong>Driver Docker</strong></p><p>  在Selenium官方<a class="link" href="https://github.com/seleniumHQ/docker-selenium">Github<i class="fas fa-external-link-alt"></i></a>上提供了一系列已封装好的Driver Docker，并至今依然在<strong>持续更新</strong>。相关使用方法可以查看其<a class="link" href="https://github.com/SeleniumHQ/docker-selenium/blob/trunk/README.md">说明<i class="fas fa-external-link-alt"></i></a>，这里就不啰嗦了。简单来讲使用方法如下：</p><ul><li>Firefox<blockquote><p><code>$ docker run -d -p 4444:4444 -v /dev/shm:/dev/shm selenium/standalone-firefox:4.0.0-beta-4-prerelease-20210517</code></p></blockquote></li><li>Chrome<blockquote><p><code>$ docker run -d -p 4444:4444 -v /dev/shm:/dev/shm selenium/standalone-chrome:4.0.0-beta-4-prerelease-20210517</code></p></blockquote></li><li>Edge<blockquote><p><code>$ docker run -d -p 4444:4444 -v /dev/shm:/dev/shm selenium/standalone-edge:4.0.0-beta-4-prerelease-20210517</code></p></blockquote></li></ul><p>  对外暴露4444端口提供Driver服务。所以我们只需要pull对应的docker镜像就好。</p><p><strong>Selenium Docker</strong></p><p>  现在来看看Selenium环境又如何搭建。其实就是选择一个合适的基础镜像（<strong>精简</strong>），在其基础上安装好必须的软件即可。通过在DockerHub上选择合适的<a class="link" href="https://registry.hub.docker.com/_/python">官方镜像<i class="fas fa-external-link-alt"></i></a>（<strong>Python</strong>），然后安装常用爬虫库。Dockerfile如下：</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">FROM python:3.9.5WORKDIR /home/codeRUN pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/ \    &amp;&amp; pip install selenium requests lxml beautifulsup4 pymysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  至此我们就完成了所需Docker的搭建。再来看看如何让他们配合执行。</p><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p>  需要用到我们的老朋友docker-compose😀。将脚本映射进我们的Selenium容器，并联通Driver容器。来看看docker-compose.yml怎么写的呢。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">version: "3"services:  spider:    image: selenium-py    volumes:      - /home/core/data/python:/home/code/    command: python your_script.py    depends_on:      - chrome  chrome:    image: selenium/standalone-chrome    container_name: chrome    volumes:      - /dev/shm:/dev/shm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  是不是超级简单？docker运行时就会去执行<code>python your_script.py</code>，执行完之后就会退出。看上去好完美！而且没有对外暴露任何端口，好安全！来看看这个<kbd>your_script.py</kbd>怎么写呢。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">from selenium import webdriverfrom selenium.webdriver.common.desired_capabilitiesmport DesiredCapabilitiesdriver = webdriver.Remote(    command_executor="http://chrome:4444/wd/hub",    desired_capabilities=DesiredCapabilities.CHROME)driver.get("https://www.ray0728.cn")print(driver.title)driver.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <code>http://chrome:4444/wd/hub</code>中的chrome是Driver Docker的容器名，在docker-compose.yml中有特别的指定。而执行结果可以通过<code>docker-compose logs -f spider</code>进行查看。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li>连接Driver失败</li></ol><p>  Chrome Docker将Chrome运行起来是需要时间的，注意并不是容器运行起来就行了，毕竟Docker只是容器（可以理解为轻量级的虚拟机），服务是容器中的应用程序，就像我们不会认为系统开机，就是后台服务开始运行了。因此我们最好等到Driver开始提供服务后再执行脚本，那么怎么做呢？答案很简单，通过不停的去探测Driver docker对外提供服务的端口是否可用，来判断服务是否被拉起。这里我们用<a class="link" href="https://baike.baidu.com/item/Netcat/9952751">NetCat<i class="fas fa-external-link-alt"></i></a>工具。可是NC工具不一定是每个Linux发行版本，所以加在Dockerfile里，重新构建一个带有nc的Selenium Docker。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">FROM python:3.9.5WORKDIR /home/codeADD sources.list /etc/apt/RUN apt update \    &amp;&amp; apt install -y netcat-openbsd \    &amp;&amp; pip config set global.index-url https://mirrors.liyun.com/pypi/simple/ \    &amp;&amp; pip install selenium requests lxml beautifulsup4 pymysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  选取的Python镜像是以Debian为基础，sources.list是提前准备好的国内apt源。</p><p>  在调用your_script.py之前先用nc判断Driver是否准备好，所以重新调整下docker-compose.yml。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">version: "3"services:  spider:    image: selenium-py    volumes:      - /home/core/data/python:/home/code/    command: run.sh    depends_on:      - chrome  chrome:    image: selenium/standalone-chrome    container_name: chrome    volumes:      - /dev/shm:/dev/shm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  与之前的区别就在于用run.sh代替了直接调用script。这样就可以将nc调用放在run.sh当中了。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#!/bin/bashwhile ! `nc -z chrome 4444`; do sleep 3; donepython your_script.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>Driver Docker不退出</li></ol><p>  Selenium Docker执行完脚本后就会自动退出（无其他执行任务）。但是Driver Docker本身就是提供持续服务，因此并不会因为Selenium Docker退出而退出。怎么才能让Driver Docker知道Selenium退出了呢？方法有两种。</p><ul><li>参考通过nc判断服务端口是否下线来推断Docker是否停止</li></ul><p>  但是Driver Docker并不是我们自己构建的，而且暂时也不打算以其为基础做二次封装（懒）。所以我们无法加入nc判断逻辑，该方案先搁置吧。</p><ul><li>通过sock通知</li></ul><p>  这里就需要知道一个关于<a class="link" href="https://docs.docker.com/engine/reference/commandline/dockerd/#examples">Docker Sock<i class="fas fa-external-link-alt"></i></a>的背景知识了。简单来说通过Unix Domain Socket可以让Docker相互之间通信，而通信需符合<a class="link" href="https://docs.docker.com/engine/api/v1.41/">API<i class="fas fa-external-link-alt"></i></a>规范。我们需要的STOP规范如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/22/Screenshot_20210522_220444_com.huawei.browser_edit_409959695004111.jpg" alt="stop api"></p><p>  按照API所描述的方法，将停止命令加在run.sh最后。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">#!/bin/bashwhile ! `nc -z chrome 4444`; do sleep 3; donepython test.pycurl -s --unix-socket /var/run/docker.sock -X POST htp://localhost/containers/chrome/stop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  并将主机/var/run/docker.sock映射给Selenium Docker。在docker-compose.yml中加入</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">docker-compose.ymlversion: "3"services:  spider:    image: selenium-py    volumes:      - /home/core/data/python:/home/code/      - /var/run/docker.sock:/var/run/docker.sock    command: /home/code/run.sh    depends_on:      - chrome  chrome:    image: selenium/standalone-chrome    container_name: chrome    volumes:      - /dev/shm:/dev/shm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  至此Selenium Docker运行完成后就会通知Driver Docker退出。完全满足本文开头所描述的需求。😎</p><h3 id="引申"><a href="#引申" class="headerlink" title="引申"></a>引申</h3><p>  本文最后通过sock向Docker Deamon发送命令，从而实现所需要的功能。但是有两点需要特别注意。</p><ul><li><p>并不能按照API文档中的参数直接向Docker Deamon发送命令，而是需要将部分特殊字符（如 [{:）转换为html字符，然后再发送给sock。</p></li><li><p>不要将docker.sock暴露给外部，因为有安全隐患，毕竟Docker Deamon只要收到符合API规范的字符串就会触发对应的操作（包括停止、删除容器等）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Docker </tag>
            
            <tag> Selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动遍历UI控件</title>
      <link href="2020/05/16/200516-%E8%87%AA%E5%8A%A8%E9%81%8D%E5%8E%86UI%E6%8E%A7%E4%BB%B6/"/>
      <url>2020/05/16/200516-%E8%87%AA%E5%8A%A8%E9%81%8D%E5%8E%86UI%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><video width="320" height="240" controls="" autoplay="">  <source src="http://pan.ray0728.cn/s/AE8RsZ8FG9gGCbw/download/%E8%87%AA%E5%8A%A8%E7%88%AC%E5%8F%96UI%E7%95%8C%E9%9D%A2.mp4" type="video/mp4">浏览器不支持 video 标签。  </video><p>  为了实现<strong>测试自动化</strong>这一“伪命题”，经过不懈的努力（<em>折腾</em>），终于基于Airtest（其实关联倒也没那么大）做出来有那么一点意思的自动化脚本。</p><span id="more"></span><pre class="line-numbers language-py" data-language="py"><code class="language-py">import logginglogging.getLogger("airtest").setLevel(logging.ERROR)from airtest.core.api import *import syssys.path.append(".")from support.app.manager import AppManagerauto_setup(__file__)am = AppManager('com.android.settings', os.path.join(os.path.dirname(os.path.realpath(__file__)), 'snap'), os.path.join(os.path.dirname(os.path.realpath(__file__)), 'exempt'))am.stop()am.start()am.uiCrawl()am.stop()am.clear()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  这是调用脚本，只需要传入PackageName就行了。剩下的就交给<code>AppManager.uiCrawl()</code>完成。</p><h3 id="遍历思路"><a href="#遍历思路" class="headerlink" title="遍历思路"></a>遍历思路</h3><p>  在以前研究（<em>折腾</em>）成果的基础上，叠加了更多的逻辑判断（允许我叉会儿腰），大致流程如下图所示。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/15/Untitled-Diagram.png" alt="流程图"></p><p>  以区域查找（<a class="link" href="https://ray0728.gitee.io/2020/05/09/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E4%B8%8E%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB%E7%9A%84Android%E6%8E%A7%E4%BB%B6%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/">基于图像识别与位置关系的Android控件遍历方式<i class="fas fa-external-link-alt"></i></a>）为主要逻辑，同时以检测Activity堆栈信息为辅助，实现自动搜寻未访问过的控件以及自动从别的App跳转回待测App。</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p><strong>1. 如何在当前界面上匹配图形</strong></p><p>  利用Opencv做图形匹配在之前的博文中已有<a class="link" href="https://ray0728.gitee.io/2020/05/03/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%9A%84Android%E6%8E%A7%E4%BB%B6%E5%85%83%E7%B4%A0%E9%81%8D%E5%8E%86/">分享<i class="fas fa-external-link-alt"></i></a>，这里就不过多赘叙。但是很可能出现希望搜索的控件图形并不在当前屏幕显示范围内，即需要上下左右滑动屏幕才会出现的控件，如：提交按钮一般都在填完大量信息之后才会出现，因此需要将屏幕滑动到底。如何判断屏幕滑到尽头了呢？</p><p>  从代码上判断吗？就算能捕获到ScrollView控件，并获取其当前值和最大值就能判断是否到达底部了吗？实际情况可能未必。有大量信息浏览类App采用滑动的方式代替了过去的翻页操作，体现在用户体验上就是用户只需要不停的将屏幕滑动到底部，就会自动加载下一页的内容。</p><p>  从用户的角度去思考呢？我们潜意识中判断是否还可以再滑动，其实是以当前屏幕在滑动以后有没有新东西出现做依据的，有，则可继续滑动。没有，则已经到头了。有了解决思路就可以转换成代码了。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def screen_match(last, current, confidence = 0.8):     if(last is None or current is None):         return False         img1 = cv2.resize(last, (256,256))         img2 = cv2.resize(current, (256,256))        sub_image1 = cv2.split(img1)         sub_image2 = cv2.split(img2)         sub_data = 0         for im1, im2 in zip(sub_image1, sub_image2):             sub_data += UIConfidence.calculate(im1, im2)             sub_data = sub_data / 3             print('screen_match:{}'.format(sub_data))             if(type(sub_data) is float):                 return sub_data &gt; confidence             else:                 return sub_data[0] &gt; confidence<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  通过对比两幅屏幕截图的三通道（BGR）各自的差值来判断两幅屏幕截图的相似度，如果大于阈值（默认80%），则认为屏幕相同。<strong>这里的80%是一个经验值，需要根据实际情况做些调整</strong>。</p><p>  有了屏幕对比，接下来就是在滑动前后各做一次屏幕截图，并对比截图相似度即可。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def _swipedTo(self, dir):    while(True):        screen = self._saveSnapScreen()        if(screen is None):            break        self.poco.swipe([0, 0.5], direction=dir)        sleep(5)        if(uic.screen_match(screen, self._saveSnapScreen())):            break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  为了让屏幕截图尽可能稳定，因此滑动后sleep(5)。</p><p><strong>2.跳转判断</strong></p><p>  现在App之间存在各种的跳转，当然能理解这种导流的方式（其实和早期PC时代，网站间交换链接的情况是类似的），但是我们的脚本可就理解不了这种情况了。当点击了某个按钮之后跳转到另一个App，脚本呢？还傻乎乎的继续遍历（人工智障）。这样有什么不好吗？当然不好！从测试的角度讲，我们不希望测试的范围无限扩大，从项目管理的角度讲这叫<strong>范围蔓延</strong>。要及时纠正这样的错误，就需要在必要的时候检测有没有跳转发生。</p><p>  幸运的是Android对于已显示的Activity有着相当成熟的管理机制，我们可以简单理解为FILO（First-In/Last-Out），如果我们能获取到当前Activity堆栈最顶层的Activity就可以判断是否发生了App跳转。而dump可以提供相关的信息。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def getCurrentPageName(self):    ret = shell("dumpsys activity | grep \"Run #\"")    lines = ret.split('\n')    emt = lines[0].strip().split(' ')    return emt[4].split('/')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  有了这样的判断，我们可以进一步获取当前是否还有需要遍历的Activity，并以此作为程序退出的条件（在流程图中已标注）。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def hasAnyActivity(self):    ret = shell("dumpsys activity | grep \"Run #\" | grep \"{}\"".format(self.pkg))    print(ret)    return len(ret.split('\n'))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  <em>可气的是，这个逻辑判断目前还有问题，它工作起来像是一个固执且愚蠢的小可爱</em></p><h3 id="遗憾"><a href="#遗憾" class="headerlink" title="遗憾"></a>遗憾</h3><p>  1. 本人对Python理解不深刻，代码中充满了智障的写法，也没有将Python优美的语法体现在代码当中，所以整个代码显得臃肿不堪。</p><p>  2. 还有很多需要优化的地方，目前运行效率并不高。</p><p>  3. 虽然获取了控件可操作属性（可点击、可长按、可编辑），但是却并没有充分使用。这就像一个测试人员将App所有界面看了一遍，却不知道哪里有错，哪里需要改进，简单来讲就是没啥用。</p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>  进一步优化逻辑判断，简化操作步骤。并将检测方式融入脚本当中，这样才可以让脚本在业务上发挥真正的作用。</p><p>仓库在<a class="link" href="https://gitee.com/ray0728/airtest-support-lib">Gitee<i class="fas fa-external-link-alt"></i></a>并持续更新。</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Airtest </tag>
            
            <tag> Python </tag>
            
            <tag> 图像识别 </tag>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于图像识别与位置关系的Android控件遍历方式</title>
      <link href="2020/05/09/200509-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E4%B8%8E%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB%E7%9A%84Android%E6%8E%A7%E4%BB%B6%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/"/>
      <url>2020/05/09/200509-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E4%B8%8E%E4%BD%8D%E7%BD%AE%E5%85%B3%E7%B3%BB%E7%9A%84Android%E6%8E%A7%E4%BB%B6%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  在<a class="link" href="https://ray0728.gitee.io/2020/05/03/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%9A%84Android%E6%8E%A7%E4%BB%B6%E5%85%83%E7%B4%A0%E9%81%8D%E5%8E%86/">《基于图像识别的Android控件遍历》<i class="fas fa-external-link-alt"></i></a>中描述了一种根据控件区域截图来遍历UI控件的方法，但是这种方法存在很大的缺陷，即无法准确区分相似度很大控件，如下图中的桌面壁纸、显示亮度与移动网络。<br><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/08/Screenshot_20210505_103757_com.android.settings_edit_56532789152822052830719968f71.jpg" alt="设置界面"></p><p>  要提高准确度就需要引入更多的判断条件。这里尝试引入位置关系，来辅助识别。</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>  UI上所有的控件都是以布局（特指界面绘制布局）的方式呈现出来的，而目前Android应用普遍以<strong>上下结构</strong>（即从上往下滑动为主，如：新闻阅读类App）或<strong>左右结构</strong>（即左右滑动为主，如：图片处理类App）为主（图层重叠类的暂不考虑，后续增加处理方式）。那么控件彼此间的位置是存在相互关系的，如上下或左右关系。当我们依次遍历控件时，一定是从根节点向子节点遍历，而对应到这两种结构上来说，我们一定是按从左到右或从上到下的顺序在遍历。有了这个结论，就可以进一步假设，如果我们获取到某个控件，其位置相对于我们已知控件的位置更靠左或上方，那么这个控件就是我们已遍历过的。<br>  对于静态的界面判断控件间相对位置非常简单，只需要判断坐标关系即可。<br><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/09/RCS20210509135511.png" alt="位置关系"></p><p>  上图展示了除重叠以外，控件与控件所有可能的位置关系。从中间Z控件出发，先看看其余控件与其位置关系（假设左上坐标表示为x<sub>0</sub>,y<sub>0</sub>，右下坐标表示为x<sub>1</sub>,y<sub>1</sub>。<em>Andorid系统以屏幕左上为原点，x轴向右逐步增大，y轴向下逐步增大。</em>）</p><ul><li>z与a：<strong>x<sub>z0</sub> &gt; x<sub>a1</sub>; y<sub>z0</sub> &gt; y<sub>a1</sub></strong></li><li>z与b： <strong>y<sub>z0</sub> &gt; y<sub>b1</sub></strong></li><li>z与c：<strong>x<sub>z1</sub> &lt; x<sub>c0</sub>; y<sub>z0</sub> &gt; y<sub>c1</sub></strong></li><li>z与d：<strong>x<sub>z0</sub> &gt; x<sub>d1</sub></strong></li><li>z与e：<strong>x<sub>z1</sub> &lt; x<sub>e0</sub></strong></li><li>z与f：<strong>x<sub>z0</sub> &gt; x<sub>f1</sub>; y<sub>z1</sub> &lt; y<sub>f0</sub></strong></li><li>z与g：<strong>y<sub>z1</sub> &lt; y<sub>g0</sub></strong></li><li>z与h：<strong>x<sub>z1</sub> &lt; x<sub>h0</sub>; y<sub>z1</sub> &lt; y<sub>h0</sub></strong><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2>  从上面可以看出一定的规律，只要满足任意一条关系，则可以找到其对应的位置关系（<em>紧挨着的情况未考虑，即某一个坐标相等的情况</em>）。从另一个角度讲，如果不满足以上关系的坐标，那么一定是<strong>相互重叠</strong>的关系。<br>  转换为代码<pre class="line-numbers language-py" data-language="py"><code class="language-py">def isOverlap(x,y,w,h,x1,y1,w1,h1):     return ((y1 + h1) &gt; y) and ((y + h) &gt; y1) and ((x1 + w1) &gt; x) and ((x + w) &gt; x1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>x,   y是左上角坐标</li><li>w,  h是长宽，用来计算右下角坐标</li></ul><p>  为什么我们需要计算是否重叠呢？在<a class="link" href="https://ray0728.gitee.io/2020/05/03/%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%9A%84Android%E6%8E%A7%E4%BB%B6%E5%85%83%E7%B4%A0%E9%81%8D%E5%8E%86/">《基于图像识别的Android控件遍历》<i class="fas fa-external-link-alt"></i></a>中我采用的方法是控件区域截图后与之前的截图进行对比，如果相似则说明是同一个控件。这种方法存在一个缺陷，在开头时已提到。有了<strong>重叠</strong>判断方法，我们可以对之前的逻辑进行改进。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">for item in freeze().offspring():   attrs = self.getUseableAttrs(item)       if(attrs):          width = item.attr('size')[0] * screen_width          height = item.attr('size')[1] * screen_height          anchorX = item.attr('anchorPoint')[0] * width          anchorY = item.attr('anchorPoint')[1] * height          x0 = (item.attr('pos')[0] * screen_width) - anchorX          y0 = (item.attr('pos')[1] * screen_height) - anchorY          if(x0 &lt; 0 or y0 &lt; 0 or (y0 + height) &lt; last_py):             continue          if(last_width &gt; 0 and uic.isOverlap(last_px, last_py, last_width, last_height, x0, y0, width, height)):              continue           last_px = x0           last_py = y0           last_width = width           last_height = height           path = self.__saveCropScreen(screen, x0, y0, width, height, page, index)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  这样截图的区域一定是不重复且未遍历到的控件。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">width = item.attr('size')[0] * screen_widthheight = item.attr('size')[1] * screen_heightanchorX = item.attr('anchorPoint')[0] * widthanchorY = item.attr('anchorPoint')[1] * heightx0 = (item.attr('pos')[0] * screen_width) - anchorXy0 = (item.attr('pos')[1] * screen_height) - anchorY<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  这段代码是将控件的相对坐标转换为绝对坐标。<strong>Airtest通过属性获取到均是相对坐标</strong>，而截图需要的是屏幕绝对坐标，因此需要转换。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">if(x0 &lt; 0 or y0 &lt; 0 or (y0 + height) &lt; last_py):   continueif(last_width &gt; 0 and uic.isOverlap(last_px, last_py, last_width, last_height, x0, y0, width, height)):   continue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  有了统一的绝对坐标，就可以做坐标对比了，如果坐标在屏幕外或控件上方则认为是已遍历过控件。同样如果是重叠的，则认为是同一个控件。然后我们就可以做区域控件截图了。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def __saveCropScreen(self, screen, x, y, width, height, page, index):    cropscreen = aircv.crop_image(screen, [x,y,x+width,y+height])    path = self.datapath    for dir in page.split('-'):        path = os.path.join(path, dir)    if(not os.path.exists(path)):        os.makedirs(path)    path = os.path.join(path, '{}.jpg'.format(index))    aircv.imwrite(path, cropscreen, ST.SNAPSHOT_QUALITY, ST.IMAGE_MAXSIZE)    return path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  当把当前屏幕的控件遍历完之后，就需要上下或左右滑动一下以判断是否还存在新的控件。但是滑动幅度过大，可能把未遍历到的控件滑过，滑动幅度过小，又可能无法显示足够多的区域来显示下一个控件。因此我们每次滑动仅从最后一个控件开始滑动最后一个控件高度。<u>但实际上这个距离是一个经验值，可能需要根据不同的应用做不一样的调整。</u></p><pre class="line-numbers language-py" data-language="py"><code class="language-py">self.poco.swipe([last_px/screen_width, last_py/screen_height], direction=[0, -last_height/screen_height])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  滑动之后需要用已发现最后一个控件的截图去新的屏幕上寻找其定位点，并以此更新<mark>last_px, last_py</mark>，以及一系列与最后一个控件相关的属性值。并像之前做过的那样，去判断新的控件相对于<mark>last控件</mark>的坐标关系。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">screen = G.DEVICE.snapshot(os.path.join(self.datapath, page,"snap.png"))if(last_path is not None):   pos = uic.air_match_in(last_path, screen)   if(pos is not None):      last_px = pos[0] - last_width * 0.5      last_py = pos[1] - last_height * 0.5   else:      last_px = 0      last_py = 0      last_width = 0      last_height = 0      if(last_px &lt; 0):         last_px = 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <kbd>air_match_in</kbd>是基于Airtest封装的区域图片查找函数。代码如下：</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def air_match_in(srcpath, screen):   template = Template(srcpath)   return template.match_in(screen)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>  那么什么时间结束遍历呢？当程序再也找不到新的控件时就可以了，为了防止某些特殊情况发生，可以再连续两次滑动后，均无新增控件发现再退出。完整代码如下：</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">from .confidence import UIConfidence as uicfrom airtest.core.api import *from airtest.aircv import *import osclass UIManager:    def __init__(self, poco, datapath):        self.poco = poco        self.datapath = datapath        self.MAX_NOT_FOUND_TIMES = 2        if(not os.path.exists(datapath)):            os.makedirs(datapath)    def getUseableAttrs(self, item):        attrsArray = []        if(item.attr('touchable')):            attrsArray.append('touchable')        if(item.attr('touchable')):            attrsArray.append('touchable')        if(item.attr('editalbe')):            attrsArray.append('editalbe')        return attrsArray    def __getScreenSize(self):        width = G.DEVICE.display_info['width']        height = G.DEVICE.display_info['height']        if(height &gt; width):            return width,height        return height,width    def __saveCropScreen(self, screen, x, y, width, height, page, index):        cropscreen = aircv.crop_image(screen, [x,y,x+width,y+height])        path = self.datapath        for dir in page.split('-'):            path = os.path.join(path, dir)        if(not os.path.exists(path)):            os.makedirs(path)        path = os.path.join(path, '{}.jpg'.format(index))        aircv.imwrite(path, cropscreen, ST.SNAPSHOT_QUALITY, ST.IMAGE_MAXSIZE)        return path        def parseLayout(self, page):        index = 1        last_px = 0        last_py = 0        last_width = 0        last_height = 0        last_path = None        screen_width, screen_height = self.__getScreenSize()        newItem = 0        not_found_times = 0        while(not_found_times &lt; self.MAX_NOT_FOUND_TIMES):            sleep(5)            newItem = 0            freeze = self.poco.freeze()            if(not os.path.exists(os.path.join(self.datapath, page))):                os.makedirs(os.path.join(self.datapath, page))            screen = G.DEVICE.snapshot(os.path.join(self.datapath, page,"snap.png"))            if(last_path is not None):                pos = uic.air_match_in(last_path, screen)                if(pos is not None):                    print('match in', pos, last_px, last_py, last_width, last_height)                    last_px = pos[0] - last_width * 0.5                    last_py = pos[1] - last_height * 0.5                else:                    last_px = 0                    last_py = 0                    last_width = 0                    last_height = 0                if(last_px &lt; 0):                    last_px = 0            for item in freeze().offspring():                attrs = self.getUseableAttrs(item)                if(attrs):                    width = item.attr('size')[0] * screen_width                    height = item.attr('size')[1] * screen_height                    if(width == 0 or height == 0):                        continue                    anchorX = item.attr('anchorPoint')[0] * width                    anchorY = item.attr('anchorPoint')[1] * height                    x0 = (item.attr('pos')[0] * screen_width) - anchorX                    y0 = (item.attr('pos')[1] * screen_height) - anchorY                    if(x0 &lt; 0 or y0 &lt; 0 or (y0 + height) &lt; last_py):                        continue                    if(last_width &gt; 0 and uic.isOverlap(last_px, last_py, last_width, last_height, x0, y0, width, height)):                        continue                    last_px = x0                    last_py = y0                    last_width = width                    last_height = height                    path = self.__saveCropScreen(screen, x0, y0, width, height, page, index)                    last_path = path                    not_found_times = -1                    # TODO 递归处理                    index += 1            if(not_found_times == -1):                not_found_times = 0            else:                not_found_times += )            self.poco.swipe([last_px/screen_width, last_py/screen_height], direction=[0, -last_height/screen_height])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  外部调用时，只需要调用<kbd>parseLayout</kbd>即可，代码中存在<kbd>TODO</kbd>，还缺少了递归遍历的处理部分，后续会继续更新相关代码。代码已归档至<a href="!https://gitee.com/ray0728/airtest-support-lib/tree/master">Gitee 代码仓库</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Airtest </tag>
            
            <tag> Python </tag>
            
            <tag> 图像识别 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker + Git 部署Hexo发布</title>
      <link href="2020/05/07/200507-Docker%E9%83%A8%E7%BD%B2Hexo%E5%8F%91%E5%B8%83/"/>
      <url>2020/05/07/200507-Docker%E9%83%A8%E7%BD%B2Hexo%E5%8F%91%E5%B8%83/</url>
      
        <content type="html"><![CDATA[<p>  现在各代码托管平台均提供了静态页面展示功能，可以利用其搭建自己的个人博客。而这样的好处有：</p><ol><li>不用自建服务器</li><li>不用网络备案</li><li>文档归档管理</li><li>自主选择主题</li></ol><p>  当然也有它的不足：</p><ol><li>域名需按照特定的格式设置</li><li>有诸多限制（如需自行寻找图床搭配使用）</li></ol><p>  不过总的来说作为个人博客基本够用了，关键是免费呢。</p><span id="more"></span><h2 id="诉求"><a href="#诉求" class="headerlink" title="诉求"></a>诉求</h2><p>  如果为了向博客发布文章，还需要投入专门的时间在电脑上操作，甚至要部署一套Hexo环境的话，那么在时间碎片化严重的今天将显得非常的不实用。因此我们可以考虑利用docker，封装一套hexo环境。让其支持自动发布功能，并根据实际情况部署在云或个人电脑上（通过简单的脚本实现一键部署）。这样主要的精力就可以投入在内容创作上，充分利用各种碎片时间。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>  大致设计了一下，期望中应该有两条业务流。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/08/RCS20210507185144d0fc77fd6d8df521.png" alt="业务流设计"></p><ul><li><strong>文章编辑流</strong><br>该业务流重点关注碎片化编写的内容可实时保存，最好有云端存储，这样方便在任何时候、任何地点、任何环境下都可继续编写。</li><li><strong>文章发布流</strong><br>该业务流重点关注快速发布，且不受主机环境影响。</li></ul><h2 id="部分实现"><a href="#部分实现" class="headerlink" title="部分实现"></a>部分实现</h2><p>  本文仅针对日志发布业务流中，一键发布至Git仓库做详细描述。以下选择的是Gitee平台，相比较GitHub，除了不支持自动刷新页面以外，Gitee具有<strong>国内更快访问速度</strong>这一决定性的优势，想想看，如果打开你的博客需要2分钟才加载完成，又会有多少人愿意等待这2分钟呢？<br>  首先在<kbd>Hexo配置文件(_config.yml)</kbd>中配置好deploy的仓库地址，建议选择SSH方式部署，这样可以做到免登陆验证。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">deploy:  type: git  repo: git@gitee.com:yourname/yourname.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>  利用SSH上传的好处是可以免登陆，减少与用户的交互输入，但是缺点是首次上传时需要手动输入yes。后面我们也会提到这一问题。当然其余需要配置的信息，如：标题、主题、目录结构等等信息，若有需要也请一并在<kbd>Hexo主配置文件</kbd>中修改或添加，这里就不详细描述了。关于Hexo配置信息，请参考<a href="!https://hexo.io/zh-cn/docs/configuration">这里</a>。</p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>  这里不再描述如何搭建Docker环境，相信在网上能找到很多相关的指导，下面详细介绍如何构建<strong>支持自动发布Hexo的Docker镜像</strong>。我们的目的很明确，这个镜像不需要做特别复杂的工作，只需要有node、ssh、hexo即可，因此选择以alpine作为基础镜像环境，因为它足够小。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">FROM node:14-alpineWORKDIR /var/www/hexoRUN echo "Asia/Shanghai" &gt; /etc/timezone \    &amp;&amp; echo "https://mirrors.aliyun.com/alpine/v3.9/main/" &gt; /etc/apk/repositories  \    &amp;&amp; npm config set registry https://registry.npm.taobao.org \    &amp;&amp; apk add --no-cache git \    &amp;&amp; apk add --no-cache openssh-client \    &amp;&amp; npm install hexo-cli -g \    &amp;&amp; hexo init \    &amp;&amp; npm install hexo-renderer-swig \    &amp;&amp; npm install \    &amp;&amp; npm install hexo-deployer-git --save \    &amp;&amp; rm -rf source themes \    &amp;&amp; git config --global user.email "yourname@yourmail" \    &amp;&amp; git config --global user.name "yourname" \    &amp;&amp; ssh-keygen -t RSA -C "hexo@docker.com" -P "" -N "" -f /root/.ssh/id_rsa \    &amp;&amp; echo "StrictHostKeyChecking no" &gt;&gt; /etc/ssh/ssh_config \    &amp;&amp; cat /root/.ssh/id_rsa.pubADD themes ./themesADD _config.yml ./<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  <kbd>WORKDIR</kbd>指明后以后该镜像在运行的时候所使用的工作目录，hexo环境以及日志目录都将在这里。然后依次安装git、openssh(<strong>不需要SSH服务端</strong>)、hexo以及hexo发布插件。这里我使用的主题是Next 5，而最新的hexo移除了swing，所以多安装了<kbd>hexo-renderer-swig</kbd>，<em>可根据自己的需要增删软件</em>。</p><blockquote><p>rm -rf source themes</p></blockquote><p>  从hexo环境中移除source以及thems，因为我们需要用自己的文章以及主题环境去替代默认生成的内容。<br>  在完成<kbd>hexo init</kbd>以及各种软件安装之后，还需要对环境做相关的初始化，初始化动作确实可以放在container之后再做，而不需要在镜像中完成，但是前文提到希望使用SSH进行文章发布，而container并不能保证每次container中生成的公私钥都一样（当然确保每次使用同一个container的话也不是不行，但是为了确保发布的准确性，就需要首先使用<kbd>hexo clean</kbd>再进行编译，或者使用<kbd>hexo g -f -d</kbd>)，所以为了方便以后的工作，我们需要将ssh的公私钥固定下来。初始化的动作主要有：</p><ul><li>初始化git配置</li><li>初始化RSA公私钥<blockquote><p>echo “StrictHostKeyChecking no” &gt;&gt; /etc/ssh/ssh_config </p></blockquote></li></ul><p>  这步很关键，它可以让SSH首次连接时跳过检查，即不要求与用户交互。这样可以确保首次执行<kbd>hexo g -d</kbd>时不会要求输入yes。</p><blockquote><p>ADD themes ./themes<br> ADD _config.yml ./</p></blockquote><p>  使用修改好的<kbd>hexo 主配置文件</kbd>以及主题内容。其实在实际业务中，主题配置可能发生变化，因此这里即便不拷贝主题也没有关系，在后面将展示通过参数的形式动态指定主题。<br>  至此Docker构造脚本准备好了，将上述内容保存为<kbd>Dockerfile</kbd>，并执行Docker build。根据网络情况，稍等一段时间即可完成构建。在构建的输出中一定发现打印出了一段长长的Base64代码。如：</p><pre class="line-numbers language-none"><code class="language-none">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@xxx.xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  请记下这段代码，后续要用到。这段代码是Dockerfile中打印的</p><blockquote><p>cat /root/.ssh/id_rsa.pub</p></blockquote><p>  这段代码即是SSH公钥，请根据静态页面供应商的帮助，将公钥添加进仓库的SSH公钥管理当中，如Gitee中的<a class="link" href="https://gitee.com/help/articles/4191">相关帮助<i class="fas fa-external-link-alt"></i></a>，GitHub的添加方式大同小异。<br>  好了，到这里我们有了一个hexo环境的docker，下面介绍如何使用这个docker。</p><h3 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h3><p>  其实并不是一定要用docker-compose, 只使用docker也可以达到类似的效果。在这个场景下使用docker-compose唯一的好处是，不需要手工输入太多的参数。</p><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">hexo:  image: your-docker-name  volumes:    - /your-hexo/source:/var/www/hexo/source    - /your-hexo/themes:/var/www/hexo/themes  command: hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  简单来讲就是将source、themes动态挂载至container 对应的目录上。然后执行hexo发布命令即可。上面也讲到其实可以用docker命令代替，那么代替的命令如下：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker run --rm -v /your-hexo/source:/var/www/hexo/source -v /your-hexo/themes:/var/www/hexo/themes hexo-git hexo g -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  <kbd>--rm</kbd>是指当container退出后自动销毁。如果不希望container销毁，那么请勿使用该参数。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>  现在剩下的最后一个问题是，这个docker应该部署在什么地方。这个就看自己的环境以及习惯吧，可以放在私人云ECS上，也可放在家里的电脑上，需要用的时候执行一下<kbd>docker-compose up</kbd>或者上面的docker命令即可。当然这仅仅是最初规划两条业务流中很小的一部分。剩下的以后再慢慢补充和完善吧。至少目前可满足我一小部分的需求了。</p>]]></content>
      
      
      <categories>
          
          <category> 云 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Git </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于图像识别的Android控件遍历</title>
      <link href="2020/05/03/200503-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%9A%84Android%E6%8E%A7%E4%BB%B6%E5%85%83%E7%B4%A0%E9%81%8D%E5%8E%86/"/>
      <url>2020/05/03/200503-%E5%9F%BA%E4%BA%8E%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB%E7%9A%84Android%E6%8E%A7%E4%BB%B6%E5%85%83%E7%B4%A0%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>  在追求测试自动化的道路上，我想让脚本具有一定的自适应能力，能自主识别出可操作（可点击、可长按、可编辑）的控件，并能自主控制脚本运行逻辑（依据策略自适应）。<br>  能识别出可操作控件则是这一目标的第一步。Airtest使用的POCO具有获取控件属性的作用，同时Airtest封装Opencv用于图像识别。因此这是一个实现该目标较理想的平台。</p><h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><p>  Android界面无论采用何种布局，都可以理解为是以图层的原理，逐层叠加出来的。所以利用POCO获取子节点的方法，从根节点开始依次遍历其所有子节点以及子节点的子节点（孙节点），并保留可操作（可点击、可长按、可编辑）的节点。如此即可获得想要的控件列表。</p><span id="more"></span><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>  首先利用Airtest的截图功能<code>G.DEVICE.snapshot</code>获取当前屏幕截图（已启动需遍历的app）。然后通过<code>offspring</code>获取所有子节点，为了加速遍历速度，我们使用<code>freeze()</code>将界面元素冻结，以加速子节点的遍历。<br>  拿到子节点后通过获取其属性判断是否具有可操作性，在poco中获取属性方式很简单，通过attr即可。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def getUseableAttrs(self, item):        attrsArray = []        if(item.attr('touchable')):            attrsArray.append('touchable')        if(item.attr('touchable')):            attrsArray.append('touchable')        if(item.attr('editalbe')):            attrsArray.append('editalbe')        return attrsArraydef parseFreezeLayout(self, elementsArray):        sleep(5.0)        freeze = self.poco.freeze()        screen = G.DEVICE.snapshot(os.path.join(self.datapath, "snap.jpg"))        for item in freeze().offspring():            attrs = self.getUseableAttrs(item)            if(attrs):                 elementsArray.append(item)        return index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  这样我们就可以快速获得当前屏幕上可操作的控件元素。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>  遍历获取到的控件仅仅是屏幕区域内的控件，屏幕外的控件是无法获取的。换句话讲上述方面仅能获取到当前显示区域内的控件，一旦需要滑动屏幕才可显示的内容则<strong>一概获取不到</strong>。而屏幕滑动之后（无论滑动距离有多小），界面即刷新，而offspring又会从根节点出发重新依次遍历当前显示区域内的所有控件。如果能去掉重复的控件，那么我们就可以通过滑动获取到APP当前页面的所有可操作控件了。<br>  首先看看通过attr是否可获取类似Android R.id这样全局唯一的ID。梦想很美好，现实很残酷。在某些APP中似乎并没有对每一个可操作控件定义不一样的ID，这导致无法通过ID进行控件的区分。那么控件上的文字描述呢？比如按钮上显示的确定或取消字样。这也仅对部分app有效，因为随着UX设计越来越人性化，某些功能的按钮多以图形来表示，如：添加，撤销，搜索等等。至此我们已无法单纯的利用控件基本属性作为去重的判断依据。<br>  那么人在页面刷新后又是如何判断那些控件是新出现的，那些是之前已有的呢？这里不深入探讨视觉神经的工作原理，我们假设一个不识字的小孩可以怎样识别出新增控件的。答案很简单，依靠图形对比，在我们假设的这个小孩眼里只会有“绿色背景带有加号图形的方块”或“红色背景上面有些文字的圆圈”，并以此作为显示区域前后两次刷新对比的依据，“绿色背景带有加号图形的方块”在之前已出现过，“红色的家伙”之前没有。<br>  有了这样的假设，我们就可以以图像识别为抓手，对原有代码进行升级改造了。</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>  思路很简单，之前的逻辑已可以识别出当前显示区域所有可操作控件，那么我们可以对每个控件做区域截图（也就是仅把控件截图保存）。并将截图与其它控件的截图做图像对比，若图像一致，则认为是同一个控件，否则为新增控件。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">def saveCropScreen(self, screen, x, y, width, height, page, index):     cropscreen = aircv.crop_image(screen, [x,y,x+width,y+height])     path = self.datapath     for dir in page.split('-'):         path = os.path.join(path, dir)     if(not os.path.exists(path)):         os.makedirs(path)     path = os.path.join(path, '{}.jpg'.format(index))     aircv.imwrite(path, cropscreen, ST.SNAPSHOT_QUALITY, ST.IMAGE_MAXSIZE) return path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  而图像识别则是通过计算两张图片的哈希值，然后通过计算出汉明距离，来判断2张图像是否一致。一共采用了3种哈希算法，这里就不深入探讨彼此的优劣了。</p><pre class="line-numbers language-py" data-language="py"><code class="language-py">import cv2import numpy as npimport collectionsfrom airtest.core.api import *class UIConfidence:    @staticmethod    def flatten(x):        def iselement(e):            return not(isinstance(e, collections.Iterable) and not isinstance(e, str))        for el in x:            if(iselement(el)):                yield el            else:                yield from UIConfidence.flatten(el)    @staticmethod    def getAllHashValue(imgres):        return [UIConfidence.aHash(imgres), UIConfidence.dHash(imgres), UIConfidence.pHash(imgres)]    # 均值哈希算法    @staticmethod    def aHash(imgres):        img = cv2.imread(imgres)        # 缩放为8*8        img = cv2.resize(img, (8, 8), interpolation=cv2.INTER_CUBIC)        # 转换为灰度图        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)        # s为像素和初值为0，hash_str为hash值初值为''        s = 0        hash_str = ''        # 遍历累加求像素和        for i in range(8):            for j in range(8):                s = s + gray[i, j]        # 求平均灰度        avg = s / 64        # 灰度大于平均值为1相反为0生成图片的hash值        for i in range(8):            for j in range(8):                if gray[i, j] &gt; avg:                    hash_str = hash_str + '1'                else:                    hash_str = hash_str + '0'        return hash_str    # 差值感知算法    @staticmethod    def dHash(imgres):        img = cv2.imread(imgres)        # 缩放8*9        img = cv2.resize(img, (9, 8),interpolation=cv2.INTER_CUBIC)        # 转换灰度图        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)        hash_str = ''        # 每行前一个像素大于后一个像素为1，相反为0，生成哈希        for i in range(8):            for j in range(8):                if gray[i, j] &gt; gray[i, j + 1]:                    hash_str = hash_str + '1'                else:                    hash_str = hash_str + '0'        return hash_str    # 感知哈希算法(pHash)    @staticmethod    def pHash(imgres):                img = cv2.imread(imgres,0)        img = cv2.resize(img,(64,64), interpolation=cv2.INTER_CUBIC)        h,w=img.shape[:2]        vis0 = np.zeros((h,w),np.float32)        vis0[:h,:w] = img        vis1 = cv2.dct(cv2.dct(vis0))        vis1.resize(32,32)        img_list = list(UIConfidence.flatten(vis1.tolist()))        avg = sum(img_list)*1./len(img_list)        avg_list = ['0' if i&lt;avg else '1' for i in img_list]        return ''.join(['%x' % int(''.join(avg_list[x:x+4]),2) for x in range(0,32*32,4)])         # Hash值对比    @staticmethod    def cmpHash(hash1, hash2):        n = 0        # hash长度不同则返回-1代表传参出错        if len(hash1)!=len(hash2):            return -1        # 遍历判断        n = sum([ch1 != ch2 for ch1, ch2 in zip(hash1, hash2)])        print(n)        return n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="遗留"><a href="#遗留" class="headerlink" title="遗留"></a>遗留</h2><p>  虽然引入了opencv这样的大佬，但实际运行的效果还是差强人意，在对比背景颜色接近的控件时，大概率识别为同一个控件。</p><p><img lazyload="" src="/images/loading.svg" data-src="https://arts.ray0728.cn/images/2021/05/08/Screenshot_20210505_103757_com.android.settings_edit_56532789152822052830719968f71.jpg" alt="com.android.settings"></p><p>  如上图中桌面壁纸以及显示亮度均会被识别为与移动网络很相似（汉明距离小于2）。由此可见仅依赖简单的图像识别，似乎还不能接近完美的工作，后面我将继续探索如何更准确识别控件的方法 。</p>]]></content>
      
      
      <categories>
          
          <category> 图像处理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Airtest </tag>
            
            <tag> Python </tag>
            
            <tag> 图像识别 </tag>
            
            <tag> OpenCV </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
